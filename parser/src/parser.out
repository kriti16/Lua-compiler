Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    NEWLINE
    TDASH

Grammar

Rule 0     S' -> chunk
Rule 1     chunk -> chunk stat
Rule 2     chunk -> chunk stat SEMI
Rule 3     chunk -> chunk stat laststat
Rule 4     chunk -> chunk stat SEMI laststat SEMI
Rule 5     chunk -> empty
Rule 6     block -> chunk
Rule 7     stat -> varlist EQUALS explist
Rule 8     stat -> do block end
Rule 9     stat -> while exp do block end
Rule 10    stat -> repeat block until exp
Rule 11    stat -> if exp then block ifblock else block end
Rule 12    stat -> if exp then block ifblock end
Rule 13    stat -> for names EQUALS exp COMMA exp do block end
Rule 14    stat -> for names EQUALS exp COMMA exp COMMA exp do block end
Rule 15    stat -> for namelist in explist do block end
Rule 16    stat -> local namelist
Rule 17    stat -> local namelist EQUALS explist
Rule 18    stat -> function funcname funcbody
Rule 19    stat -> local function names funcbody
Rule 20    funcbody -> LPAREN RPAREN block end
Rule 21    funcbody -> LPAREN parlist RPAREN block end
Rule 22    parlist -> namelist
Rule 23    parlist -> namelist comtrp
Rule 24    parlist -> TRPLDOTS
Rule 25    comtrp -> COMMA TRPLDOTS
Rule 26    laststat -> return explist
Rule 27    laststat -> return
Rule 28    laststat -> break
Rule 29    funcname -> names dotid COLON
Rule 30    funcname -> names dotid
Rule 31    dotid -> SDOT names dotid
Rule 32    dotid -> empty
Rule 33    comvar -> COMMA var comvar
Rule 34    comvar -> empty
Rule 35    comid -> COMMA names comid
Rule 36    comid -> empty
Rule 37    ifblock -> ifblock elseif exp then block
Rule 38    ifblock -> empty
Rule 39    varlist -> var comvar
Rule 40    var -> names
Rule 41    var -> prefixexp LSQUARE exp RSQUARE
Rule 42    var -> prefixexp SDOT names
Rule 43    namelist -> names comid
Rule 44    explist -> explist COMMA exp
Rule 45    explist -> exp
Rule 46    exp -> nil
Rule 47    exp -> false
Rule 48    exp -> true
Rule 49    exp -> Number
Rule 50    exp -> STRING
Rule 51    exp -> TRPLDOTS
Rule 52    exp -> function
Rule 53    exp -> prefixexp
Rule 54    exp -> exp PLUS exp
Rule 55    exp -> exp MINUS exp
Rule 56    exp -> exp TIMES exp
Rule 57    exp -> exp DIVIDE exp
Rule 58    exp -> exp POWER exp
Rule 59    exp -> exp LT exp
Rule 60    exp -> exp LE exp
Rule 61    exp -> exp GT exp
Rule 62    exp -> exp GE exp
Rule 63    exp -> exp NE exp
Rule 64    exp -> exp CHECKEQ exp
Rule 65    exp -> exp and exp
Rule 66    exp -> exp or exp
Rule 67    exp -> exp MODULO exp
Rule 68    exp -> exp DBLDOTS exp
Rule 69    exp -> unop exp
Rule 70    exp -> tableconstructor
Rule 71    Number -> INTEGER
Rule 72    Number -> FLOAT
Rule 73    Number -> HEX
Rule 74    empty -> <empty>
Rule 75    prefixexp -> var
Rule 76    prefixexp -> LPAREN exp RPAREN
Rule 77    unop -> MINUS
Rule 78    unop -> not
Rule 79    unop -> HASH
Rule 80    tableconstructor -> LCURLY fieldlist RCURLY
Rule 81    tableconstructor -> LCURLY RCURLY
Rule 82    fieldlist -> field fieldseplist fieldsep
Rule 83    fieldlist -> field fieldseplist
Rule 84    fieldseplist -> fieldseplist fieldsep field
Rule 85    fieldseplist -> empty
Rule 86    field -> LSQUARE exp RSQUARE EQUALS exp
Rule 87    field -> names EQUALS exp
Rule 88    field -> exp
Rule 89    fieldsep -> COMMA
Rule 90    fieldsep -> SEMI
Rule 91    names -> ID
Rule 92    names -> RESID

Terminals, with rules where they appear

CHECKEQ              : 64
COLON                : 29
COMMA                : 13 14 14 25 33 35 44 89
DBLDOTS              : 68
DIVIDE               : 57
EQUALS               : 7 13 14 17 86 87
FLOAT                : 72
GE                   : 62
GT                   : 61
HASH                 : 79
HEX                  : 73
ID                   : 91
INTEGER              : 71
LCURLY               : 80 81
LE                   : 60
LPAREN               : 20 21 76
LSQUARE              : 41 86
LT                   : 59
MINUS                : 55 77
MODULO               : 67
NE                   : 63
NEWLINE              : 
PLUS                 : 54
POWER                : 58
RCURLY               : 80 81
RESID                : 92
RPAREN               : 20 21 76
RSQUARE              : 41 86
SDOT                 : 31 42
SEMI                 : 2 4 4 90
STRING               : 50
TDASH                : 
TIMES                : 56
TRPLDOTS             : 24 25 51
and                  : 65
break                : 28
do                   : 8 9 13 14 15
else                 : 11
elseif               : 37
end                  : 8 9 11 12 13 14 15 20 21
error                : 
false                : 47
for                  : 13 14 15
function             : 18 19 52
if                   : 11 12
in                   : 15
local                : 16 17 19
nil                  : 46
not                  : 78
or                   : 66
repeat               : 10
return               : 26 27
then                 : 11 12 37
true                 : 48
until                : 10
while                : 9

Nonterminals, with rules where they appear

Number               : 49
block                : 8 9 10 11 11 12 13 14 15 20 21 37
chunk                : 1 2 3 4 6 0
comid                : 35 43
comtrp               : 23
comvar               : 33 39
dotid                : 29 30 31
empty                : 5 32 34 36 38 85
exp                  : 9 10 11 12 13 13 14 14 14 37 41 44 45 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 76 86 86 87 88
explist              : 7 15 17 26 44
field                : 82 83 84
fieldlist            : 80
fieldsep             : 82 84
fieldseplist         : 82 83 84
funcbody             : 18 19
funcname             : 18
ifblock              : 11 12 37
laststat             : 3 4
namelist             : 15 16 17 22 23
names                : 13 14 19 29 30 31 35 40 42 43 87
parlist              : 21
prefixexp            : 41 42 53
stat                 : 1 2 3 4
tableconstructor     : 70
unop                 : 69
var                  : 33 39 75
varlist              : 7

Parsing method: LALR

state 0

    (0) S' -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    $end            reduce using rule 74 (empty -> .)

    chunk                          shift and go to state 2
    empty                          shift and go to state 1

state 1

    (5) chunk -> empty .

    do              reduce using rule 5 (chunk -> empty .)
    while           reduce using rule 5 (chunk -> empty .)
    repeat          reduce using rule 5 (chunk -> empty .)
    if              reduce using rule 5 (chunk -> empty .)
    for             reduce using rule 5 (chunk -> empty .)
    local           reduce using rule 5 (chunk -> empty .)
    function        reduce using rule 5 (chunk -> empty .)
    ID              reduce using rule 5 (chunk -> empty .)
    RESID           reduce using rule 5 (chunk -> empty .)
    LPAREN          reduce using rule 5 (chunk -> empty .)
    end             reduce using rule 5 (chunk -> empty .)
    else            reduce using rule 5 (chunk -> empty .)
    elseif          reduce using rule 5 (chunk -> empty .)
    $end            reduce using rule 5 (chunk -> empty .)
    until           reduce using rule 5 (chunk -> empty .)


state 2

    (0) S' -> chunk .
    (1) chunk -> chunk . stat
    (2) chunk -> chunk . stat SEMI
    (3) chunk -> chunk . stat laststat
    (4) chunk -> chunk . stat SEMI laststat SEMI
    (7) stat -> . varlist EQUALS explist
    (8) stat -> . do block end
    (9) stat -> . while exp do block end
    (10) stat -> . repeat block until exp
    (11) stat -> . if exp then block ifblock else block end
    (12) stat -> . if exp then block ifblock end
    (13) stat -> . for names EQUALS exp COMMA exp do block end
    (14) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (15) stat -> . for namelist in explist do block end
    (16) stat -> . local namelist
    (17) stat -> . local namelist EQUALS explist
    (18) stat -> . function funcname funcbody
    (19) stat -> . local function names funcbody
    (39) varlist -> . var comvar
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN

    do              shift and go to state 13
    while           shift and go to state 17
    repeat          shift and go to state 15
    if              shift and go to state 6
    for             shift and go to state 8
    local           shift and go to state 11
    function        shift and go to state 12
    ID              shift and go to state 16
    RESID           shift and go to state 3
    LPAREN          shift and go to state 4

    prefixexp                      shift and go to state 7
    stat                           shift and go to state 14
    varlist                        shift and go to state 9
    names                          shift and go to state 5
    var                            shift and go to state 10

state 3

    (92) names -> RESID .

    LSQUARE         reduce using rule 92 (names -> RESID .)
    SDOT            reduce using rule 92 (names -> RESID .)
    PLUS            reduce using rule 92 (names -> RESID .)
    MINUS           reduce using rule 92 (names -> RESID .)
    TIMES           reduce using rule 92 (names -> RESID .)
    DIVIDE          reduce using rule 92 (names -> RESID .)
    POWER           reduce using rule 92 (names -> RESID .)
    LT              reduce using rule 92 (names -> RESID .)
    LE              reduce using rule 92 (names -> RESID .)
    GT              reduce using rule 92 (names -> RESID .)
    GE              reduce using rule 92 (names -> RESID .)
    NE              reduce using rule 92 (names -> RESID .)
    CHECKEQ         reduce using rule 92 (names -> RESID .)
    and             reduce using rule 92 (names -> RESID .)
    or              reduce using rule 92 (names -> RESID .)
    MODULO          reduce using rule 92 (names -> RESID .)
    DBLDOTS         reduce using rule 92 (names -> RESID .)
    RPAREN          reduce using rule 92 (names -> RESID .)
    then            reduce using rule 92 (names -> RESID .)
    do              reduce using rule 92 (names -> RESID .)
    COMMA           reduce using rule 92 (names -> RESID .)
    SEMI            reduce using rule 92 (names -> RESID .)
    RCURLY          reduce using rule 92 (names -> RESID .)
    RSQUARE         reduce using rule 92 (names -> RESID .)
    return          reduce using rule 92 (names -> RESID .)
    break           reduce using rule 92 (names -> RESID .)
    while           reduce using rule 92 (names -> RESID .)
    repeat          reduce using rule 92 (names -> RESID .)
    if              reduce using rule 92 (names -> RESID .)
    for             reduce using rule 92 (names -> RESID .)
    local           reduce using rule 92 (names -> RESID .)
    function        reduce using rule 92 (names -> RESID .)
    ID              reduce using rule 92 (names -> RESID .)
    RESID           reduce using rule 92 (names -> RESID .)
    LPAREN          reduce using rule 92 (names -> RESID .)
    $end            reduce using rule 92 (names -> RESID .)
    end             reduce using rule 92 (names -> RESID .)
    until           reduce using rule 92 (names -> RESID .)
    else            reduce using rule 92 (names -> RESID .)
    elseif          reduce using rule 92 (names -> RESID .)
    EQUALS          reduce using rule 92 (names -> RESID .)
    COLON           reduce using rule 92 (names -> RESID .)
    in              reduce using rule 92 (names -> RESID .)


state 4

    (76) prefixexp -> LPAREN . exp RPAREN
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 35
    var                            shift and go to state 26
    names                          shift and go to state 5

state 5

    (40) var -> names .

    LSQUARE         reduce using rule 40 (var -> names .)
    SDOT            reduce using rule 40 (var -> names .)
    PLUS            reduce using rule 40 (var -> names .)
    MINUS           reduce using rule 40 (var -> names .)
    TIMES           reduce using rule 40 (var -> names .)
    DIVIDE          reduce using rule 40 (var -> names .)
    POWER           reduce using rule 40 (var -> names .)
    LT              reduce using rule 40 (var -> names .)
    LE              reduce using rule 40 (var -> names .)
    GT              reduce using rule 40 (var -> names .)
    GE              reduce using rule 40 (var -> names .)
    NE              reduce using rule 40 (var -> names .)
    CHECKEQ         reduce using rule 40 (var -> names .)
    and             reduce using rule 40 (var -> names .)
    or              reduce using rule 40 (var -> names .)
    MODULO          reduce using rule 40 (var -> names .)
    DBLDOTS         reduce using rule 40 (var -> names .)
    SEMI            reduce using rule 40 (var -> names .)
    return          reduce using rule 40 (var -> names .)
    break           reduce using rule 40 (var -> names .)
    do              reduce using rule 40 (var -> names .)
    while           reduce using rule 40 (var -> names .)
    repeat          reduce using rule 40 (var -> names .)
    if              reduce using rule 40 (var -> names .)
    for             reduce using rule 40 (var -> names .)
    local           reduce using rule 40 (var -> names .)
    function        reduce using rule 40 (var -> names .)
    ID              reduce using rule 40 (var -> names .)
    RESID           reduce using rule 40 (var -> names .)
    LPAREN          reduce using rule 40 (var -> names .)
    $end            reduce using rule 40 (var -> names .)
    end             reduce using rule 40 (var -> names .)
    until           reduce using rule 40 (var -> names .)
    else            reduce using rule 40 (var -> names .)
    elseif          reduce using rule 40 (var -> names .)
    COMMA           reduce using rule 40 (var -> names .)
    EQUALS          reduce using rule 40 (var -> names .)
    RPAREN          reduce using rule 40 (var -> names .)
    then            reduce using rule 40 (var -> names .)
    RCURLY          reduce using rule 40 (var -> names .)
    RSQUARE         reduce using rule 40 (var -> names .)


state 6

    (11) stat -> if . exp then block ifblock else block end
    (12) stat -> if . exp then block ifblock end
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 37
    var                            shift and go to state 26
    names                          shift and go to state 5

state 7

    (41) var -> prefixexp . LSQUARE exp RSQUARE
    (42) var -> prefixexp . SDOT names

    LSQUARE         shift and go to state 38
    SDOT            shift and go to state 39


state 8

    (13) stat -> for . names EQUALS exp COMMA exp do block end
    (14) stat -> for . names EQUALS exp COMMA exp COMMA exp do block end
    (15) stat -> for . namelist in explist do block end
    (91) names -> . ID
    (92) names -> . RESID
    (43) namelist -> . names comid

    ID              shift and go to state 16
    RESID           shift and go to state 3

    namelist                       shift and go to state 40
    names                          shift and go to state 41

state 9

    (7) stat -> varlist . EQUALS explist

    EQUALS          shift and go to state 42


state 10

    (39) varlist -> var . comvar
    (75) prefixexp -> var .
    (33) comvar -> . COMMA var comvar
    (34) comvar -> . empty
    (74) empty -> .

    LSQUARE         reduce using rule 75 (prefixexp -> var .)
    SDOT            reduce using rule 75 (prefixexp -> var .)
    COMMA           shift and go to state 43
    EQUALS          reduce using rule 74 (empty -> .)

    comvar                         shift and go to state 44
    empty                          shift and go to state 45

state 11

    (16) stat -> local . namelist
    (17) stat -> local . namelist EQUALS explist
    (19) stat -> local . function names funcbody
    (43) namelist -> . names comid
    (91) names -> . ID
    (92) names -> . RESID

    function        shift and go to state 46
    ID              shift and go to state 16
    RESID           shift and go to state 3

    namelist                       shift and go to state 47
    names                          shift and go to state 48

state 12

    (18) stat -> function . funcname funcbody
    (29) funcname -> . names dotid COLON
    (30) funcname -> . names dotid
    (91) names -> . ID
    (92) names -> . RESID

    ID              shift and go to state 16
    RESID           shift and go to state 3

    names                          shift and go to state 50
    funcname                       shift and go to state 49

state 13

    (8) stat -> do . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)

    empty                          shift and go to state 1
    chunk                          shift and go to state 51
    block                          shift and go to state 52

state 14

    (1) chunk -> chunk stat .
    (2) chunk -> chunk stat . SEMI
    (3) chunk -> chunk stat . laststat
    (4) chunk -> chunk stat . SEMI laststat SEMI
    (26) laststat -> . return explist
    (27) laststat -> . return
    (28) laststat -> . break

    do              reduce using rule 1 (chunk -> chunk stat .)
    while           reduce using rule 1 (chunk -> chunk stat .)
    repeat          reduce using rule 1 (chunk -> chunk stat .)
    if              reduce using rule 1 (chunk -> chunk stat .)
    for             reduce using rule 1 (chunk -> chunk stat .)
    local           reduce using rule 1 (chunk -> chunk stat .)
    function        reduce using rule 1 (chunk -> chunk stat .)
    ID              reduce using rule 1 (chunk -> chunk stat .)
    RESID           reduce using rule 1 (chunk -> chunk stat .)
    LPAREN          reduce using rule 1 (chunk -> chunk stat .)
    end             reduce using rule 1 (chunk -> chunk stat .)
    else            reduce using rule 1 (chunk -> chunk stat .)
    elseif          reduce using rule 1 (chunk -> chunk stat .)
    $end            reduce using rule 1 (chunk -> chunk stat .)
    until           reduce using rule 1 (chunk -> chunk stat .)
    SEMI            shift and go to state 54
    return          shift and go to state 53
    break           shift and go to state 56

    laststat                       shift and go to state 55

state 15

    (10) stat -> repeat . block until exp
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    until           reduce using rule 74 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 57

state 16

    (91) names -> ID .

    LSQUARE         reduce using rule 91 (names -> ID .)
    SDOT            reduce using rule 91 (names -> ID .)
    PLUS            reduce using rule 91 (names -> ID .)
    MINUS           reduce using rule 91 (names -> ID .)
    TIMES           reduce using rule 91 (names -> ID .)
    DIVIDE          reduce using rule 91 (names -> ID .)
    POWER           reduce using rule 91 (names -> ID .)
    LT              reduce using rule 91 (names -> ID .)
    LE              reduce using rule 91 (names -> ID .)
    GT              reduce using rule 91 (names -> ID .)
    GE              reduce using rule 91 (names -> ID .)
    NE              reduce using rule 91 (names -> ID .)
    CHECKEQ         reduce using rule 91 (names -> ID .)
    and             reduce using rule 91 (names -> ID .)
    or              reduce using rule 91 (names -> ID .)
    MODULO          reduce using rule 91 (names -> ID .)
    DBLDOTS         reduce using rule 91 (names -> ID .)
    RPAREN          reduce using rule 91 (names -> ID .)
    then            reduce using rule 91 (names -> ID .)
    do              reduce using rule 91 (names -> ID .)
    COMMA           reduce using rule 91 (names -> ID .)
    SEMI            reduce using rule 91 (names -> ID .)
    RCURLY          reduce using rule 91 (names -> ID .)
    RSQUARE         reduce using rule 91 (names -> ID .)
    return          reduce using rule 91 (names -> ID .)
    break           reduce using rule 91 (names -> ID .)
    while           reduce using rule 91 (names -> ID .)
    repeat          reduce using rule 91 (names -> ID .)
    if              reduce using rule 91 (names -> ID .)
    for             reduce using rule 91 (names -> ID .)
    local           reduce using rule 91 (names -> ID .)
    function        reduce using rule 91 (names -> ID .)
    ID              reduce using rule 91 (names -> ID .)
    RESID           reduce using rule 91 (names -> ID .)
    LPAREN          reduce using rule 91 (names -> ID .)
    $end            reduce using rule 91 (names -> ID .)
    end             reduce using rule 91 (names -> ID .)
    until           reduce using rule 91 (names -> ID .)
    else            reduce using rule 91 (names -> ID .)
    elseif          reduce using rule 91 (names -> ID .)
    EQUALS          reduce using rule 91 (names -> ID .)
    COLON           reduce using rule 91 (names -> ID .)
    in              reduce using rule 91 (names -> ID .)


state 17

    (9) stat -> while . exp do block end
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 58
    var                            shift and go to state 26
    names                          shift and go to state 5

state 18

    (69) exp -> unop . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    unop                           shift and go to state 18
    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 59
    var                            shift and go to state 26
    names                          shift and go to state 5

state 19

    (70) exp -> tableconstructor .

    then            reduce using rule 70 (exp -> tableconstructor .)
    PLUS            reduce using rule 70 (exp -> tableconstructor .)
    MINUS           reduce using rule 70 (exp -> tableconstructor .)
    TIMES           reduce using rule 70 (exp -> tableconstructor .)
    DIVIDE          reduce using rule 70 (exp -> tableconstructor .)
    POWER           reduce using rule 70 (exp -> tableconstructor .)
    LT              reduce using rule 70 (exp -> tableconstructor .)
    LE              reduce using rule 70 (exp -> tableconstructor .)
    GT              reduce using rule 70 (exp -> tableconstructor .)
    GE              reduce using rule 70 (exp -> tableconstructor .)
    NE              reduce using rule 70 (exp -> tableconstructor .)
    CHECKEQ         reduce using rule 70 (exp -> tableconstructor .)
    and             reduce using rule 70 (exp -> tableconstructor .)
    or              reduce using rule 70 (exp -> tableconstructor .)
    MODULO          reduce using rule 70 (exp -> tableconstructor .)
    DBLDOTS         reduce using rule 70 (exp -> tableconstructor .)
    RPAREN          reduce using rule 70 (exp -> tableconstructor .)
    do              reduce using rule 70 (exp -> tableconstructor .)
    COMMA           reduce using rule 70 (exp -> tableconstructor .)
    SEMI            reduce using rule 70 (exp -> tableconstructor .)
    RCURLY          reduce using rule 70 (exp -> tableconstructor .)
    RSQUARE         reduce using rule 70 (exp -> tableconstructor .)
    return          reduce using rule 70 (exp -> tableconstructor .)
    break           reduce using rule 70 (exp -> tableconstructor .)
    while           reduce using rule 70 (exp -> tableconstructor .)
    repeat          reduce using rule 70 (exp -> tableconstructor .)
    if              reduce using rule 70 (exp -> tableconstructor .)
    for             reduce using rule 70 (exp -> tableconstructor .)
    local           reduce using rule 70 (exp -> tableconstructor .)
    function        reduce using rule 70 (exp -> tableconstructor .)
    ID              reduce using rule 70 (exp -> tableconstructor .)
    RESID           reduce using rule 70 (exp -> tableconstructor .)
    LPAREN          reduce using rule 70 (exp -> tableconstructor .)
    $end            reduce using rule 70 (exp -> tableconstructor .)
    end             reduce using rule 70 (exp -> tableconstructor .)
    until           reduce using rule 70 (exp -> tableconstructor .)
    else            reduce using rule 70 (exp -> tableconstructor .)
    elseif          reduce using rule 70 (exp -> tableconstructor .)


state 20

    (47) exp -> false .

    then            reduce using rule 47 (exp -> false .)
    PLUS            reduce using rule 47 (exp -> false .)
    MINUS           reduce using rule 47 (exp -> false .)
    TIMES           reduce using rule 47 (exp -> false .)
    DIVIDE          reduce using rule 47 (exp -> false .)
    POWER           reduce using rule 47 (exp -> false .)
    LT              reduce using rule 47 (exp -> false .)
    LE              reduce using rule 47 (exp -> false .)
    GT              reduce using rule 47 (exp -> false .)
    GE              reduce using rule 47 (exp -> false .)
    NE              reduce using rule 47 (exp -> false .)
    CHECKEQ         reduce using rule 47 (exp -> false .)
    and             reduce using rule 47 (exp -> false .)
    or              reduce using rule 47 (exp -> false .)
    MODULO          reduce using rule 47 (exp -> false .)
    DBLDOTS         reduce using rule 47 (exp -> false .)
    RPAREN          reduce using rule 47 (exp -> false .)
    do              reduce using rule 47 (exp -> false .)
    COMMA           reduce using rule 47 (exp -> false .)
    SEMI            reduce using rule 47 (exp -> false .)
    RCURLY          reduce using rule 47 (exp -> false .)
    RSQUARE         reduce using rule 47 (exp -> false .)
    return          reduce using rule 47 (exp -> false .)
    break           reduce using rule 47 (exp -> false .)
    while           reduce using rule 47 (exp -> false .)
    repeat          reduce using rule 47 (exp -> false .)
    if              reduce using rule 47 (exp -> false .)
    for             reduce using rule 47 (exp -> false .)
    local           reduce using rule 47 (exp -> false .)
    function        reduce using rule 47 (exp -> false .)
    ID              reduce using rule 47 (exp -> false .)
    RESID           reduce using rule 47 (exp -> false .)
    LPAREN          reduce using rule 47 (exp -> false .)
    $end            reduce using rule 47 (exp -> false .)
    end             reduce using rule 47 (exp -> false .)
    until           reduce using rule 47 (exp -> false .)
    else            reduce using rule 47 (exp -> false .)
    elseif          reduce using rule 47 (exp -> false .)


state 21

    (80) tableconstructor -> LCURLY . fieldlist RCURLY
    (81) tableconstructor -> LCURLY . RCURLY
    (82) fieldlist -> . field fieldseplist fieldsep
    (83) fieldlist -> . field fieldseplist
    (86) field -> . LSQUARE exp RSQUARE EQUALS exp
    (87) field -> . names EQUALS exp
    (88) field -> . exp
    (91) names -> . ID
    (92) names -> . RESID
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names

    RCURLY          shift and go to state 61
    LSQUARE         shift and go to state 65
    ID              shift and go to state 16
    RESID           shift and go to state 3
    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    field                          shift and go to state 62
    unop                           shift and go to state 18
    fieldlist                      shift and go to state 63
    exp                            shift and go to state 64
    var                            shift and go to state 26
    names                          shift and go to state 60

state 22

    (79) unop -> HASH .

    nil             reduce using rule 79 (unop -> HASH .)
    false           reduce using rule 79 (unop -> HASH .)
    true            reduce using rule 79 (unop -> HASH .)
    STRING          reduce using rule 79 (unop -> HASH .)
    TRPLDOTS        reduce using rule 79 (unop -> HASH .)
    function        reduce using rule 79 (unop -> HASH .)
    INTEGER         reduce using rule 79 (unop -> HASH .)
    FLOAT           reduce using rule 79 (unop -> HASH .)
    HEX             reduce using rule 79 (unop -> HASH .)
    LPAREN          reduce using rule 79 (unop -> HASH .)
    MINUS           reduce using rule 79 (unop -> HASH .)
    not             reduce using rule 79 (unop -> HASH .)
    HASH            reduce using rule 79 (unop -> HASH .)
    LCURLY          reduce using rule 79 (unop -> HASH .)
    ID              reduce using rule 79 (unop -> HASH .)
    RESID           reduce using rule 79 (unop -> HASH .)


state 23

    (77) unop -> MINUS .

    nil             reduce using rule 77 (unop -> MINUS .)
    false           reduce using rule 77 (unop -> MINUS .)
    true            reduce using rule 77 (unop -> MINUS .)
    STRING          reduce using rule 77 (unop -> MINUS .)
    TRPLDOTS        reduce using rule 77 (unop -> MINUS .)
    function        reduce using rule 77 (unop -> MINUS .)
    INTEGER         reduce using rule 77 (unop -> MINUS .)
    FLOAT           reduce using rule 77 (unop -> MINUS .)
    HEX             reduce using rule 77 (unop -> MINUS .)
    LPAREN          reduce using rule 77 (unop -> MINUS .)
    MINUS           reduce using rule 77 (unop -> MINUS .)
    not             reduce using rule 77 (unop -> MINUS .)
    HASH            reduce using rule 77 (unop -> MINUS .)
    LCURLY          reduce using rule 77 (unop -> MINUS .)
    ID              reduce using rule 77 (unop -> MINUS .)
    RESID           reduce using rule 77 (unop -> MINUS .)


state 24

    (50) exp -> STRING .

    then            reduce using rule 50 (exp -> STRING .)
    PLUS            reduce using rule 50 (exp -> STRING .)
    MINUS           reduce using rule 50 (exp -> STRING .)
    TIMES           reduce using rule 50 (exp -> STRING .)
    DIVIDE          reduce using rule 50 (exp -> STRING .)
    POWER           reduce using rule 50 (exp -> STRING .)
    LT              reduce using rule 50 (exp -> STRING .)
    LE              reduce using rule 50 (exp -> STRING .)
    GT              reduce using rule 50 (exp -> STRING .)
    GE              reduce using rule 50 (exp -> STRING .)
    NE              reduce using rule 50 (exp -> STRING .)
    CHECKEQ         reduce using rule 50 (exp -> STRING .)
    and             reduce using rule 50 (exp -> STRING .)
    or              reduce using rule 50 (exp -> STRING .)
    MODULO          reduce using rule 50 (exp -> STRING .)
    DBLDOTS         reduce using rule 50 (exp -> STRING .)
    RPAREN          reduce using rule 50 (exp -> STRING .)
    do              reduce using rule 50 (exp -> STRING .)
    COMMA           reduce using rule 50 (exp -> STRING .)
    SEMI            reduce using rule 50 (exp -> STRING .)
    RCURLY          reduce using rule 50 (exp -> STRING .)
    RSQUARE         reduce using rule 50 (exp -> STRING .)
    return          reduce using rule 50 (exp -> STRING .)
    break           reduce using rule 50 (exp -> STRING .)
    while           reduce using rule 50 (exp -> STRING .)
    repeat          reduce using rule 50 (exp -> STRING .)
    if              reduce using rule 50 (exp -> STRING .)
    for             reduce using rule 50 (exp -> STRING .)
    local           reduce using rule 50 (exp -> STRING .)
    function        reduce using rule 50 (exp -> STRING .)
    ID              reduce using rule 50 (exp -> STRING .)
    RESID           reduce using rule 50 (exp -> STRING .)
    LPAREN          reduce using rule 50 (exp -> STRING .)
    $end            reduce using rule 50 (exp -> STRING .)
    end             reduce using rule 50 (exp -> STRING .)
    until           reduce using rule 50 (exp -> STRING .)
    else            reduce using rule 50 (exp -> STRING .)
    elseif          reduce using rule 50 (exp -> STRING .)


state 25

    (53) exp -> prefixexp .
    (41) var -> prefixexp . LSQUARE exp RSQUARE
    (42) var -> prefixexp . SDOT names

    then            reduce using rule 53 (exp -> prefixexp .)
    PLUS            reduce using rule 53 (exp -> prefixexp .)
    MINUS           reduce using rule 53 (exp -> prefixexp .)
    TIMES           reduce using rule 53 (exp -> prefixexp .)
    DIVIDE          reduce using rule 53 (exp -> prefixexp .)
    POWER           reduce using rule 53 (exp -> prefixexp .)
    LT              reduce using rule 53 (exp -> prefixexp .)
    LE              reduce using rule 53 (exp -> prefixexp .)
    GT              reduce using rule 53 (exp -> prefixexp .)
    GE              reduce using rule 53 (exp -> prefixexp .)
    NE              reduce using rule 53 (exp -> prefixexp .)
    CHECKEQ         reduce using rule 53 (exp -> prefixexp .)
    and             reduce using rule 53 (exp -> prefixexp .)
    or              reduce using rule 53 (exp -> prefixexp .)
    MODULO          reduce using rule 53 (exp -> prefixexp .)
    DBLDOTS         reduce using rule 53 (exp -> prefixexp .)
    RPAREN          reduce using rule 53 (exp -> prefixexp .)
    do              reduce using rule 53 (exp -> prefixexp .)
    COMMA           reduce using rule 53 (exp -> prefixexp .)
    SEMI            reduce using rule 53 (exp -> prefixexp .)
    RCURLY          reduce using rule 53 (exp -> prefixexp .)
    RSQUARE         reduce using rule 53 (exp -> prefixexp .)
    return          reduce using rule 53 (exp -> prefixexp .)
    break           reduce using rule 53 (exp -> prefixexp .)
    while           reduce using rule 53 (exp -> prefixexp .)
    repeat          reduce using rule 53 (exp -> prefixexp .)
    if              reduce using rule 53 (exp -> prefixexp .)
    for             reduce using rule 53 (exp -> prefixexp .)
    local           reduce using rule 53 (exp -> prefixexp .)
    function        reduce using rule 53 (exp -> prefixexp .)
    ID              reduce using rule 53 (exp -> prefixexp .)
    RESID           reduce using rule 53 (exp -> prefixexp .)
    LPAREN          reduce using rule 53 (exp -> prefixexp .)
    $end            reduce using rule 53 (exp -> prefixexp .)
    end             reduce using rule 53 (exp -> prefixexp .)
    until           reduce using rule 53 (exp -> prefixexp .)
    else            reduce using rule 53 (exp -> prefixexp .)
    elseif          reduce using rule 53 (exp -> prefixexp .)
    LSQUARE         shift and go to state 38
    SDOT            shift and go to state 39


state 26

    (75) prefixexp -> var .

    LSQUARE         reduce using rule 75 (prefixexp -> var .)
    SDOT            reduce using rule 75 (prefixexp -> var .)
    RSQUARE         reduce using rule 75 (prefixexp -> var .)
    PLUS            reduce using rule 75 (prefixexp -> var .)
    MINUS           reduce using rule 75 (prefixexp -> var .)
    TIMES           reduce using rule 75 (prefixexp -> var .)
    DIVIDE          reduce using rule 75 (prefixexp -> var .)
    POWER           reduce using rule 75 (prefixexp -> var .)
    LT              reduce using rule 75 (prefixexp -> var .)
    LE              reduce using rule 75 (prefixexp -> var .)
    GT              reduce using rule 75 (prefixexp -> var .)
    GE              reduce using rule 75 (prefixexp -> var .)
    NE              reduce using rule 75 (prefixexp -> var .)
    CHECKEQ         reduce using rule 75 (prefixexp -> var .)
    and             reduce using rule 75 (prefixexp -> var .)
    or              reduce using rule 75 (prefixexp -> var .)
    MODULO          reduce using rule 75 (prefixexp -> var .)
    DBLDOTS         reduce using rule 75 (prefixexp -> var .)
    RPAREN          reduce using rule 75 (prefixexp -> var .)
    then            reduce using rule 75 (prefixexp -> var .)
    do              reduce using rule 75 (prefixexp -> var .)
    COMMA           reduce using rule 75 (prefixexp -> var .)
    SEMI            reduce using rule 75 (prefixexp -> var .)
    RCURLY          reduce using rule 75 (prefixexp -> var .)
    return          reduce using rule 75 (prefixexp -> var .)
    break           reduce using rule 75 (prefixexp -> var .)
    while           reduce using rule 75 (prefixexp -> var .)
    repeat          reduce using rule 75 (prefixexp -> var .)
    if              reduce using rule 75 (prefixexp -> var .)
    for             reduce using rule 75 (prefixexp -> var .)
    local           reduce using rule 75 (prefixexp -> var .)
    function        reduce using rule 75 (prefixexp -> var .)
    ID              reduce using rule 75 (prefixexp -> var .)
    RESID           reduce using rule 75 (prefixexp -> var .)
    LPAREN          reduce using rule 75 (prefixexp -> var .)
    $end            reduce using rule 75 (prefixexp -> var .)
    end             reduce using rule 75 (prefixexp -> var .)
    until           reduce using rule 75 (prefixexp -> var .)
    else            reduce using rule 75 (prefixexp -> var .)
    elseif          reduce using rule 75 (prefixexp -> var .)


state 27

    (71) Number -> INTEGER .

    PLUS            reduce using rule 71 (Number -> INTEGER .)
    MINUS           reduce using rule 71 (Number -> INTEGER .)
    TIMES           reduce using rule 71 (Number -> INTEGER .)
    DIVIDE          reduce using rule 71 (Number -> INTEGER .)
    POWER           reduce using rule 71 (Number -> INTEGER .)
    LT              reduce using rule 71 (Number -> INTEGER .)
    LE              reduce using rule 71 (Number -> INTEGER .)
    GT              reduce using rule 71 (Number -> INTEGER .)
    GE              reduce using rule 71 (Number -> INTEGER .)
    NE              reduce using rule 71 (Number -> INTEGER .)
    CHECKEQ         reduce using rule 71 (Number -> INTEGER .)
    and             reduce using rule 71 (Number -> INTEGER .)
    or              reduce using rule 71 (Number -> INTEGER .)
    MODULO          reduce using rule 71 (Number -> INTEGER .)
    DBLDOTS         reduce using rule 71 (Number -> INTEGER .)
    COMMA           reduce using rule 71 (Number -> INTEGER .)
    SEMI            reduce using rule 71 (Number -> INTEGER .)
    return          reduce using rule 71 (Number -> INTEGER .)
    break           reduce using rule 71 (Number -> INTEGER .)
    do              reduce using rule 71 (Number -> INTEGER .)
    while           reduce using rule 71 (Number -> INTEGER .)
    repeat          reduce using rule 71 (Number -> INTEGER .)
    if              reduce using rule 71 (Number -> INTEGER .)
    for             reduce using rule 71 (Number -> INTEGER .)
    local           reduce using rule 71 (Number -> INTEGER .)
    function        reduce using rule 71 (Number -> INTEGER .)
    ID              reduce using rule 71 (Number -> INTEGER .)
    RESID           reduce using rule 71 (Number -> INTEGER .)
    LPAREN          reduce using rule 71 (Number -> INTEGER .)
    $end            reduce using rule 71 (Number -> INTEGER .)
    end             reduce using rule 71 (Number -> INTEGER .)
    until           reduce using rule 71 (Number -> INTEGER .)
    else            reduce using rule 71 (Number -> INTEGER .)
    elseif          reduce using rule 71 (Number -> INTEGER .)
    RPAREN          reduce using rule 71 (Number -> INTEGER .)
    then            reduce using rule 71 (Number -> INTEGER .)
    RCURLY          reduce using rule 71 (Number -> INTEGER .)
    RSQUARE         reduce using rule 71 (Number -> INTEGER .)


state 28

    (52) exp -> function .

    then            reduce using rule 52 (exp -> function .)
    PLUS            reduce using rule 52 (exp -> function .)
    MINUS           reduce using rule 52 (exp -> function .)
    TIMES           reduce using rule 52 (exp -> function .)
    DIVIDE          reduce using rule 52 (exp -> function .)
    POWER           reduce using rule 52 (exp -> function .)
    LT              reduce using rule 52 (exp -> function .)
    LE              reduce using rule 52 (exp -> function .)
    GT              reduce using rule 52 (exp -> function .)
    GE              reduce using rule 52 (exp -> function .)
    NE              reduce using rule 52 (exp -> function .)
    CHECKEQ         reduce using rule 52 (exp -> function .)
    and             reduce using rule 52 (exp -> function .)
    or              reduce using rule 52 (exp -> function .)
    MODULO          reduce using rule 52 (exp -> function .)
    DBLDOTS         reduce using rule 52 (exp -> function .)
    RPAREN          reduce using rule 52 (exp -> function .)
    do              reduce using rule 52 (exp -> function .)
    COMMA           reduce using rule 52 (exp -> function .)
    SEMI            reduce using rule 52 (exp -> function .)
    RCURLY          reduce using rule 52 (exp -> function .)
    RSQUARE         reduce using rule 52 (exp -> function .)
    return          reduce using rule 52 (exp -> function .)
    break           reduce using rule 52 (exp -> function .)
    while           reduce using rule 52 (exp -> function .)
    repeat          reduce using rule 52 (exp -> function .)
    if              reduce using rule 52 (exp -> function .)
    for             reduce using rule 52 (exp -> function .)
    local           reduce using rule 52 (exp -> function .)
    function        reduce using rule 52 (exp -> function .)
    ID              reduce using rule 52 (exp -> function .)
    RESID           reduce using rule 52 (exp -> function .)
    LPAREN          reduce using rule 52 (exp -> function .)
    $end            reduce using rule 52 (exp -> function .)
    end             reduce using rule 52 (exp -> function .)
    until           reduce using rule 52 (exp -> function .)
    else            reduce using rule 52 (exp -> function .)
    elseif          reduce using rule 52 (exp -> function .)


state 29

    (46) exp -> nil .

    then            reduce using rule 46 (exp -> nil .)
    PLUS            reduce using rule 46 (exp -> nil .)
    MINUS           reduce using rule 46 (exp -> nil .)
    TIMES           reduce using rule 46 (exp -> nil .)
    DIVIDE          reduce using rule 46 (exp -> nil .)
    POWER           reduce using rule 46 (exp -> nil .)
    LT              reduce using rule 46 (exp -> nil .)
    LE              reduce using rule 46 (exp -> nil .)
    GT              reduce using rule 46 (exp -> nil .)
    GE              reduce using rule 46 (exp -> nil .)
    NE              reduce using rule 46 (exp -> nil .)
    CHECKEQ         reduce using rule 46 (exp -> nil .)
    and             reduce using rule 46 (exp -> nil .)
    or              reduce using rule 46 (exp -> nil .)
    MODULO          reduce using rule 46 (exp -> nil .)
    DBLDOTS         reduce using rule 46 (exp -> nil .)
    RPAREN          reduce using rule 46 (exp -> nil .)
    do              reduce using rule 46 (exp -> nil .)
    COMMA           reduce using rule 46 (exp -> nil .)
    SEMI            reduce using rule 46 (exp -> nil .)
    RCURLY          reduce using rule 46 (exp -> nil .)
    RSQUARE         reduce using rule 46 (exp -> nil .)
    return          reduce using rule 46 (exp -> nil .)
    break           reduce using rule 46 (exp -> nil .)
    while           reduce using rule 46 (exp -> nil .)
    repeat          reduce using rule 46 (exp -> nil .)
    if              reduce using rule 46 (exp -> nil .)
    for             reduce using rule 46 (exp -> nil .)
    local           reduce using rule 46 (exp -> nil .)
    function        reduce using rule 46 (exp -> nil .)
    ID              reduce using rule 46 (exp -> nil .)
    RESID           reduce using rule 46 (exp -> nil .)
    LPAREN          reduce using rule 46 (exp -> nil .)
    $end            reduce using rule 46 (exp -> nil .)
    end             reduce using rule 46 (exp -> nil .)
    until           reduce using rule 46 (exp -> nil .)
    else            reduce using rule 46 (exp -> nil .)
    elseif          reduce using rule 46 (exp -> nil .)


state 30

    (73) Number -> HEX .

    PLUS            reduce using rule 73 (Number -> HEX .)
    MINUS           reduce using rule 73 (Number -> HEX .)
    TIMES           reduce using rule 73 (Number -> HEX .)
    DIVIDE          reduce using rule 73 (Number -> HEX .)
    POWER           reduce using rule 73 (Number -> HEX .)
    LT              reduce using rule 73 (Number -> HEX .)
    LE              reduce using rule 73 (Number -> HEX .)
    GT              reduce using rule 73 (Number -> HEX .)
    GE              reduce using rule 73 (Number -> HEX .)
    NE              reduce using rule 73 (Number -> HEX .)
    CHECKEQ         reduce using rule 73 (Number -> HEX .)
    and             reduce using rule 73 (Number -> HEX .)
    or              reduce using rule 73 (Number -> HEX .)
    MODULO          reduce using rule 73 (Number -> HEX .)
    DBLDOTS         reduce using rule 73 (Number -> HEX .)
    COMMA           reduce using rule 73 (Number -> HEX .)
    SEMI            reduce using rule 73 (Number -> HEX .)
    return          reduce using rule 73 (Number -> HEX .)
    break           reduce using rule 73 (Number -> HEX .)
    do              reduce using rule 73 (Number -> HEX .)
    while           reduce using rule 73 (Number -> HEX .)
    repeat          reduce using rule 73 (Number -> HEX .)
    if              reduce using rule 73 (Number -> HEX .)
    for             reduce using rule 73 (Number -> HEX .)
    local           reduce using rule 73 (Number -> HEX .)
    function        reduce using rule 73 (Number -> HEX .)
    ID              reduce using rule 73 (Number -> HEX .)
    RESID           reduce using rule 73 (Number -> HEX .)
    LPAREN          reduce using rule 73 (Number -> HEX .)
    $end            reduce using rule 73 (Number -> HEX .)
    end             reduce using rule 73 (Number -> HEX .)
    until           reduce using rule 73 (Number -> HEX .)
    else            reduce using rule 73 (Number -> HEX .)
    elseif          reduce using rule 73 (Number -> HEX .)
    RPAREN          reduce using rule 73 (Number -> HEX .)
    then            reduce using rule 73 (Number -> HEX .)
    RCURLY          reduce using rule 73 (Number -> HEX .)
    RSQUARE         reduce using rule 73 (Number -> HEX .)


state 31

    (78) unop -> not .

    nil             reduce using rule 78 (unop -> not .)
    false           reduce using rule 78 (unop -> not .)
    true            reduce using rule 78 (unop -> not .)
    STRING          reduce using rule 78 (unop -> not .)
    TRPLDOTS        reduce using rule 78 (unop -> not .)
    function        reduce using rule 78 (unop -> not .)
    INTEGER         reduce using rule 78 (unop -> not .)
    FLOAT           reduce using rule 78 (unop -> not .)
    HEX             reduce using rule 78 (unop -> not .)
    LPAREN          reduce using rule 78 (unop -> not .)
    MINUS           reduce using rule 78 (unop -> not .)
    not             reduce using rule 78 (unop -> not .)
    HASH            reduce using rule 78 (unop -> not .)
    LCURLY          reduce using rule 78 (unop -> not .)
    ID              reduce using rule 78 (unop -> not .)
    RESID           reduce using rule 78 (unop -> not .)


state 32

    (48) exp -> true .

    then            reduce using rule 48 (exp -> true .)
    PLUS            reduce using rule 48 (exp -> true .)
    MINUS           reduce using rule 48 (exp -> true .)
    TIMES           reduce using rule 48 (exp -> true .)
    DIVIDE          reduce using rule 48 (exp -> true .)
    POWER           reduce using rule 48 (exp -> true .)
    LT              reduce using rule 48 (exp -> true .)
    LE              reduce using rule 48 (exp -> true .)
    GT              reduce using rule 48 (exp -> true .)
    GE              reduce using rule 48 (exp -> true .)
    NE              reduce using rule 48 (exp -> true .)
    CHECKEQ         reduce using rule 48 (exp -> true .)
    and             reduce using rule 48 (exp -> true .)
    or              reduce using rule 48 (exp -> true .)
    MODULO          reduce using rule 48 (exp -> true .)
    DBLDOTS         reduce using rule 48 (exp -> true .)
    RPAREN          reduce using rule 48 (exp -> true .)
    do              reduce using rule 48 (exp -> true .)
    COMMA           reduce using rule 48 (exp -> true .)
    SEMI            reduce using rule 48 (exp -> true .)
    RCURLY          reduce using rule 48 (exp -> true .)
    RSQUARE         reduce using rule 48 (exp -> true .)
    return          reduce using rule 48 (exp -> true .)
    break           reduce using rule 48 (exp -> true .)
    while           reduce using rule 48 (exp -> true .)
    repeat          reduce using rule 48 (exp -> true .)
    if              reduce using rule 48 (exp -> true .)
    for             reduce using rule 48 (exp -> true .)
    local           reduce using rule 48 (exp -> true .)
    function        reduce using rule 48 (exp -> true .)
    ID              reduce using rule 48 (exp -> true .)
    RESID           reduce using rule 48 (exp -> true .)
    LPAREN          reduce using rule 48 (exp -> true .)
    $end            reduce using rule 48 (exp -> true .)
    end             reduce using rule 48 (exp -> true .)
    until           reduce using rule 48 (exp -> true .)
    else            reduce using rule 48 (exp -> true .)
    elseif          reduce using rule 48 (exp -> true .)


state 33

    (72) Number -> FLOAT .

    PLUS            reduce using rule 72 (Number -> FLOAT .)
    MINUS           reduce using rule 72 (Number -> FLOAT .)
    TIMES           reduce using rule 72 (Number -> FLOAT .)
    DIVIDE          reduce using rule 72 (Number -> FLOAT .)
    POWER           reduce using rule 72 (Number -> FLOAT .)
    LT              reduce using rule 72 (Number -> FLOAT .)
    LE              reduce using rule 72 (Number -> FLOAT .)
    GT              reduce using rule 72 (Number -> FLOAT .)
    GE              reduce using rule 72 (Number -> FLOAT .)
    NE              reduce using rule 72 (Number -> FLOAT .)
    CHECKEQ         reduce using rule 72 (Number -> FLOAT .)
    and             reduce using rule 72 (Number -> FLOAT .)
    or              reduce using rule 72 (Number -> FLOAT .)
    MODULO          reduce using rule 72 (Number -> FLOAT .)
    DBLDOTS         reduce using rule 72 (Number -> FLOAT .)
    COMMA           reduce using rule 72 (Number -> FLOAT .)
    SEMI            reduce using rule 72 (Number -> FLOAT .)
    return          reduce using rule 72 (Number -> FLOAT .)
    break           reduce using rule 72 (Number -> FLOAT .)
    do              reduce using rule 72 (Number -> FLOAT .)
    while           reduce using rule 72 (Number -> FLOAT .)
    repeat          reduce using rule 72 (Number -> FLOAT .)
    if              reduce using rule 72 (Number -> FLOAT .)
    for             reduce using rule 72 (Number -> FLOAT .)
    local           reduce using rule 72 (Number -> FLOAT .)
    function        reduce using rule 72 (Number -> FLOAT .)
    ID              reduce using rule 72 (Number -> FLOAT .)
    RESID           reduce using rule 72 (Number -> FLOAT .)
    LPAREN          reduce using rule 72 (Number -> FLOAT .)
    $end            reduce using rule 72 (Number -> FLOAT .)
    end             reduce using rule 72 (Number -> FLOAT .)
    until           reduce using rule 72 (Number -> FLOAT .)
    else            reduce using rule 72 (Number -> FLOAT .)
    elseif          reduce using rule 72 (Number -> FLOAT .)
    RPAREN          reduce using rule 72 (Number -> FLOAT .)
    then            reduce using rule 72 (Number -> FLOAT .)
    RCURLY          reduce using rule 72 (Number -> FLOAT .)
    RSQUARE         reduce using rule 72 (Number -> FLOAT .)


state 34

    (49) exp -> Number .

    then            reduce using rule 49 (exp -> Number .)
    PLUS            reduce using rule 49 (exp -> Number .)
    MINUS           reduce using rule 49 (exp -> Number .)
    TIMES           reduce using rule 49 (exp -> Number .)
    DIVIDE          reduce using rule 49 (exp -> Number .)
    POWER           reduce using rule 49 (exp -> Number .)
    LT              reduce using rule 49 (exp -> Number .)
    LE              reduce using rule 49 (exp -> Number .)
    GT              reduce using rule 49 (exp -> Number .)
    GE              reduce using rule 49 (exp -> Number .)
    NE              reduce using rule 49 (exp -> Number .)
    CHECKEQ         reduce using rule 49 (exp -> Number .)
    and             reduce using rule 49 (exp -> Number .)
    or              reduce using rule 49 (exp -> Number .)
    MODULO          reduce using rule 49 (exp -> Number .)
    DBLDOTS         reduce using rule 49 (exp -> Number .)
    RPAREN          reduce using rule 49 (exp -> Number .)
    do              reduce using rule 49 (exp -> Number .)
    COMMA           reduce using rule 49 (exp -> Number .)
    SEMI            reduce using rule 49 (exp -> Number .)
    RCURLY          reduce using rule 49 (exp -> Number .)
    RSQUARE         reduce using rule 49 (exp -> Number .)
    return          reduce using rule 49 (exp -> Number .)
    break           reduce using rule 49 (exp -> Number .)
    while           reduce using rule 49 (exp -> Number .)
    repeat          reduce using rule 49 (exp -> Number .)
    if              reduce using rule 49 (exp -> Number .)
    for             reduce using rule 49 (exp -> Number .)
    local           reduce using rule 49 (exp -> Number .)
    function        reduce using rule 49 (exp -> Number .)
    ID              reduce using rule 49 (exp -> Number .)
    RESID           reduce using rule 49 (exp -> Number .)
    LPAREN          reduce using rule 49 (exp -> Number .)
    $end            reduce using rule 49 (exp -> Number .)
    end             reduce using rule 49 (exp -> Number .)
    until           reduce using rule 49 (exp -> Number .)
    else            reduce using rule 49 (exp -> Number .)
    elseif          reduce using rule 49 (exp -> Number .)


state 35

    (76) prefixexp -> LPAREN exp . RPAREN
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    RPAREN          shift and go to state 68
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 36

    (51) exp -> TRPLDOTS .

    then            reduce using rule 51 (exp -> TRPLDOTS .)
    PLUS            reduce using rule 51 (exp -> TRPLDOTS .)
    MINUS           reduce using rule 51 (exp -> TRPLDOTS .)
    TIMES           reduce using rule 51 (exp -> TRPLDOTS .)
    DIVIDE          reduce using rule 51 (exp -> TRPLDOTS .)
    POWER           reduce using rule 51 (exp -> TRPLDOTS .)
    LT              reduce using rule 51 (exp -> TRPLDOTS .)
    LE              reduce using rule 51 (exp -> TRPLDOTS .)
    GT              reduce using rule 51 (exp -> TRPLDOTS .)
    GE              reduce using rule 51 (exp -> TRPLDOTS .)
    NE              reduce using rule 51 (exp -> TRPLDOTS .)
    CHECKEQ         reduce using rule 51 (exp -> TRPLDOTS .)
    and             reduce using rule 51 (exp -> TRPLDOTS .)
    or              reduce using rule 51 (exp -> TRPLDOTS .)
    MODULO          reduce using rule 51 (exp -> TRPLDOTS .)
    DBLDOTS         reduce using rule 51 (exp -> TRPLDOTS .)
    RPAREN          reduce using rule 51 (exp -> TRPLDOTS .)
    do              reduce using rule 51 (exp -> TRPLDOTS .)
    COMMA           reduce using rule 51 (exp -> TRPLDOTS .)
    SEMI            reduce using rule 51 (exp -> TRPLDOTS .)
    RCURLY          reduce using rule 51 (exp -> TRPLDOTS .)
    RSQUARE         reduce using rule 51 (exp -> TRPLDOTS .)
    return          reduce using rule 51 (exp -> TRPLDOTS .)
    break           reduce using rule 51 (exp -> TRPLDOTS .)
    while           reduce using rule 51 (exp -> TRPLDOTS .)
    repeat          reduce using rule 51 (exp -> TRPLDOTS .)
    if              reduce using rule 51 (exp -> TRPLDOTS .)
    for             reduce using rule 51 (exp -> TRPLDOTS .)
    local           reduce using rule 51 (exp -> TRPLDOTS .)
    function        reduce using rule 51 (exp -> TRPLDOTS .)
    ID              reduce using rule 51 (exp -> TRPLDOTS .)
    RESID           reduce using rule 51 (exp -> TRPLDOTS .)
    LPAREN          reduce using rule 51 (exp -> TRPLDOTS .)
    $end            reduce using rule 51 (exp -> TRPLDOTS .)
    end             reduce using rule 51 (exp -> TRPLDOTS .)
    until           reduce using rule 51 (exp -> TRPLDOTS .)
    else            reduce using rule 51 (exp -> TRPLDOTS .)
    elseif          reduce using rule 51 (exp -> TRPLDOTS .)


state 37

    (11) stat -> if exp . then block ifblock else block end
    (12) stat -> if exp . then block ifblock end
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            shift and go to state 82
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 38

    (41) var -> prefixexp LSQUARE . exp RSQUARE
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 83
    var                            shift and go to state 26
    names                          shift and go to state 5

state 39

    (42) var -> prefixexp SDOT . names
    (91) names -> . ID
    (92) names -> . RESID

    ID              shift and go to state 16
    RESID           shift and go to state 3

    names                          shift and go to state 84

state 40

    (15) stat -> for namelist . in explist do block end

    in              shift and go to state 85


state 41

    (13) stat -> for names . EQUALS exp COMMA exp do block end
    (14) stat -> for names . EQUALS exp COMMA exp COMMA exp do block end
    (43) namelist -> names . comid
    (35) comid -> . COMMA names comid
    (36) comid -> . empty
    (74) empty -> .

    EQUALS          shift and go to state 86
    COMMA           shift and go to state 88
    in              reduce using rule 74 (empty -> .)

    empty                          shift and go to state 87
    comid                          shift and go to state 89

state 42

    (7) stat -> varlist EQUALS . explist
    (44) explist -> . explist COMMA exp
    (45) explist -> . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 91
    var                            shift and go to state 26
    explist                        shift and go to state 90
    names                          shift and go to state 5

state 43

    (33) comvar -> COMMA . var comvar
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN

    ID              shift and go to state 16
    RESID           shift and go to state 3
    LPAREN          shift and go to state 4

    var                            shift and go to state 92
    prefixexp                      shift and go to state 7
    names                          shift and go to state 5

state 44

    (39) varlist -> var comvar .

    EQUALS          reduce using rule 39 (varlist -> var comvar .)


state 45

    (34) comvar -> empty .

    EQUALS          reduce using rule 34 (comvar -> empty .)


state 46

    (19) stat -> local function . names funcbody
    (91) names -> . ID
    (92) names -> . RESID

    ID              shift and go to state 16
    RESID           shift and go to state 3

    names                          shift and go to state 93

state 47

    (16) stat -> local namelist .
    (17) stat -> local namelist . EQUALS explist

    SEMI            reduce using rule 16 (stat -> local namelist .)
    return          reduce using rule 16 (stat -> local namelist .)
    break           reduce using rule 16 (stat -> local namelist .)
    do              reduce using rule 16 (stat -> local namelist .)
    while           reduce using rule 16 (stat -> local namelist .)
    repeat          reduce using rule 16 (stat -> local namelist .)
    if              reduce using rule 16 (stat -> local namelist .)
    for             reduce using rule 16 (stat -> local namelist .)
    local           reduce using rule 16 (stat -> local namelist .)
    function        reduce using rule 16 (stat -> local namelist .)
    ID              reduce using rule 16 (stat -> local namelist .)
    RESID           reduce using rule 16 (stat -> local namelist .)
    LPAREN          reduce using rule 16 (stat -> local namelist .)
    end             reduce using rule 16 (stat -> local namelist .)
    until           reduce using rule 16 (stat -> local namelist .)
    else            reduce using rule 16 (stat -> local namelist .)
    elseif          reduce using rule 16 (stat -> local namelist .)
    $end            reduce using rule 16 (stat -> local namelist .)
    EQUALS          shift and go to state 94


state 48

    (43) namelist -> names . comid
    (35) comid -> . COMMA names comid
    (36) comid -> . empty
    (74) empty -> .

    COMMA           shift and go to state 88
    EQUALS          reduce using rule 74 (empty -> .)
    SEMI            reduce using rule 74 (empty -> .)
    return          reduce using rule 74 (empty -> .)
    break           reduce using rule 74 (empty -> .)
    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    $end            reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)
    until           reduce using rule 74 (empty -> .)
    else            reduce using rule 74 (empty -> .)
    elseif          reduce using rule 74 (empty -> .)
    RPAREN          reduce using rule 74 (empty -> .)

  ! COMMA           [ reduce using rule 74 (empty -> .) ]

    empty                          shift and go to state 87
    comid                          shift and go to state 89

state 49

    (18) stat -> function funcname . funcbody
    (20) funcbody -> . LPAREN RPAREN block end
    (21) funcbody -> . LPAREN parlist RPAREN block end

    LPAREN          shift and go to state 96

    funcbody                       shift and go to state 95

state 50

    (29) funcname -> names . dotid COLON
    (30) funcname -> names . dotid
    (31) dotid -> . SDOT names dotid
    (32) dotid -> . empty
    (74) empty -> .

    SDOT            shift and go to state 97
    COLON           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)

    dotid                          shift and go to state 98
    empty                          shift and go to state 99

state 51

    (6) block -> chunk .
    (1) chunk -> chunk . stat
    (2) chunk -> chunk . stat SEMI
    (3) chunk -> chunk . stat laststat
    (4) chunk -> chunk . stat SEMI laststat SEMI
    (7) stat -> . varlist EQUALS explist
    (8) stat -> . do block end
    (9) stat -> . while exp do block end
    (10) stat -> . repeat block until exp
    (11) stat -> . if exp then block ifblock else block end
    (12) stat -> . if exp then block ifblock end
    (13) stat -> . for names EQUALS exp COMMA exp do block end
    (14) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (15) stat -> . for namelist in explist do block end
    (16) stat -> . local namelist
    (17) stat -> . local namelist EQUALS explist
    (18) stat -> . function funcname funcbody
    (19) stat -> . local function names funcbody
    (39) varlist -> . var comvar
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN

    end             reduce using rule 6 (block -> chunk .)
    until           reduce using rule 6 (block -> chunk .)
    else            reduce using rule 6 (block -> chunk .)
    elseif          reduce using rule 6 (block -> chunk .)
    do              shift and go to state 13
    while           shift and go to state 17
    repeat          shift and go to state 15
    if              shift and go to state 6
    for             shift and go to state 8
    local           shift and go to state 11
    function        shift and go to state 12
    ID              shift and go to state 16
    RESID           shift and go to state 3
    LPAREN          shift and go to state 4

    prefixexp                      shift and go to state 7
    stat                           shift and go to state 14
    varlist                        shift and go to state 9
    names                          shift and go to state 5
    var                            shift and go to state 10

state 52

    (8) stat -> do block . end

    end             shift and go to state 100


state 53

    (26) laststat -> return . explist
    (27) laststat -> return .
    (44) explist -> . explist COMMA exp
    (45) explist -> . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

  ! shift/reduce conflict for function resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RESID resolved as shift
    do              reduce using rule 27 (laststat -> return .)
    while           reduce using rule 27 (laststat -> return .)
    repeat          reduce using rule 27 (laststat -> return .)
    if              reduce using rule 27 (laststat -> return .)
    for             reduce using rule 27 (laststat -> return .)
    local           reduce using rule 27 (laststat -> return .)
    $end            reduce using rule 27 (laststat -> return .)
    end             reduce using rule 27 (laststat -> return .)
    until           reduce using rule 27 (laststat -> return .)
    else            reduce using rule 27 (laststat -> return .)
    elseif          reduce using rule 27 (laststat -> return .)
    SEMI            reduce using rule 27 (laststat -> return .)
    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

  ! function        [ reduce using rule 27 (laststat -> return .) ]
  ! ID              [ reduce using rule 27 (laststat -> return .) ]
  ! RESID           [ reduce using rule 27 (laststat -> return .) ]
  ! LPAREN          [ reduce using rule 27 (laststat -> return .) ]

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 91
    var                            shift and go to state 26
    explist                        shift and go to state 101
    names                          shift and go to state 5

state 54

    (2) chunk -> chunk stat SEMI .
    (4) chunk -> chunk stat SEMI . laststat SEMI
    (26) laststat -> . return explist
    (27) laststat -> . return
    (28) laststat -> . break

    do              reduce using rule 2 (chunk -> chunk stat SEMI .)
    while           reduce using rule 2 (chunk -> chunk stat SEMI .)
    repeat          reduce using rule 2 (chunk -> chunk stat SEMI .)
    if              reduce using rule 2 (chunk -> chunk stat SEMI .)
    for             reduce using rule 2 (chunk -> chunk stat SEMI .)
    local           reduce using rule 2 (chunk -> chunk stat SEMI .)
    function        reduce using rule 2 (chunk -> chunk stat SEMI .)
    ID              reduce using rule 2 (chunk -> chunk stat SEMI .)
    RESID           reduce using rule 2 (chunk -> chunk stat SEMI .)
    LPAREN          reduce using rule 2 (chunk -> chunk stat SEMI .)
    end             reduce using rule 2 (chunk -> chunk stat SEMI .)
    else            reduce using rule 2 (chunk -> chunk stat SEMI .)
    elseif          reduce using rule 2 (chunk -> chunk stat SEMI .)
    $end            reduce using rule 2 (chunk -> chunk stat SEMI .)
    until           reduce using rule 2 (chunk -> chunk stat SEMI .)
    return          shift and go to state 53
    break           shift and go to state 56

    laststat                       shift and go to state 102

state 55

    (3) chunk -> chunk stat laststat .

    do              reduce using rule 3 (chunk -> chunk stat laststat .)
    while           reduce using rule 3 (chunk -> chunk stat laststat .)
    repeat          reduce using rule 3 (chunk -> chunk stat laststat .)
    if              reduce using rule 3 (chunk -> chunk stat laststat .)
    for             reduce using rule 3 (chunk -> chunk stat laststat .)
    local           reduce using rule 3 (chunk -> chunk stat laststat .)
    function        reduce using rule 3 (chunk -> chunk stat laststat .)
    ID              reduce using rule 3 (chunk -> chunk stat laststat .)
    RESID           reduce using rule 3 (chunk -> chunk stat laststat .)
    LPAREN          reduce using rule 3 (chunk -> chunk stat laststat .)
    end             reduce using rule 3 (chunk -> chunk stat laststat .)
    else            reduce using rule 3 (chunk -> chunk stat laststat .)
    elseif          reduce using rule 3 (chunk -> chunk stat laststat .)
    $end            reduce using rule 3 (chunk -> chunk stat laststat .)
    until           reduce using rule 3 (chunk -> chunk stat laststat .)


state 56

    (28) laststat -> break .

    do              reduce using rule 28 (laststat -> break .)
    while           reduce using rule 28 (laststat -> break .)
    repeat          reduce using rule 28 (laststat -> break .)
    if              reduce using rule 28 (laststat -> break .)
    for             reduce using rule 28 (laststat -> break .)
    local           reduce using rule 28 (laststat -> break .)
    function        reduce using rule 28 (laststat -> break .)
    ID              reduce using rule 28 (laststat -> break .)
    RESID           reduce using rule 28 (laststat -> break .)
    LPAREN          reduce using rule 28 (laststat -> break .)
    $end            reduce using rule 28 (laststat -> break .)
    end             reduce using rule 28 (laststat -> break .)
    until           reduce using rule 28 (laststat -> break .)
    else            reduce using rule 28 (laststat -> break .)
    elseif          reduce using rule 28 (laststat -> break .)
    SEMI            reduce using rule 28 (laststat -> break .)


state 57

    (10) stat -> repeat block . until exp

    until           shift and go to state 103


state 58

    (9) stat -> while exp . do block end
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    do              shift and go to state 104
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 59

    (69) exp -> unop exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 69 (exp -> unop exp .)
    PLUS            reduce using rule 69 (exp -> unop exp .)
    MINUS           reduce using rule 69 (exp -> unop exp .)
    TIMES           reduce using rule 69 (exp -> unop exp .)
    DIVIDE          reduce using rule 69 (exp -> unop exp .)
    LT              reduce using rule 69 (exp -> unop exp .)
    LE              reduce using rule 69 (exp -> unop exp .)
    GT              reduce using rule 69 (exp -> unop exp .)
    GE              reduce using rule 69 (exp -> unop exp .)
    NE              reduce using rule 69 (exp -> unop exp .)
    CHECKEQ         reduce using rule 69 (exp -> unop exp .)
    and             reduce using rule 69 (exp -> unop exp .)
    or              reduce using rule 69 (exp -> unop exp .)
    MODULO          reduce using rule 69 (exp -> unop exp .)
    DBLDOTS         reduce using rule 69 (exp -> unop exp .)
    RPAREN          reduce using rule 69 (exp -> unop exp .)
    do              reduce using rule 69 (exp -> unop exp .)
    COMMA           reduce using rule 69 (exp -> unop exp .)
    SEMI            reduce using rule 69 (exp -> unop exp .)
    RCURLY          reduce using rule 69 (exp -> unop exp .)
    RSQUARE         reduce using rule 69 (exp -> unop exp .)
    return          reduce using rule 69 (exp -> unop exp .)
    break           reduce using rule 69 (exp -> unop exp .)
    while           reduce using rule 69 (exp -> unop exp .)
    repeat          reduce using rule 69 (exp -> unop exp .)
    if              reduce using rule 69 (exp -> unop exp .)
    for             reduce using rule 69 (exp -> unop exp .)
    local           reduce using rule 69 (exp -> unop exp .)
    function        reduce using rule 69 (exp -> unop exp .)
    ID              reduce using rule 69 (exp -> unop exp .)
    RESID           reduce using rule 69 (exp -> unop exp .)
    LPAREN          reduce using rule 69 (exp -> unop exp .)
    $end            reduce using rule 69 (exp -> unop exp .)
    end             reduce using rule 69 (exp -> unop exp .)
    until           reduce using rule 69 (exp -> unop exp .)
    else            reduce using rule 69 (exp -> unop exp .)
    elseif          reduce using rule 69 (exp -> unop exp .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 69 (exp -> unop exp .) ]
  ! PLUS            [ shift and go to state 76 ]
  ! MINUS           [ shift and go to state 79 ]
  ! TIMES           [ shift and go to state 72 ]
  ! DIVIDE          [ shift and go to state 81 ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]
  ! MODULO          [ shift and go to state 77 ]
  ! DBLDOTS         [ shift and go to state 78 ]


state 60

    (87) field -> names . EQUALS exp
    (40) var -> names .

    EQUALS          shift and go to state 105
    LSQUARE         reduce using rule 40 (var -> names .)
    SDOT            reduce using rule 40 (var -> names .)
    PLUS            reduce using rule 40 (var -> names .)
    MINUS           reduce using rule 40 (var -> names .)
    TIMES           reduce using rule 40 (var -> names .)
    DIVIDE          reduce using rule 40 (var -> names .)
    POWER           reduce using rule 40 (var -> names .)
    LT              reduce using rule 40 (var -> names .)
    LE              reduce using rule 40 (var -> names .)
    GT              reduce using rule 40 (var -> names .)
    GE              reduce using rule 40 (var -> names .)
    NE              reduce using rule 40 (var -> names .)
    CHECKEQ         reduce using rule 40 (var -> names .)
    and             reduce using rule 40 (var -> names .)
    or              reduce using rule 40 (var -> names .)
    MODULO          reduce using rule 40 (var -> names .)
    DBLDOTS         reduce using rule 40 (var -> names .)
    COMMA           reduce using rule 40 (var -> names .)
    SEMI            reduce using rule 40 (var -> names .)
    RCURLY          reduce using rule 40 (var -> names .)


state 61

    (81) tableconstructor -> LCURLY RCURLY .

    COMMA           reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    PLUS            reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    MINUS           reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    TIMES           reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    DIVIDE          reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    POWER           reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    LT              reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    LE              reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    GT              reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    GE              reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    NE              reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    CHECKEQ         reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    and             reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    or              reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    MODULO          reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    DBLDOTS         reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    RPAREN          reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    then            reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    do              reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    SEMI            reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    RCURLY          reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    RSQUARE         reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    return          reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    break           reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    while           reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    repeat          reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    if              reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    for             reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    local           reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    function        reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    ID              reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    RESID           reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    LPAREN          reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    $end            reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    end             reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    until           reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    else            reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)
    elseif          reduce using rule 81 (tableconstructor -> LCURLY RCURLY .)


state 62

    (82) fieldlist -> field . fieldseplist fieldsep
    (83) fieldlist -> field . fieldseplist
    (84) fieldseplist -> . fieldseplist fieldsep field
    (85) fieldseplist -> . empty
    (74) empty -> .

    COMMA           reduce using rule 74 (empty -> .)
    SEMI            reduce using rule 74 (empty -> .)
    RCURLY          reduce using rule 74 (empty -> .)

    fieldseplist                   shift and go to state 106
    empty                          shift and go to state 107

state 63

    (80) tableconstructor -> LCURLY fieldlist . RCURLY

    RCURLY          shift and go to state 108


state 64

    (88) field -> exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 88 (field -> exp .)
    SEMI            reduce using rule 88 (field -> exp .)
    RCURLY          reduce using rule 88 (field -> exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 65

    (86) field -> LSQUARE . exp RSQUARE EQUALS exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 109
    var                            shift and go to state 26
    names                          shift and go to state 5

state 66

    (65) exp -> exp and . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 110
    var                            shift and go to state 26
    names                          shift and go to state 5

state 67

    (60) exp -> exp LE . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 111
    var                            shift and go to state 26
    names                          shift and go to state 5

state 68

    (76) prefixexp -> LPAREN exp RPAREN .

    LSQUARE         reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    SDOT            reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    RSQUARE         reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    POWER           reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    LE              reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    GE              reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    CHECKEQ         reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    and             reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    or              reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    MODULO          reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    DBLDOTS         reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    then            reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    do              reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    SEMI            reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    RCURLY          reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    return          reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    break           reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    while           reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    repeat          reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    if              reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    for             reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    local           reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    function        reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    RESID           reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    $end            reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    end             reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    until           reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    else            reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)
    elseif          reduce using rule 76 (prefixexp -> LPAREN exp RPAREN .)


state 69

    (58) exp -> exp POWER . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 112
    var                            shift and go to state 26
    names                          shift and go to state 5

state 70

    (66) exp -> exp or . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 113
    var                            shift and go to state 26
    names                          shift and go to state 5

state 71

    (62) exp -> exp GE . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 114
    var                            shift and go to state 26
    names                          shift and go to state 5

state 72

    (56) exp -> exp TIMES . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 115
    var                            shift and go to state 26
    names                          shift and go to state 5

state 73

    (64) exp -> exp CHECKEQ . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 116
    var                            shift and go to state 26
    names                          shift and go to state 5

state 74

    (59) exp -> exp LT . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 117
    var                            shift and go to state 26
    names                          shift and go to state 5

state 75

    (61) exp -> exp GT . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 118
    var                            shift and go to state 26
    names                          shift and go to state 5

state 76

    (54) exp -> exp PLUS . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 119
    var                            shift and go to state 26
    names                          shift and go to state 5

state 77

    (67) exp -> exp MODULO . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 120
    var                            shift and go to state 26
    names                          shift and go to state 5

state 78

    (68) exp -> exp DBLDOTS . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 121
    var                            shift and go to state 26
    names                          shift and go to state 5

state 79

    (55) exp -> exp MINUS . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 122
    var                            shift and go to state 26
    names                          shift and go to state 5

state 80

    (63) exp -> exp NE . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 123
    var                            shift and go to state 26
    names                          shift and go to state 5

state 81

    (57) exp -> exp DIVIDE . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 124
    var                            shift and go to state 26
    names                          shift and go to state 5

state 82

    (11) stat -> if exp then . block ifblock else block end
    (12) stat -> if exp then . block ifblock end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    else            reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)
    elseif          reduce using rule 74 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 125

state 83

    (41) var -> prefixexp LSQUARE exp . RSQUARE
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    RSQUARE         shift and go to state 126
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 84

    (42) var -> prefixexp SDOT names .

    LSQUARE         reduce using rule 42 (var -> prefixexp SDOT names .)
    SDOT            reduce using rule 42 (var -> prefixexp SDOT names .)
    PLUS            reduce using rule 42 (var -> prefixexp SDOT names .)
    MINUS           reduce using rule 42 (var -> prefixexp SDOT names .)
    TIMES           reduce using rule 42 (var -> prefixexp SDOT names .)
    DIVIDE          reduce using rule 42 (var -> prefixexp SDOT names .)
    POWER           reduce using rule 42 (var -> prefixexp SDOT names .)
    LT              reduce using rule 42 (var -> prefixexp SDOT names .)
    LE              reduce using rule 42 (var -> prefixexp SDOT names .)
    GT              reduce using rule 42 (var -> prefixexp SDOT names .)
    GE              reduce using rule 42 (var -> prefixexp SDOT names .)
    NE              reduce using rule 42 (var -> prefixexp SDOT names .)
    CHECKEQ         reduce using rule 42 (var -> prefixexp SDOT names .)
    and             reduce using rule 42 (var -> prefixexp SDOT names .)
    or              reduce using rule 42 (var -> prefixexp SDOT names .)
    MODULO          reduce using rule 42 (var -> prefixexp SDOT names .)
    DBLDOTS         reduce using rule 42 (var -> prefixexp SDOT names .)
    SEMI            reduce using rule 42 (var -> prefixexp SDOT names .)
    return          reduce using rule 42 (var -> prefixexp SDOT names .)
    break           reduce using rule 42 (var -> prefixexp SDOT names .)
    do              reduce using rule 42 (var -> prefixexp SDOT names .)
    while           reduce using rule 42 (var -> prefixexp SDOT names .)
    repeat          reduce using rule 42 (var -> prefixexp SDOT names .)
    if              reduce using rule 42 (var -> prefixexp SDOT names .)
    for             reduce using rule 42 (var -> prefixexp SDOT names .)
    local           reduce using rule 42 (var -> prefixexp SDOT names .)
    function        reduce using rule 42 (var -> prefixexp SDOT names .)
    ID              reduce using rule 42 (var -> prefixexp SDOT names .)
    RESID           reduce using rule 42 (var -> prefixexp SDOT names .)
    LPAREN          reduce using rule 42 (var -> prefixexp SDOT names .)
    $end            reduce using rule 42 (var -> prefixexp SDOT names .)
    end             reduce using rule 42 (var -> prefixexp SDOT names .)
    until           reduce using rule 42 (var -> prefixexp SDOT names .)
    else            reduce using rule 42 (var -> prefixexp SDOT names .)
    elseif          reduce using rule 42 (var -> prefixexp SDOT names .)
    COMMA           reduce using rule 42 (var -> prefixexp SDOT names .)
    EQUALS          reduce using rule 42 (var -> prefixexp SDOT names .)
    RPAREN          reduce using rule 42 (var -> prefixexp SDOT names .)
    then            reduce using rule 42 (var -> prefixexp SDOT names .)
    RCURLY          reduce using rule 42 (var -> prefixexp SDOT names .)
    RSQUARE         reduce using rule 42 (var -> prefixexp SDOT names .)


state 85

    (15) stat -> for namelist in . explist do block end
    (44) explist -> . explist COMMA exp
    (45) explist -> . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 18
    exp                            shift and go to state 91
    var                            shift and go to state 26
    explist                        shift and go to state 127
    names                          shift and go to state 5

state 86

    (13) stat -> for names EQUALS . exp COMMA exp do block end
    (14) stat -> for names EQUALS . exp COMMA exp COMMA exp do block end
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    names                          shift and go to state 5
    exp                            shift and go to state 128
    var                            shift and go to state 26

state 87

    (36) comid -> empty .

    in              reduce using rule 36 (comid -> empty .)
    EQUALS          reduce using rule 36 (comid -> empty .)
    SEMI            reduce using rule 36 (comid -> empty .)
    return          reduce using rule 36 (comid -> empty .)
    break           reduce using rule 36 (comid -> empty .)
    do              reduce using rule 36 (comid -> empty .)
    while           reduce using rule 36 (comid -> empty .)
    repeat          reduce using rule 36 (comid -> empty .)
    if              reduce using rule 36 (comid -> empty .)
    for             reduce using rule 36 (comid -> empty .)
    local           reduce using rule 36 (comid -> empty .)
    function        reduce using rule 36 (comid -> empty .)
    ID              reduce using rule 36 (comid -> empty .)
    RESID           reduce using rule 36 (comid -> empty .)
    LPAREN          reduce using rule 36 (comid -> empty .)
    $end            reduce using rule 36 (comid -> empty .)
    end             reduce using rule 36 (comid -> empty .)
    until           reduce using rule 36 (comid -> empty .)
    else            reduce using rule 36 (comid -> empty .)
    elseif          reduce using rule 36 (comid -> empty .)
    COMMA           reduce using rule 36 (comid -> empty .)
    RPAREN          reduce using rule 36 (comid -> empty .)


state 88

    (35) comid -> COMMA . names comid
    (91) names -> . ID
    (92) names -> . RESID

    ID              shift and go to state 16
    RESID           shift and go to state 3

    names                          shift and go to state 129

state 89

    (43) namelist -> names comid .

    in              reduce using rule 43 (namelist -> names comid .)
    EQUALS          reduce using rule 43 (namelist -> names comid .)
    SEMI            reduce using rule 43 (namelist -> names comid .)
    return          reduce using rule 43 (namelist -> names comid .)
    break           reduce using rule 43 (namelist -> names comid .)
    do              reduce using rule 43 (namelist -> names comid .)
    while           reduce using rule 43 (namelist -> names comid .)
    repeat          reduce using rule 43 (namelist -> names comid .)
    if              reduce using rule 43 (namelist -> names comid .)
    for             reduce using rule 43 (namelist -> names comid .)
    local           reduce using rule 43 (namelist -> names comid .)
    function        reduce using rule 43 (namelist -> names comid .)
    ID              reduce using rule 43 (namelist -> names comid .)
    RESID           reduce using rule 43 (namelist -> names comid .)
    LPAREN          reduce using rule 43 (namelist -> names comid .)
    $end            reduce using rule 43 (namelist -> names comid .)
    end             reduce using rule 43 (namelist -> names comid .)
    until           reduce using rule 43 (namelist -> names comid .)
    else            reduce using rule 43 (namelist -> names comid .)
    elseif          reduce using rule 43 (namelist -> names comid .)
    COMMA           reduce using rule 43 (namelist -> names comid .)
    RPAREN          reduce using rule 43 (namelist -> names comid .)


state 90

    (7) stat -> varlist EQUALS explist .
    (44) explist -> explist . COMMA exp

    SEMI            reduce using rule 7 (stat -> varlist EQUALS explist .)
    return          reduce using rule 7 (stat -> varlist EQUALS explist .)
    break           reduce using rule 7 (stat -> varlist EQUALS explist .)
    do              reduce using rule 7 (stat -> varlist EQUALS explist .)
    while           reduce using rule 7 (stat -> varlist EQUALS explist .)
    repeat          reduce using rule 7 (stat -> varlist EQUALS explist .)
    if              reduce using rule 7 (stat -> varlist EQUALS explist .)
    for             reduce using rule 7 (stat -> varlist EQUALS explist .)
    local           reduce using rule 7 (stat -> varlist EQUALS explist .)
    function        reduce using rule 7 (stat -> varlist EQUALS explist .)
    ID              reduce using rule 7 (stat -> varlist EQUALS explist .)
    RESID           reduce using rule 7 (stat -> varlist EQUALS explist .)
    LPAREN          reduce using rule 7 (stat -> varlist EQUALS explist .)
    end             reduce using rule 7 (stat -> varlist EQUALS explist .)
    until           reduce using rule 7 (stat -> varlist EQUALS explist .)
    else            reduce using rule 7 (stat -> varlist EQUALS explist .)
    elseif          reduce using rule 7 (stat -> varlist EQUALS explist .)
    $end            reduce using rule 7 (stat -> varlist EQUALS explist .)
    COMMA           shift and go to state 130


state 91

    (45) explist -> exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    do              reduce using rule 45 (explist -> exp .)
    COMMA           reduce using rule 45 (explist -> exp .)
    while           reduce using rule 45 (explist -> exp .)
    repeat          reduce using rule 45 (explist -> exp .)
    if              reduce using rule 45 (explist -> exp .)
    for             reduce using rule 45 (explist -> exp .)
    local           reduce using rule 45 (explist -> exp .)
    function        reduce using rule 45 (explist -> exp .)
    ID              reduce using rule 45 (explist -> exp .)
    RESID           reduce using rule 45 (explist -> exp .)
    LPAREN          reduce using rule 45 (explist -> exp .)
    $end            reduce using rule 45 (explist -> exp .)
    end             reduce using rule 45 (explist -> exp .)
    until           reduce using rule 45 (explist -> exp .)
    else            reduce using rule 45 (explist -> exp .)
    elseif          reduce using rule 45 (explist -> exp .)
    SEMI            reduce using rule 45 (explist -> exp .)
    return          reduce using rule 45 (explist -> exp .)
    break           reduce using rule 45 (explist -> exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 92

    (33) comvar -> COMMA var . comvar
    (75) prefixexp -> var .
    (33) comvar -> . COMMA var comvar
    (34) comvar -> . empty
    (74) empty -> .

    LSQUARE         reduce using rule 75 (prefixexp -> var .)
    SDOT            reduce using rule 75 (prefixexp -> var .)
    COMMA           shift and go to state 43
    EQUALS          reduce using rule 74 (empty -> .)

    comvar                         shift and go to state 131
    empty                          shift and go to state 45

state 93

    (19) stat -> local function names . funcbody
    (20) funcbody -> . LPAREN RPAREN block end
    (21) funcbody -> . LPAREN parlist RPAREN block end

    LPAREN          shift and go to state 96

    funcbody                       shift and go to state 132

state 94

    (17) stat -> local namelist EQUALS . explist
    (44) explist -> . explist COMMA exp
    (45) explist -> . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 18
    exp                            shift and go to state 91
    var                            shift and go to state 26
    explist                        shift and go to state 133
    names                          shift and go to state 5

state 95

    (18) stat -> function funcname funcbody .

    SEMI            reduce using rule 18 (stat -> function funcname funcbody .)
    return          reduce using rule 18 (stat -> function funcname funcbody .)
    break           reduce using rule 18 (stat -> function funcname funcbody .)
    do              reduce using rule 18 (stat -> function funcname funcbody .)
    while           reduce using rule 18 (stat -> function funcname funcbody .)
    repeat          reduce using rule 18 (stat -> function funcname funcbody .)
    if              reduce using rule 18 (stat -> function funcname funcbody .)
    for             reduce using rule 18 (stat -> function funcname funcbody .)
    local           reduce using rule 18 (stat -> function funcname funcbody .)
    function        reduce using rule 18 (stat -> function funcname funcbody .)
    ID              reduce using rule 18 (stat -> function funcname funcbody .)
    RESID           reduce using rule 18 (stat -> function funcname funcbody .)
    LPAREN          reduce using rule 18 (stat -> function funcname funcbody .)
    end             reduce using rule 18 (stat -> function funcname funcbody .)
    until           reduce using rule 18 (stat -> function funcname funcbody .)
    else            reduce using rule 18 (stat -> function funcname funcbody .)
    elseif          reduce using rule 18 (stat -> function funcname funcbody .)
    $end            reduce using rule 18 (stat -> function funcname funcbody .)


state 96

    (20) funcbody -> LPAREN . RPAREN block end
    (21) funcbody -> LPAREN . parlist RPAREN block end
    (22) parlist -> . namelist
    (23) parlist -> . namelist comtrp
    (24) parlist -> . TRPLDOTS
    (43) namelist -> . names comid
    (91) names -> . ID
    (92) names -> . RESID

    RPAREN          shift and go to state 137
    TRPLDOTS        shift and go to state 135
    ID              shift and go to state 16
    RESID           shift and go to state 3

    namelist                       shift and go to state 134
    parlist                        shift and go to state 136
    names                          shift and go to state 48

state 97

    (31) dotid -> SDOT . names dotid
    (91) names -> . ID
    (92) names -> . RESID

    ID              shift and go to state 16
    RESID           shift and go to state 3

    names                          shift and go to state 138

state 98

    (29) funcname -> names dotid . COLON
    (30) funcname -> names dotid .

    COLON           shift and go to state 139
    LPAREN          reduce using rule 30 (funcname -> names dotid .)


state 99

    (32) dotid -> empty .

    COLON           reduce using rule 32 (dotid -> empty .)
    LPAREN          reduce using rule 32 (dotid -> empty .)


state 100

    (8) stat -> do block end .

    SEMI            reduce using rule 8 (stat -> do block end .)
    return          reduce using rule 8 (stat -> do block end .)
    break           reduce using rule 8 (stat -> do block end .)
    do              reduce using rule 8 (stat -> do block end .)
    while           reduce using rule 8 (stat -> do block end .)
    repeat          reduce using rule 8 (stat -> do block end .)
    if              reduce using rule 8 (stat -> do block end .)
    for             reduce using rule 8 (stat -> do block end .)
    local           reduce using rule 8 (stat -> do block end .)
    function        reduce using rule 8 (stat -> do block end .)
    ID              reduce using rule 8 (stat -> do block end .)
    RESID           reduce using rule 8 (stat -> do block end .)
    LPAREN          reduce using rule 8 (stat -> do block end .)
    end             reduce using rule 8 (stat -> do block end .)
    until           reduce using rule 8 (stat -> do block end .)
    else            reduce using rule 8 (stat -> do block end .)
    elseif          reduce using rule 8 (stat -> do block end .)
    $end            reduce using rule 8 (stat -> do block end .)


state 101

    (26) laststat -> return explist .
    (44) explist -> explist . COMMA exp

    do              reduce using rule 26 (laststat -> return explist .)
    while           reduce using rule 26 (laststat -> return explist .)
    repeat          reduce using rule 26 (laststat -> return explist .)
    if              reduce using rule 26 (laststat -> return explist .)
    for             reduce using rule 26 (laststat -> return explist .)
    local           reduce using rule 26 (laststat -> return explist .)
    function        reduce using rule 26 (laststat -> return explist .)
    ID              reduce using rule 26 (laststat -> return explist .)
    RESID           reduce using rule 26 (laststat -> return explist .)
    LPAREN          reduce using rule 26 (laststat -> return explist .)
    $end            reduce using rule 26 (laststat -> return explist .)
    end             reduce using rule 26 (laststat -> return explist .)
    until           reduce using rule 26 (laststat -> return explist .)
    else            reduce using rule 26 (laststat -> return explist .)
    elseif          reduce using rule 26 (laststat -> return explist .)
    SEMI            reduce using rule 26 (laststat -> return explist .)
    COMMA           shift and go to state 130


state 102

    (4) chunk -> chunk stat SEMI laststat . SEMI

    SEMI            shift and go to state 140


state 103

    (10) stat -> repeat block until . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 141
    var                            shift and go to state 26
    names                          shift and go to state 5

state 104

    (9) stat -> while exp do . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 142

state 105

    (87) field -> names EQUALS . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    names                          shift and go to state 5
    exp                            shift and go to state 143
    var                            shift and go to state 26

state 106

    (82) fieldlist -> field fieldseplist . fieldsep
    (83) fieldlist -> field fieldseplist .
    (84) fieldseplist -> fieldseplist . fieldsep field
    (89) fieldsep -> . COMMA
    (90) fieldsep -> . SEMI

    RCURLY          reduce using rule 83 (fieldlist -> field fieldseplist .)
    COMMA           shift and go to state 145
    SEMI            shift and go to state 146

    fieldsep                       shift and go to state 144

state 107

    (85) fieldseplist -> empty .

    COMMA           reduce using rule 85 (fieldseplist -> empty .)
    SEMI            reduce using rule 85 (fieldseplist -> empty .)
    RCURLY          reduce using rule 85 (fieldseplist -> empty .)


state 108

    (80) tableconstructor -> LCURLY fieldlist RCURLY .

    COMMA           reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    PLUS            reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    MINUS           reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    TIMES           reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    DIVIDE          reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    POWER           reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LT              reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LE              reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    GT              reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    GE              reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    NE              reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    CHECKEQ         reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    and             reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    or              reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    MODULO          reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    DBLDOTS         reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RPAREN          reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    then            reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    do              reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    SEMI            reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RCURLY          reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RSQUARE         reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    return          reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    break           reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    while           reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    repeat          reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    if              reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    for             reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    local           reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    function        reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    ID              reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RESID           reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LPAREN          reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    $end            reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    end             reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    until           reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    else            reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)
    elseif          reduce using rule 80 (tableconstructor -> LCURLY fieldlist RCURLY .)


state 109

    (86) field -> LSQUARE exp . RSQUARE EQUALS exp
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    RSQUARE         shift and go to state 147
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 110

    (65) exp -> exp and exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 65 (exp -> exp and exp .)
    LT              reduce using rule 65 (exp -> exp and exp .)
    LE              reduce using rule 65 (exp -> exp and exp .)
    GT              reduce using rule 65 (exp -> exp and exp .)
    GE              reduce using rule 65 (exp -> exp and exp .)
    NE              reduce using rule 65 (exp -> exp and exp .)
    CHECKEQ         reduce using rule 65 (exp -> exp and exp .)
    and             reduce using rule 65 (exp -> exp and exp .)
    or              reduce using rule 65 (exp -> exp and exp .)
    RPAREN          reduce using rule 65 (exp -> exp and exp .)
    do              reduce using rule 65 (exp -> exp and exp .)
    COMMA           reduce using rule 65 (exp -> exp and exp .)
    SEMI            reduce using rule 65 (exp -> exp and exp .)
    RCURLY          reduce using rule 65 (exp -> exp and exp .)
    RSQUARE         reduce using rule 65 (exp -> exp and exp .)
    return          reduce using rule 65 (exp -> exp and exp .)
    break           reduce using rule 65 (exp -> exp and exp .)
    while           reduce using rule 65 (exp -> exp and exp .)
    repeat          reduce using rule 65 (exp -> exp and exp .)
    if              reduce using rule 65 (exp -> exp and exp .)
    for             reduce using rule 65 (exp -> exp and exp .)
    local           reduce using rule 65 (exp -> exp and exp .)
    function        reduce using rule 65 (exp -> exp and exp .)
    ID              reduce using rule 65 (exp -> exp and exp .)
    RESID           reduce using rule 65 (exp -> exp and exp .)
    LPAREN          reduce using rule 65 (exp -> exp and exp .)
    $end            reduce using rule 65 (exp -> exp and exp .)
    end             reduce using rule 65 (exp -> exp and exp .)
    until           reduce using rule 65 (exp -> exp and exp .)
    else            reduce using rule 65 (exp -> exp and exp .)
    elseif          reduce using rule 65 (exp -> exp and exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78

  ! PLUS            [ reduce using rule 65 (exp -> exp and exp .) ]
  ! MINUS           [ reduce using rule 65 (exp -> exp and exp .) ]
  ! TIMES           [ reduce using rule 65 (exp -> exp and exp .) ]
  ! DIVIDE          [ reduce using rule 65 (exp -> exp and exp .) ]
  ! POWER           [ reduce using rule 65 (exp -> exp and exp .) ]
  ! MODULO          [ reduce using rule 65 (exp -> exp and exp .) ]
  ! DBLDOTS         [ reduce using rule 65 (exp -> exp and exp .) ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]


state 111

    (60) exp -> exp LE exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 60 (exp -> exp LE exp .)
    LT              reduce using rule 60 (exp -> exp LE exp .)
    LE              reduce using rule 60 (exp -> exp LE exp .)
    GT              reduce using rule 60 (exp -> exp LE exp .)
    GE              reduce using rule 60 (exp -> exp LE exp .)
    NE              reduce using rule 60 (exp -> exp LE exp .)
    CHECKEQ         reduce using rule 60 (exp -> exp LE exp .)
    and             reduce using rule 60 (exp -> exp LE exp .)
    or              reduce using rule 60 (exp -> exp LE exp .)
    RPAREN          reduce using rule 60 (exp -> exp LE exp .)
    do              reduce using rule 60 (exp -> exp LE exp .)
    COMMA           reduce using rule 60 (exp -> exp LE exp .)
    SEMI            reduce using rule 60 (exp -> exp LE exp .)
    RCURLY          reduce using rule 60 (exp -> exp LE exp .)
    RSQUARE         reduce using rule 60 (exp -> exp LE exp .)
    return          reduce using rule 60 (exp -> exp LE exp .)
    break           reduce using rule 60 (exp -> exp LE exp .)
    while           reduce using rule 60 (exp -> exp LE exp .)
    repeat          reduce using rule 60 (exp -> exp LE exp .)
    if              reduce using rule 60 (exp -> exp LE exp .)
    for             reduce using rule 60 (exp -> exp LE exp .)
    local           reduce using rule 60 (exp -> exp LE exp .)
    function        reduce using rule 60 (exp -> exp LE exp .)
    ID              reduce using rule 60 (exp -> exp LE exp .)
    RESID           reduce using rule 60 (exp -> exp LE exp .)
    LPAREN          reduce using rule 60 (exp -> exp LE exp .)
    $end            reduce using rule 60 (exp -> exp LE exp .)
    end             reduce using rule 60 (exp -> exp LE exp .)
    until           reduce using rule 60 (exp -> exp LE exp .)
    else            reduce using rule 60 (exp -> exp LE exp .)
    elseif          reduce using rule 60 (exp -> exp LE exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78

  ! PLUS            [ reduce using rule 60 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 60 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 60 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 60 (exp -> exp LE exp .) ]
  ! POWER           [ reduce using rule 60 (exp -> exp LE exp .) ]
  ! MODULO          [ reduce using rule 60 (exp -> exp LE exp .) ]
  ! DBLDOTS         [ reduce using rule 60 (exp -> exp LE exp .) ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]


state 112

    (58) exp -> exp POWER exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 58 (exp -> exp POWER exp .)
    PLUS            reduce using rule 58 (exp -> exp POWER exp .)
    MINUS           reduce using rule 58 (exp -> exp POWER exp .)
    TIMES           reduce using rule 58 (exp -> exp POWER exp .)
    DIVIDE          reduce using rule 58 (exp -> exp POWER exp .)
    LT              reduce using rule 58 (exp -> exp POWER exp .)
    LE              reduce using rule 58 (exp -> exp POWER exp .)
    GT              reduce using rule 58 (exp -> exp POWER exp .)
    GE              reduce using rule 58 (exp -> exp POWER exp .)
    NE              reduce using rule 58 (exp -> exp POWER exp .)
    CHECKEQ         reduce using rule 58 (exp -> exp POWER exp .)
    and             reduce using rule 58 (exp -> exp POWER exp .)
    or              reduce using rule 58 (exp -> exp POWER exp .)
    MODULO          reduce using rule 58 (exp -> exp POWER exp .)
    DBLDOTS         reduce using rule 58 (exp -> exp POWER exp .)
    RPAREN          reduce using rule 58 (exp -> exp POWER exp .)
    do              reduce using rule 58 (exp -> exp POWER exp .)
    COMMA           reduce using rule 58 (exp -> exp POWER exp .)
    SEMI            reduce using rule 58 (exp -> exp POWER exp .)
    RCURLY          reduce using rule 58 (exp -> exp POWER exp .)
    RSQUARE         reduce using rule 58 (exp -> exp POWER exp .)
    return          reduce using rule 58 (exp -> exp POWER exp .)
    break           reduce using rule 58 (exp -> exp POWER exp .)
    while           reduce using rule 58 (exp -> exp POWER exp .)
    repeat          reduce using rule 58 (exp -> exp POWER exp .)
    if              reduce using rule 58 (exp -> exp POWER exp .)
    for             reduce using rule 58 (exp -> exp POWER exp .)
    local           reduce using rule 58 (exp -> exp POWER exp .)
    function        reduce using rule 58 (exp -> exp POWER exp .)
    ID              reduce using rule 58 (exp -> exp POWER exp .)
    RESID           reduce using rule 58 (exp -> exp POWER exp .)
    LPAREN          reduce using rule 58 (exp -> exp POWER exp .)
    $end            reduce using rule 58 (exp -> exp POWER exp .)
    end             reduce using rule 58 (exp -> exp POWER exp .)
    until           reduce using rule 58 (exp -> exp POWER exp .)
    else            reduce using rule 58 (exp -> exp POWER exp .)
    elseif          reduce using rule 58 (exp -> exp POWER exp .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 58 (exp -> exp POWER exp .) ]
  ! PLUS            [ shift and go to state 76 ]
  ! MINUS           [ shift and go to state 79 ]
  ! TIMES           [ shift and go to state 72 ]
  ! DIVIDE          [ shift and go to state 81 ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]
  ! MODULO          [ shift and go to state 77 ]
  ! DBLDOTS         [ shift and go to state 78 ]


state 113

    (66) exp -> exp or exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 66 (exp -> exp or exp .)
    LT              reduce using rule 66 (exp -> exp or exp .)
    LE              reduce using rule 66 (exp -> exp or exp .)
    GT              reduce using rule 66 (exp -> exp or exp .)
    GE              reduce using rule 66 (exp -> exp or exp .)
    NE              reduce using rule 66 (exp -> exp or exp .)
    CHECKEQ         reduce using rule 66 (exp -> exp or exp .)
    and             reduce using rule 66 (exp -> exp or exp .)
    or              reduce using rule 66 (exp -> exp or exp .)
    RPAREN          reduce using rule 66 (exp -> exp or exp .)
    do              reduce using rule 66 (exp -> exp or exp .)
    COMMA           reduce using rule 66 (exp -> exp or exp .)
    SEMI            reduce using rule 66 (exp -> exp or exp .)
    RCURLY          reduce using rule 66 (exp -> exp or exp .)
    RSQUARE         reduce using rule 66 (exp -> exp or exp .)
    return          reduce using rule 66 (exp -> exp or exp .)
    break           reduce using rule 66 (exp -> exp or exp .)
    while           reduce using rule 66 (exp -> exp or exp .)
    repeat          reduce using rule 66 (exp -> exp or exp .)
    if              reduce using rule 66 (exp -> exp or exp .)
    for             reduce using rule 66 (exp -> exp or exp .)
    local           reduce using rule 66 (exp -> exp or exp .)
    function        reduce using rule 66 (exp -> exp or exp .)
    ID              reduce using rule 66 (exp -> exp or exp .)
    RESID           reduce using rule 66 (exp -> exp or exp .)
    LPAREN          reduce using rule 66 (exp -> exp or exp .)
    $end            reduce using rule 66 (exp -> exp or exp .)
    end             reduce using rule 66 (exp -> exp or exp .)
    until           reduce using rule 66 (exp -> exp or exp .)
    else            reduce using rule 66 (exp -> exp or exp .)
    elseif          reduce using rule 66 (exp -> exp or exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78

  ! PLUS            [ reduce using rule 66 (exp -> exp or exp .) ]
  ! MINUS           [ reduce using rule 66 (exp -> exp or exp .) ]
  ! TIMES           [ reduce using rule 66 (exp -> exp or exp .) ]
  ! DIVIDE          [ reduce using rule 66 (exp -> exp or exp .) ]
  ! POWER           [ reduce using rule 66 (exp -> exp or exp .) ]
  ! MODULO          [ reduce using rule 66 (exp -> exp or exp .) ]
  ! DBLDOTS         [ reduce using rule 66 (exp -> exp or exp .) ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]


state 114

    (62) exp -> exp GE exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 62 (exp -> exp GE exp .)
    LT              reduce using rule 62 (exp -> exp GE exp .)
    LE              reduce using rule 62 (exp -> exp GE exp .)
    GT              reduce using rule 62 (exp -> exp GE exp .)
    GE              reduce using rule 62 (exp -> exp GE exp .)
    NE              reduce using rule 62 (exp -> exp GE exp .)
    CHECKEQ         reduce using rule 62 (exp -> exp GE exp .)
    and             reduce using rule 62 (exp -> exp GE exp .)
    or              reduce using rule 62 (exp -> exp GE exp .)
    RPAREN          reduce using rule 62 (exp -> exp GE exp .)
    do              reduce using rule 62 (exp -> exp GE exp .)
    COMMA           reduce using rule 62 (exp -> exp GE exp .)
    SEMI            reduce using rule 62 (exp -> exp GE exp .)
    RCURLY          reduce using rule 62 (exp -> exp GE exp .)
    RSQUARE         reduce using rule 62 (exp -> exp GE exp .)
    return          reduce using rule 62 (exp -> exp GE exp .)
    break           reduce using rule 62 (exp -> exp GE exp .)
    while           reduce using rule 62 (exp -> exp GE exp .)
    repeat          reduce using rule 62 (exp -> exp GE exp .)
    if              reduce using rule 62 (exp -> exp GE exp .)
    for             reduce using rule 62 (exp -> exp GE exp .)
    local           reduce using rule 62 (exp -> exp GE exp .)
    function        reduce using rule 62 (exp -> exp GE exp .)
    ID              reduce using rule 62 (exp -> exp GE exp .)
    RESID           reduce using rule 62 (exp -> exp GE exp .)
    LPAREN          reduce using rule 62 (exp -> exp GE exp .)
    $end            reduce using rule 62 (exp -> exp GE exp .)
    end             reduce using rule 62 (exp -> exp GE exp .)
    until           reduce using rule 62 (exp -> exp GE exp .)
    else            reduce using rule 62 (exp -> exp GE exp .)
    elseif          reduce using rule 62 (exp -> exp GE exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78

  ! PLUS            [ reduce using rule 62 (exp -> exp GE exp .) ]
  ! MINUS           [ reduce using rule 62 (exp -> exp GE exp .) ]
  ! TIMES           [ reduce using rule 62 (exp -> exp GE exp .) ]
  ! DIVIDE          [ reduce using rule 62 (exp -> exp GE exp .) ]
  ! POWER           [ reduce using rule 62 (exp -> exp GE exp .) ]
  ! MODULO          [ reduce using rule 62 (exp -> exp GE exp .) ]
  ! DBLDOTS         [ reduce using rule 62 (exp -> exp GE exp .) ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]


state 115

    (56) exp -> exp TIMES exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 56 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 56 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 56 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 56 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 56 (exp -> exp TIMES exp .)
    LT              reduce using rule 56 (exp -> exp TIMES exp .)
    LE              reduce using rule 56 (exp -> exp TIMES exp .)
    GT              reduce using rule 56 (exp -> exp TIMES exp .)
    GE              reduce using rule 56 (exp -> exp TIMES exp .)
    NE              reduce using rule 56 (exp -> exp TIMES exp .)
    CHECKEQ         reduce using rule 56 (exp -> exp TIMES exp .)
    and             reduce using rule 56 (exp -> exp TIMES exp .)
    or              reduce using rule 56 (exp -> exp TIMES exp .)
    MODULO          reduce using rule 56 (exp -> exp TIMES exp .)
    DBLDOTS         reduce using rule 56 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 56 (exp -> exp TIMES exp .)
    do              reduce using rule 56 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 56 (exp -> exp TIMES exp .)
    SEMI            reduce using rule 56 (exp -> exp TIMES exp .)
    RCURLY          reduce using rule 56 (exp -> exp TIMES exp .)
    RSQUARE         reduce using rule 56 (exp -> exp TIMES exp .)
    return          reduce using rule 56 (exp -> exp TIMES exp .)
    break           reduce using rule 56 (exp -> exp TIMES exp .)
    while           reduce using rule 56 (exp -> exp TIMES exp .)
    repeat          reduce using rule 56 (exp -> exp TIMES exp .)
    if              reduce using rule 56 (exp -> exp TIMES exp .)
    for             reduce using rule 56 (exp -> exp TIMES exp .)
    local           reduce using rule 56 (exp -> exp TIMES exp .)
    function        reduce using rule 56 (exp -> exp TIMES exp .)
    ID              reduce using rule 56 (exp -> exp TIMES exp .)
    RESID           reduce using rule 56 (exp -> exp TIMES exp .)
    LPAREN          reduce using rule 56 (exp -> exp TIMES exp .)
    $end            reduce using rule 56 (exp -> exp TIMES exp .)
    end             reduce using rule 56 (exp -> exp TIMES exp .)
    until           reduce using rule 56 (exp -> exp TIMES exp .)
    else            reduce using rule 56 (exp -> exp TIMES exp .)
    elseif          reduce using rule 56 (exp -> exp TIMES exp .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 56 (exp -> exp TIMES exp .) ]
  ! PLUS            [ shift and go to state 76 ]
  ! MINUS           [ shift and go to state 79 ]
  ! TIMES           [ shift and go to state 72 ]
  ! DIVIDE          [ shift and go to state 81 ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]
  ! MODULO          [ shift and go to state 77 ]
  ! DBLDOTS         [ shift and go to state 78 ]


state 116

    (64) exp -> exp CHECKEQ exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 64 (exp -> exp CHECKEQ exp .)
    LT              reduce using rule 64 (exp -> exp CHECKEQ exp .)
    LE              reduce using rule 64 (exp -> exp CHECKEQ exp .)
    GT              reduce using rule 64 (exp -> exp CHECKEQ exp .)
    GE              reduce using rule 64 (exp -> exp CHECKEQ exp .)
    NE              reduce using rule 64 (exp -> exp CHECKEQ exp .)
    CHECKEQ         reduce using rule 64 (exp -> exp CHECKEQ exp .)
    and             reduce using rule 64 (exp -> exp CHECKEQ exp .)
    or              reduce using rule 64 (exp -> exp CHECKEQ exp .)
    RPAREN          reduce using rule 64 (exp -> exp CHECKEQ exp .)
    do              reduce using rule 64 (exp -> exp CHECKEQ exp .)
    COMMA           reduce using rule 64 (exp -> exp CHECKEQ exp .)
    SEMI            reduce using rule 64 (exp -> exp CHECKEQ exp .)
    RCURLY          reduce using rule 64 (exp -> exp CHECKEQ exp .)
    RSQUARE         reduce using rule 64 (exp -> exp CHECKEQ exp .)
    return          reduce using rule 64 (exp -> exp CHECKEQ exp .)
    break           reduce using rule 64 (exp -> exp CHECKEQ exp .)
    while           reduce using rule 64 (exp -> exp CHECKEQ exp .)
    repeat          reduce using rule 64 (exp -> exp CHECKEQ exp .)
    if              reduce using rule 64 (exp -> exp CHECKEQ exp .)
    for             reduce using rule 64 (exp -> exp CHECKEQ exp .)
    local           reduce using rule 64 (exp -> exp CHECKEQ exp .)
    function        reduce using rule 64 (exp -> exp CHECKEQ exp .)
    ID              reduce using rule 64 (exp -> exp CHECKEQ exp .)
    RESID           reduce using rule 64 (exp -> exp CHECKEQ exp .)
    LPAREN          reduce using rule 64 (exp -> exp CHECKEQ exp .)
    $end            reduce using rule 64 (exp -> exp CHECKEQ exp .)
    end             reduce using rule 64 (exp -> exp CHECKEQ exp .)
    until           reduce using rule 64 (exp -> exp CHECKEQ exp .)
    else            reduce using rule 64 (exp -> exp CHECKEQ exp .)
    elseif          reduce using rule 64 (exp -> exp CHECKEQ exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78

  ! PLUS            [ reduce using rule 64 (exp -> exp CHECKEQ exp .) ]
  ! MINUS           [ reduce using rule 64 (exp -> exp CHECKEQ exp .) ]
  ! TIMES           [ reduce using rule 64 (exp -> exp CHECKEQ exp .) ]
  ! DIVIDE          [ reduce using rule 64 (exp -> exp CHECKEQ exp .) ]
  ! POWER           [ reduce using rule 64 (exp -> exp CHECKEQ exp .) ]
  ! MODULO          [ reduce using rule 64 (exp -> exp CHECKEQ exp .) ]
  ! DBLDOTS         [ reduce using rule 64 (exp -> exp CHECKEQ exp .) ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]


state 117

    (59) exp -> exp LT exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 59 (exp -> exp LT exp .)
    LT              reduce using rule 59 (exp -> exp LT exp .)
    LE              reduce using rule 59 (exp -> exp LT exp .)
    GT              reduce using rule 59 (exp -> exp LT exp .)
    GE              reduce using rule 59 (exp -> exp LT exp .)
    NE              reduce using rule 59 (exp -> exp LT exp .)
    CHECKEQ         reduce using rule 59 (exp -> exp LT exp .)
    and             reduce using rule 59 (exp -> exp LT exp .)
    or              reduce using rule 59 (exp -> exp LT exp .)
    RPAREN          reduce using rule 59 (exp -> exp LT exp .)
    do              reduce using rule 59 (exp -> exp LT exp .)
    COMMA           reduce using rule 59 (exp -> exp LT exp .)
    SEMI            reduce using rule 59 (exp -> exp LT exp .)
    RCURLY          reduce using rule 59 (exp -> exp LT exp .)
    RSQUARE         reduce using rule 59 (exp -> exp LT exp .)
    return          reduce using rule 59 (exp -> exp LT exp .)
    break           reduce using rule 59 (exp -> exp LT exp .)
    while           reduce using rule 59 (exp -> exp LT exp .)
    repeat          reduce using rule 59 (exp -> exp LT exp .)
    if              reduce using rule 59 (exp -> exp LT exp .)
    for             reduce using rule 59 (exp -> exp LT exp .)
    local           reduce using rule 59 (exp -> exp LT exp .)
    function        reduce using rule 59 (exp -> exp LT exp .)
    ID              reduce using rule 59 (exp -> exp LT exp .)
    RESID           reduce using rule 59 (exp -> exp LT exp .)
    LPAREN          reduce using rule 59 (exp -> exp LT exp .)
    $end            reduce using rule 59 (exp -> exp LT exp .)
    end             reduce using rule 59 (exp -> exp LT exp .)
    until           reduce using rule 59 (exp -> exp LT exp .)
    else            reduce using rule 59 (exp -> exp LT exp .)
    elseif          reduce using rule 59 (exp -> exp LT exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78

  ! PLUS            [ reduce using rule 59 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 59 (exp -> exp LT exp .) ]
  ! TIMES           [ reduce using rule 59 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 59 (exp -> exp LT exp .) ]
  ! POWER           [ reduce using rule 59 (exp -> exp LT exp .) ]
  ! MODULO          [ reduce using rule 59 (exp -> exp LT exp .) ]
  ! DBLDOTS         [ reduce using rule 59 (exp -> exp LT exp .) ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]


state 118

    (61) exp -> exp GT exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 61 (exp -> exp GT exp .)
    LT              reduce using rule 61 (exp -> exp GT exp .)
    LE              reduce using rule 61 (exp -> exp GT exp .)
    GT              reduce using rule 61 (exp -> exp GT exp .)
    GE              reduce using rule 61 (exp -> exp GT exp .)
    NE              reduce using rule 61 (exp -> exp GT exp .)
    CHECKEQ         reduce using rule 61 (exp -> exp GT exp .)
    and             reduce using rule 61 (exp -> exp GT exp .)
    or              reduce using rule 61 (exp -> exp GT exp .)
    RPAREN          reduce using rule 61 (exp -> exp GT exp .)
    do              reduce using rule 61 (exp -> exp GT exp .)
    COMMA           reduce using rule 61 (exp -> exp GT exp .)
    SEMI            reduce using rule 61 (exp -> exp GT exp .)
    RCURLY          reduce using rule 61 (exp -> exp GT exp .)
    RSQUARE         reduce using rule 61 (exp -> exp GT exp .)
    return          reduce using rule 61 (exp -> exp GT exp .)
    break           reduce using rule 61 (exp -> exp GT exp .)
    while           reduce using rule 61 (exp -> exp GT exp .)
    repeat          reduce using rule 61 (exp -> exp GT exp .)
    if              reduce using rule 61 (exp -> exp GT exp .)
    for             reduce using rule 61 (exp -> exp GT exp .)
    local           reduce using rule 61 (exp -> exp GT exp .)
    function        reduce using rule 61 (exp -> exp GT exp .)
    ID              reduce using rule 61 (exp -> exp GT exp .)
    RESID           reduce using rule 61 (exp -> exp GT exp .)
    LPAREN          reduce using rule 61 (exp -> exp GT exp .)
    $end            reduce using rule 61 (exp -> exp GT exp .)
    end             reduce using rule 61 (exp -> exp GT exp .)
    until           reduce using rule 61 (exp -> exp GT exp .)
    else            reduce using rule 61 (exp -> exp GT exp .)
    elseif          reduce using rule 61 (exp -> exp GT exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78

  ! PLUS            [ reduce using rule 61 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 61 (exp -> exp GT exp .) ]
  ! TIMES           [ reduce using rule 61 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 61 (exp -> exp GT exp .) ]
  ! POWER           [ reduce using rule 61 (exp -> exp GT exp .) ]
  ! MODULO          [ reduce using rule 61 (exp -> exp GT exp .) ]
  ! DBLDOTS         [ reduce using rule 61 (exp -> exp GT exp .) ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]


state 119

    (54) exp -> exp PLUS exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 54 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 54 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 54 (exp -> exp PLUS exp .)
    LT              reduce using rule 54 (exp -> exp PLUS exp .)
    LE              reduce using rule 54 (exp -> exp PLUS exp .)
    GT              reduce using rule 54 (exp -> exp PLUS exp .)
    GE              reduce using rule 54 (exp -> exp PLUS exp .)
    NE              reduce using rule 54 (exp -> exp PLUS exp .)
    CHECKEQ         reduce using rule 54 (exp -> exp PLUS exp .)
    and             reduce using rule 54 (exp -> exp PLUS exp .)
    or              reduce using rule 54 (exp -> exp PLUS exp .)
    DBLDOTS         reduce using rule 54 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 54 (exp -> exp PLUS exp .)
    do              reduce using rule 54 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 54 (exp -> exp PLUS exp .)
    SEMI            reduce using rule 54 (exp -> exp PLUS exp .)
    RCURLY          reduce using rule 54 (exp -> exp PLUS exp .)
    RSQUARE         reduce using rule 54 (exp -> exp PLUS exp .)
    return          reduce using rule 54 (exp -> exp PLUS exp .)
    break           reduce using rule 54 (exp -> exp PLUS exp .)
    while           reduce using rule 54 (exp -> exp PLUS exp .)
    repeat          reduce using rule 54 (exp -> exp PLUS exp .)
    if              reduce using rule 54 (exp -> exp PLUS exp .)
    for             reduce using rule 54 (exp -> exp PLUS exp .)
    local           reduce using rule 54 (exp -> exp PLUS exp .)
    function        reduce using rule 54 (exp -> exp PLUS exp .)
    ID              reduce using rule 54 (exp -> exp PLUS exp .)
    RESID           reduce using rule 54 (exp -> exp PLUS exp .)
    LPAREN          reduce using rule 54 (exp -> exp PLUS exp .)
    $end            reduce using rule 54 (exp -> exp PLUS exp .)
    end             reduce using rule 54 (exp -> exp PLUS exp .)
    until           reduce using rule 54 (exp -> exp PLUS exp .)
    else            reduce using rule 54 (exp -> exp PLUS exp .)
    elseif          reduce using rule 54 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    MODULO          shift and go to state 77

  ! TIMES           [ reduce using rule 54 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 54 (exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 54 (exp -> exp PLUS exp .) ]
  ! MODULO          [ reduce using rule 54 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 76 ]
  ! MINUS           [ shift and go to state 79 ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]
  ! DBLDOTS         [ shift and go to state 78 ]


state 120

    (67) exp -> exp MODULO exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 67 (exp -> exp MODULO exp .)
    PLUS            reduce using rule 67 (exp -> exp MODULO exp .)
    MINUS           reduce using rule 67 (exp -> exp MODULO exp .)
    TIMES           reduce using rule 67 (exp -> exp MODULO exp .)
    DIVIDE          reduce using rule 67 (exp -> exp MODULO exp .)
    LT              reduce using rule 67 (exp -> exp MODULO exp .)
    LE              reduce using rule 67 (exp -> exp MODULO exp .)
    GT              reduce using rule 67 (exp -> exp MODULO exp .)
    GE              reduce using rule 67 (exp -> exp MODULO exp .)
    NE              reduce using rule 67 (exp -> exp MODULO exp .)
    CHECKEQ         reduce using rule 67 (exp -> exp MODULO exp .)
    and             reduce using rule 67 (exp -> exp MODULO exp .)
    or              reduce using rule 67 (exp -> exp MODULO exp .)
    MODULO          reduce using rule 67 (exp -> exp MODULO exp .)
    DBLDOTS         reduce using rule 67 (exp -> exp MODULO exp .)
    RPAREN          reduce using rule 67 (exp -> exp MODULO exp .)
    do              reduce using rule 67 (exp -> exp MODULO exp .)
    COMMA           reduce using rule 67 (exp -> exp MODULO exp .)
    SEMI            reduce using rule 67 (exp -> exp MODULO exp .)
    RCURLY          reduce using rule 67 (exp -> exp MODULO exp .)
    RSQUARE         reduce using rule 67 (exp -> exp MODULO exp .)
    return          reduce using rule 67 (exp -> exp MODULO exp .)
    break           reduce using rule 67 (exp -> exp MODULO exp .)
    while           reduce using rule 67 (exp -> exp MODULO exp .)
    repeat          reduce using rule 67 (exp -> exp MODULO exp .)
    if              reduce using rule 67 (exp -> exp MODULO exp .)
    for             reduce using rule 67 (exp -> exp MODULO exp .)
    local           reduce using rule 67 (exp -> exp MODULO exp .)
    function        reduce using rule 67 (exp -> exp MODULO exp .)
    ID              reduce using rule 67 (exp -> exp MODULO exp .)
    RESID           reduce using rule 67 (exp -> exp MODULO exp .)
    LPAREN          reduce using rule 67 (exp -> exp MODULO exp .)
    $end            reduce using rule 67 (exp -> exp MODULO exp .)
    end             reduce using rule 67 (exp -> exp MODULO exp .)
    until           reduce using rule 67 (exp -> exp MODULO exp .)
    else            reduce using rule 67 (exp -> exp MODULO exp .)
    elseif          reduce using rule 67 (exp -> exp MODULO exp .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 67 (exp -> exp MODULO exp .) ]
  ! PLUS            [ shift and go to state 76 ]
  ! MINUS           [ shift and go to state 79 ]
  ! TIMES           [ shift and go to state 72 ]
  ! DIVIDE          [ shift and go to state 81 ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]
  ! MODULO          [ shift and go to state 77 ]
  ! DBLDOTS         [ shift and go to state 78 ]


state 121

    (68) exp -> exp DBLDOTS exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 68 (exp -> exp DBLDOTS exp .)
    LT              reduce using rule 68 (exp -> exp DBLDOTS exp .)
    LE              reduce using rule 68 (exp -> exp DBLDOTS exp .)
    GT              reduce using rule 68 (exp -> exp DBLDOTS exp .)
    GE              reduce using rule 68 (exp -> exp DBLDOTS exp .)
    NE              reduce using rule 68 (exp -> exp DBLDOTS exp .)
    CHECKEQ         reduce using rule 68 (exp -> exp DBLDOTS exp .)
    and             reduce using rule 68 (exp -> exp DBLDOTS exp .)
    or              reduce using rule 68 (exp -> exp DBLDOTS exp .)
    RPAREN          reduce using rule 68 (exp -> exp DBLDOTS exp .)
    do              reduce using rule 68 (exp -> exp DBLDOTS exp .)
    COMMA           reduce using rule 68 (exp -> exp DBLDOTS exp .)
    SEMI            reduce using rule 68 (exp -> exp DBLDOTS exp .)
    RCURLY          reduce using rule 68 (exp -> exp DBLDOTS exp .)
    RSQUARE         reduce using rule 68 (exp -> exp DBLDOTS exp .)
    return          reduce using rule 68 (exp -> exp DBLDOTS exp .)
    break           reduce using rule 68 (exp -> exp DBLDOTS exp .)
    while           reduce using rule 68 (exp -> exp DBLDOTS exp .)
    repeat          reduce using rule 68 (exp -> exp DBLDOTS exp .)
    if              reduce using rule 68 (exp -> exp DBLDOTS exp .)
    for             reduce using rule 68 (exp -> exp DBLDOTS exp .)
    local           reduce using rule 68 (exp -> exp DBLDOTS exp .)
    function        reduce using rule 68 (exp -> exp DBLDOTS exp .)
    ID              reduce using rule 68 (exp -> exp DBLDOTS exp .)
    RESID           reduce using rule 68 (exp -> exp DBLDOTS exp .)
    LPAREN          reduce using rule 68 (exp -> exp DBLDOTS exp .)
    $end            reduce using rule 68 (exp -> exp DBLDOTS exp .)
    end             reduce using rule 68 (exp -> exp DBLDOTS exp .)
    until           reduce using rule 68 (exp -> exp DBLDOTS exp .)
    else            reduce using rule 68 (exp -> exp DBLDOTS exp .)
    elseif          reduce using rule 68 (exp -> exp DBLDOTS exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78

  ! PLUS            [ reduce using rule 68 (exp -> exp DBLDOTS exp .) ]
  ! MINUS           [ reduce using rule 68 (exp -> exp DBLDOTS exp .) ]
  ! TIMES           [ reduce using rule 68 (exp -> exp DBLDOTS exp .) ]
  ! DIVIDE          [ reduce using rule 68 (exp -> exp DBLDOTS exp .) ]
  ! POWER           [ reduce using rule 68 (exp -> exp DBLDOTS exp .) ]
  ! MODULO          [ reduce using rule 68 (exp -> exp DBLDOTS exp .) ]
  ! DBLDOTS         [ reduce using rule 68 (exp -> exp DBLDOTS exp .) ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]


state 122

    (55) exp -> exp MINUS exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 55 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 55 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 55 (exp -> exp MINUS exp .)
    LT              reduce using rule 55 (exp -> exp MINUS exp .)
    LE              reduce using rule 55 (exp -> exp MINUS exp .)
    GT              reduce using rule 55 (exp -> exp MINUS exp .)
    GE              reduce using rule 55 (exp -> exp MINUS exp .)
    NE              reduce using rule 55 (exp -> exp MINUS exp .)
    CHECKEQ         reduce using rule 55 (exp -> exp MINUS exp .)
    and             reduce using rule 55 (exp -> exp MINUS exp .)
    or              reduce using rule 55 (exp -> exp MINUS exp .)
    DBLDOTS         reduce using rule 55 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 55 (exp -> exp MINUS exp .)
    do              reduce using rule 55 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 55 (exp -> exp MINUS exp .)
    SEMI            reduce using rule 55 (exp -> exp MINUS exp .)
    RCURLY          reduce using rule 55 (exp -> exp MINUS exp .)
    RSQUARE         reduce using rule 55 (exp -> exp MINUS exp .)
    return          reduce using rule 55 (exp -> exp MINUS exp .)
    break           reduce using rule 55 (exp -> exp MINUS exp .)
    while           reduce using rule 55 (exp -> exp MINUS exp .)
    repeat          reduce using rule 55 (exp -> exp MINUS exp .)
    if              reduce using rule 55 (exp -> exp MINUS exp .)
    for             reduce using rule 55 (exp -> exp MINUS exp .)
    local           reduce using rule 55 (exp -> exp MINUS exp .)
    function        reduce using rule 55 (exp -> exp MINUS exp .)
    ID              reduce using rule 55 (exp -> exp MINUS exp .)
    RESID           reduce using rule 55 (exp -> exp MINUS exp .)
    LPAREN          reduce using rule 55 (exp -> exp MINUS exp .)
    $end            reduce using rule 55 (exp -> exp MINUS exp .)
    end             reduce using rule 55 (exp -> exp MINUS exp .)
    until           reduce using rule 55 (exp -> exp MINUS exp .)
    else            reduce using rule 55 (exp -> exp MINUS exp .)
    elseif          reduce using rule 55 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    MODULO          shift and go to state 77

  ! TIMES           [ reduce using rule 55 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 55 (exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 55 (exp -> exp MINUS exp .) ]
  ! MODULO          [ reduce using rule 55 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 76 ]
  ! MINUS           [ shift and go to state 79 ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]
  ! DBLDOTS         [ shift and go to state 78 ]


state 123

    (63) exp -> exp NE exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 63 (exp -> exp NE exp .)
    LT              reduce using rule 63 (exp -> exp NE exp .)
    LE              reduce using rule 63 (exp -> exp NE exp .)
    GT              reduce using rule 63 (exp -> exp NE exp .)
    GE              reduce using rule 63 (exp -> exp NE exp .)
    NE              reduce using rule 63 (exp -> exp NE exp .)
    CHECKEQ         reduce using rule 63 (exp -> exp NE exp .)
    and             reduce using rule 63 (exp -> exp NE exp .)
    or              reduce using rule 63 (exp -> exp NE exp .)
    RPAREN          reduce using rule 63 (exp -> exp NE exp .)
    do              reduce using rule 63 (exp -> exp NE exp .)
    COMMA           reduce using rule 63 (exp -> exp NE exp .)
    SEMI            reduce using rule 63 (exp -> exp NE exp .)
    RCURLY          reduce using rule 63 (exp -> exp NE exp .)
    RSQUARE         reduce using rule 63 (exp -> exp NE exp .)
    return          reduce using rule 63 (exp -> exp NE exp .)
    break           reduce using rule 63 (exp -> exp NE exp .)
    while           reduce using rule 63 (exp -> exp NE exp .)
    repeat          reduce using rule 63 (exp -> exp NE exp .)
    if              reduce using rule 63 (exp -> exp NE exp .)
    for             reduce using rule 63 (exp -> exp NE exp .)
    local           reduce using rule 63 (exp -> exp NE exp .)
    function        reduce using rule 63 (exp -> exp NE exp .)
    ID              reduce using rule 63 (exp -> exp NE exp .)
    RESID           reduce using rule 63 (exp -> exp NE exp .)
    LPAREN          reduce using rule 63 (exp -> exp NE exp .)
    $end            reduce using rule 63 (exp -> exp NE exp .)
    end             reduce using rule 63 (exp -> exp NE exp .)
    until           reduce using rule 63 (exp -> exp NE exp .)
    else            reduce using rule 63 (exp -> exp NE exp .)
    elseif          reduce using rule 63 (exp -> exp NE exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78

  ! PLUS            [ reduce using rule 63 (exp -> exp NE exp .) ]
  ! MINUS           [ reduce using rule 63 (exp -> exp NE exp .) ]
  ! TIMES           [ reduce using rule 63 (exp -> exp NE exp .) ]
  ! DIVIDE          [ reduce using rule 63 (exp -> exp NE exp .) ]
  ! POWER           [ reduce using rule 63 (exp -> exp NE exp .) ]
  ! MODULO          [ reduce using rule 63 (exp -> exp NE exp .) ]
  ! DBLDOTS         [ reduce using rule 63 (exp -> exp NE exp .) ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]


state 124

    (57) exp -> exp DIVIDE exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            reduce using rule 57 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 57 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 57 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 57 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 57 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 57 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 57 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 57 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 57 (exp -> exp DIVIDE exp .)
    NE              reduce using rule 57 (exp -> exp DIVIDE exp .)
    CHECKEQ         reduce using rule 57 (exp -> exp DIVIDE exp .)
    and             reduce using rule 57 (exp -> exp DIVIDE exp .)
    or              reduce using rule 57 (exp -> exp DIVIDE exp .)
    MODULO          reduce using rule 57 (exp -> exp DIVIDE exp .)
    DBLDOTS         reduce using rule 57 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 57 (exp -> exp DIVIDE exp .)
    do              reduce using rule 57 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 57 (exp -> exp DIVIDE exp .)
    SEMI            reduce using rule 57 (exp -> exp DIVIDE exp .)
    RCURLY          reduce using rule 57 (exp -> exp DIVIDE exp .)
    RSQUARE         reduce using rule 57 (exp -> exp DIVIDE exp .)
    return          reduce using rule 57 (exp -> exp DIVIDE exp .)
    break           reduce using rule 57 (exp -> exp DIVIDE exp .)
    while           reduce using rule 57 (exp -> exp DIVIDE exp .)
    repeat          reduce using rule 57 (exp -> exp DIVIDE exp .)
    if              reduce using rule 57 (exp -> exp DIVIDE exp .)
    for             reduce using rule 57 (exp -> exp DIVIDE exp .)
    local           reduce using rule 57 (exp -> exp DIVIDE exp .)
    function        reduce using rule 57 (exp -> exp DIVIDE exp .)
    ID              reduce using rule 57 (exp -> exp DIVIDE exp .)
    RESID           reduce using rule 57 (exp -> exp DIVIDE exp .)
    LPAREN          reduce using rule 57 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 57 (exp -> exp DIVIDE exp .)
    end             reduce using rule 57 (exp -> exp DIVIDE exp .)
    until           reduce using rule 57 (exp -> exp DIVIDE exp .)
    else            reduce using rule 57 (exp -> exp DIVIDE exp .)
    elseif          reduce using rule 57 (exp -> exp DIVIDE exp .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 57 (exp -> exp DIVIDE exp .) ]
  ! PLUS            [ shift and go to state 76 ]
  ! MINUS           [ shift and go to state 79 ]
  ! TIMES           [ shift and go to state 72 ]
  ! DIVIDE          [ shift and go to state 81 ]
  ! LT              [ shift and go to state 74 ]
  ! LE              [ shift and go to state 67 ]
  ! GT              [ shift and go to state 75 ]
  ! GE              [ shift and go to state 71 ]
  ! NE              [ shift and go to state 80 ]
  ! CHECKEQ         [ shift and go to state 73 ]
  ! and             [ shift and go to state 66 ]
  ! or              [ shift and go to state 70 ]
  ! MODULO          [ shift and go to state 77 ]
  ! DBLDOTS         [ shift and go to state 78 ]


state 125

    (11) stat -> if exp then block . ifblock else block end
    (12) stat -> if exp then block . ifblock end
    (37) ifblock -> . ifblock elseif exp then block
    (38) ifblock -> . empty
    (74) empty -> .

    else            reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)
    elseif          reduce using rule 74 (empty -> .)

    empty                          shift and go to state 148
    ifblock                        shift and go to state 149

state 126

    (41) var -> prefixexp LSQUARE exp RSQUARE .

    LSQUARE         reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    SDOT            reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    PLUS            reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    MINUS           reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    TIMES           reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    DIVIDE          reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    POWER           reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    LT              reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    LE              reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    GT              reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    GE              reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    NE              reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    CHECKEQ         reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    and             reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    or              reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    MODULO          reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    DBLDOTS         reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    SEMI            reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    return          reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    break           reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    do              reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    while           reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    repeat          reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    if              reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    for             reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    local           reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    function        reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    ID              reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    RESID           reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    LPAREN          reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    $end            reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    end             reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    until           reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    else            reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    elseif          reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    COMMA           reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    EQUALS          reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    RPAREN          reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    then            reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    RCURLY          reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)
    RSQUARE         reduce using rule 41 (var -> prefixexp LSQUARE exp RSQUARE .)


state 127

    (15) stat -> for namelist in explist . do block end
    (44) explist -> explist . COMMA exp

    do              shift and go to state 150
    COMMA           shift and go to state 130


state 128

    (13) stat -> for names EQUALS exp . COMMA exp do block end
    (14) stat -> for names EQUALS exp . COMMA exp COMMA exp do block end
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    COMMA           shift and go to state 151
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 129

    (35) comid -> COMMA names . comid
    (35) comid -> . COMMA names comid
    (36) comid -> . empty
    (74) empty -> .

    COMMA           shift and go to state 88
    in              reduce using rule 74 (empty -> .)
    EQUALS          reduce using rule 74 (empty -> .)
    SEMI            reduce using rule 74 (empty -> .)
    return          reduce using rule 74 (empty -> .)
    break           reduce using rule 74 (empty -> .)
    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    $end            reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)
    until           reduce using rule 74 (empty -> .)
    else            reduce using rule 74 (empty -> .)
    elseif          reduce using rule 74 (empty -> .)
    RPAREN          reduce using rule 74 (empty -> .)

  ! COMMA           [ reduce using rule 74 (empty -> .) ]

    empty                          shift and go to state 87
    comid                          shift and go to state 152

state 130

    (44) explist -> explist COMMA . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 153
    var                            shift and go to state 26
    names                          shift and go to state 5

state 131

    (33) comvar -> COMMA var comvar .

    EQUALS          reduce using rule 33 (comvar -> COMMA var comvar .)


state 132

    (19) stat -> local function names funcbody .

    SEMI            reduce using rule 19 (stat -> local function names funcbody .)
    return          reduce using rule 19 (stat -> local function names funcbody .)
    break           reduce using rule 19 (stat -> local function names funcbody .)
    do              reduce using rule 19 (stat -> local function names funcbody .)
    while           reduce using rule 19 (stat -> local function names funcbody .)
    repeat          reduce using rule 19 (stat -> local function names funcbody .)
    if              reduce using rule 19 (stat -> local function names funcbody .)
    for             reduce using rule 19 (stat -> local function names funcbody .)
    local           reduce using rule 19 (stat -> local function names funcbody .)
    function        reduce using rule 19 (stat -> local function names funcbody .)
    ID              reduce using rule 19 (stat -> local function names funcbody .)
    RESID           reduce using rule 19 (stat -> local function names funcbody .)
    LPAREN          reduce using rule 19 (stat -> local function names funcbody .)
    end             reduce using rule 19 (stat -> local function names funcbody .)
    until           reduce using rule 19 (stat -> local function names funcbody .)
    else            reduce using rule 19 (stat -> local function names funcbody .)
    elseif          reduce using rule 19 (stat -> local function names funcbody .)
    $end            reduce using rule 19 (stat -> local function names funcbody .)


state 133

    (17) stat -> local namelist EQUALS explist .
    (44) explist -> explist . COMMA exp

    SEMI            reduce using rule 17 (stat -> local namelist EQUALS explist .)
    return          reduce using rule 17 (stat -> local namelist EQUALS explist .)
    break           reduce using rule 17 (stat -> local namelist EQUALS explist .)
    do              reduce using rule 17 (stat -> local namelist EQUALS explist .)
    while           reduce using rule 17 (stat -> local namelist EQUALS explist .)
    repeat          reduce using rule 17 (stat -> local namelist EQUALS explist .)
    if              reduce using rule 17 (stat -> local namelist EQUALS explist .)
    for             reduce using rule 17 (stat -> local namelist EQUALS explist .)
    local           reduce using rule 17 (stat -> local namelist EQUALS explist .)
    function        reduce using rule 17 (stat -> local namelist EQUALS explist .)
    ID              reduce using rule 17 (stat -> local namelist EQUALS explist .)
    RESID           reduce using rule 17 (stat -> local namelist EQUALS explist .)
    LPAREN          reduce using rule 17 (stat -> local namelist EQUALS explist .)
    end             reduce using rule 17 (stat -> local namelist EQUALS explist .)
    until           reduce using rule 17 (stat -> local namelist EQUALS explist .)
    else            reduce using rule 17 (stat -> local namelist EQUALS explist .)
    elseif          reduce using rule 17 (stat -> local namelist EQUALS explist .)
    $end            reduce using rule 17 (stat -> local namelist EQUALS explist .)
    COMMA           shift and go to state 130


state 134

    (22) parlist -> namelist .
    (23) parlist -> namelist . comtrp
    (25) comtrp -> . COMMA TRPLDOTS

    RPAREN          reduce using rule 22 (parlist -> namelist .)
    COMMA           shift and go to state 154

    comtrp                         shift and go to state 155

state 135

    (24) parlist -> TRPLDOTS .

    RPAREN          reduce using rule 24 (parlist -> TRPLDOTS .)


state 136

    (21) funcbody -> LPAREN parlist . RPAREN block end

    RPAREN          shift and go to state 156


state 137

    (20) funcbody -> LPAREN RPAREN . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)

    empty                          shift and go to state 1
    chunk                          shift and go to state 51
    block                          shift and go to state 157

state 138

    (31) dotid -> SDOT names . dotid
    (31) dotid -> . SDOT names dotid
    (32) dotid -> . empty
    (74) empty -> .

    SDOT            shift and go to state 97
    COLON           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)

    dotid                          shift and go to state 158
    empty                          shift and go to state 99

state 139

    (29) funcname -> names dotid COLON .

    LPAREN          reduce using rule 29 (funcname -> names dotid COLON .)


state 140

    (4) chunk -> chunk stat SEMI laststat SEMI .

    do              reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    while           reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    repeat          reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    if              reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    for             reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    local           reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    function        reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    ID              reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    RESID           reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    LPAREN          reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    end             reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    else            reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    elseif          reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    $end            reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    until           reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)


state 141

    (10) stat -> repeat block until exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    SEMI            reduce using rule 10 (stat -> repeat block until exp .)
    return          reduce using rule 10 (stat -> repeat block until exp .)
    break           reduce using rule 10 (stat -> repeat block until exp .)
    do              reduce using rule 10 (stat -> repeat block until exp .)
    while           reduce using rule 10 (stat -> repeat block until exp .)
    repeat          reduce using rule 10 (stat -> repeat block until exp .)
    if              reduce using rule 10 (stat -> repeat block until exp .)
    for             reduce using rule 10 (stat -> repeat block until exp .)
    local           reduce using rule 10 (stat -> repeat block until exp .)
    function        reduce using rule 10 (stat -> repeat block until exp .)
    ID              reduce using rule 10 (stat -> repeat block until exp .)
    RESID           reduce using rule 10 (stat -> repeat block until exp .)
    LPAREN          reduce using rule 10 (stat -> repeat block until exp .)
    end             reduce using rule 10 (stat -> repeat block until exp .)
    until           reduce using rule 10 (stat -> repeat block until exp .)
    else            reduce using rule 10 (stat -> repeat block until exp .)
    elseif          reduce using rule 10 (stat -> repeat block until exp .)
    $end            reduce using rule 10 (stat -> repeat block until exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 142

    (9) stat -> while exp do block . end

    end             shift and go to state 159


state 143

    (87) field -> names EQUALS exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 87 (field -> names EQUALS exp .)
    SEMI            reduce using rule 87 (field -> names EQUALS exp .)
    RCURLY          reduce using rule 87 (field -> names EQUALS exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 144

    (82) fieldlist -> field fieldseplist fieldsep .
    (84) fieldseplist -> fieldseplist fieldsep . field
    (86) field -> . LSQUARE exp RSQUARE EQUALS exp
    (87) field -> . names EQUALS exp
    (88) field -> . exp
    (91) names -> . ID
    (92) names -> . RESID
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names

    RCURLY          reduce using rule 82 (fieldlist -> field fieldseplist fieldsep .)
    LSQUARE         shift and go to state 65
    ID              shift and go to state 16
    RESID           shift and go to state 3
    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    field                          shift and go to state 160
    unop                           shift and go to state 18
    names                          shift and go to state 60
    exp                            shift and go to state 64
    var                            shift and go to state 26

state 145

    (89) fieldsep -> COMMA .

    LSQUARE         reduce using rule 89 (fieldsep -> COMMA .)
    ID              reduce using rule 89 (fieldsep -> COMMA .)
    RESID           reduce using rule 89 (fieldsep -> COMMA .)
    nil             reduce using rule 89 (fieldsep -> COMMA .)
    false           reduce using rule 89 (fieldsep -> COMMA .)
    true            reduce using rule 89 (fieldsep -> COMMA .)
    STRING          reduce using rule 89 (fieldsep -> COMMA .)
    TRPLDOTS        reduce using rule 89 (fieldsep -> COMMA .)
    function        reduce using rule 89 (fieldsep -> COMMA .)
    INTEGER         reduce using rule 89 (fieldsep -> COMMA .)
    FLOAT           reduce using rule 89 (fieldsep -> COMMA .)
    HEX             reduce using rule 89 (fieldsep -> COMMA .)
    LPAREN          reduce using rule 89 (fieldsep -> COMMA .)
    MINUS           reduce using rule 89 (fieldsep -> COMMA .)
    not             reduce using rule 89 (fieldsep -> COMMA .)
    HASH            reduce using rule 89 (fieldsep -> COMMA .)
    LCURLY          reduce using rule 89 (fieldsep -> COMMA .)
    RCURLY          reduce using rule 89 (fieldsep -> COMMA .)


state 146

    (90) fieldsep -> SEMI .

    LSQUARE         reduce using rule 90 (fieldsep -> SEMI .)
    ID              reduce using rule 90 (fieldsep -> SEMI .)
    RESID           reduce using rule 90 (fieldsep -> SEMI .)
    nil             reduce using rule 90 (fieldsep -> SEMI .)
    false           reduce using rule 90 (fieldsep -> SEMI .)
    true            reduce using rule 90 (fieldsep -> SEMI .)
    STRING          reduce using rule 90 (fieldsep -> SEMI .)
    TRPLDOTS        reduce using rule 90 (fieldsep -> SEMI .)
    function        reduce using rule 90 (fieldsep -> SEMI .)
    INTEGER         reduce using rule 90 (fieldsep -> SEMI .)
    FLOAT           reduce using rule 90 (fieldsep -> SEMI .)
    HEX             reduce using rule 90 (fieldsep -> SEMI .)
    LPAREN          reduce using rule 90 (fieldsep -> SEMI .)
    MINUS           reduce using rule 90 (fieldsep -> SEMI .)
    not             reduce using rule 90 (fieldsep -> SEMI .)
    HASH            reduce using rule 90 (fieldsep -> SEMI .)
    LCURLY          reduce using rule 90 (fieldsep -> SEMI .)
    RCURLY          reduce using rule 90 (fieldsep -> SEMI .)


state 147

    (86) field -> LSQUARE exp RSQUARE . EQUALS exp

    EQUALS          shift and go to state 161


state 148

    (38) ifblock -> empty .

    else            reduce using rule 38 (ifblock -> empty .)
    end             reduce using rule 38 (ifblock -> empty .)
    elseif          reduce using rule 38 (ifblock -> empty .)


state 149

    (11) stat -> if exp then block ifblock . else block end
    (12) stat -> if exp then block ifblock . end
    (37) ifblock -> ifblock . elseif exp then block

    else            shift and go to state 163
    end             shift and go to state 162
    elseif          shift and go to state 164


state 150

    (15) stat -> for namelist in explist do . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 165

state 151

    (13) stat -> for names EQUALS exp COMMA . exp do block end
    (14) stat -> for names EQUALS exp COMMA . exp COMMA exp do block end
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    names                          shift and go to state 5
    exp                            shift and go to state 166
    var                            shift and go to state 26

state 152

    (35) comid -> COMMA names comid .

    in              reduce using rule 35 (comid -> COMMA names comid .)
    EQUALS          reduce using rule 35 (comid -> COMMA names comid .)
    SEMI            reduce using rule 35 (comid -> COMMA names comid .)
    return          reduce using rule 35 (comid -> COMMA names comid .)
    break           reduce using rule 35 (comid -> COMMA names comid .)
    do              reduce using rule 35 (comid -> COMMA names comid .)
    while           reduce using rule 35 (comid -> COMMA names comid .)
    repeat          reduce using rule 35 (comid -> COMMA names comid .)
    if              reduce using rule 35 (comid -> COMMA names comid .)
    for             reduce using rule 35 (comid -> COMMA names comid .)
    local           reduce using rule 35 (comid -> COMMA names comid .)
    function        reduce using rule 35 (comid -> COMMA names comid .)
    ID              reduce using rule 35 (comid -> COMMA names comid .)
    RESID           reduce using rule 35 (comid -> COMMA names comid .)
    LPAREN          reduce using rule 35 (comid -> COMMA names comid .)
    $end            reduce using rule 35 (comid -> COMMA names comid .)
    end             reduce using rule 35 (comid -> COMMA names comid .)
    until           reduce using rule 35 (comid -> COMMA names comid .)
    else            reduce using rule 35 (comid -> COMMA names comid .)
    elseif          reduce using rule 35 (comid -> COMMA names comid .)
    COMMA           reduce using rule 35 (comid -> COMMA names comid .)
    RPAREN          reduce using rule 35 (comid -> COMMA names comid .)


state 153

    (44) explist -> explist COMMA exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    do              reduce using rule 44 (explist -> explist COMMA exp .)
    COMMA           reduce using rule 44 (explist -> explist COMMA exp .)
    while           reduce using rule 44 (explist -> explist COMMA exp .)
    repeat          reduce using rule 44 (explist -> explist COMMA exp .)
    if              reduce using rule 44 (explist -> explist COMMA exp .)
    for             reduce using rule 44 (explist -> explist COMMA exp .)
    local           reduce using rule 44 (explist -> explist COMMA exp .)
    function        reduce using rule 44 (explist -> explist COMMA exp .)
    ID              reduce using rule 44 (explist -> explist COMMA exp .)
    RESID           reduce using rule 44 (explist -> explist COMMA exp .)
    LPAREN          reduce using rule 44 (explist -> explist COMMA exp .)
    $end            reduce using rule 44 (explist -> explist COMMA exp .)
    end             reduce using rule 44 (explist -> explist COMMA exp .)
    until           reduce using rule 44 (explist -> explist COMMA exp .)
    else            reduce using rule 44 (explist -> explist COMMA exp .)
    elseif          reduce using rule 44 (explist -> explist COMMA exp .)
    SEMI            reduce using rule 44 (explist -> explist COMMA exp .)
    return          reduce using rule 44 (explist -> explist COMMA exp .)
    break           reduce using rule 44 (explist -> explist COMMA exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 154

    (25) comtrp -> COMMA . TRPLDOTS

    TRPLDOTS        shift and go to state 167


state 155

    (23) parlist -> namelist comtrp .

    RPAREN          reduce using rule 23 (parlist -> namelist comtrp .)


state 156

    (21) funcbody -> LPAREN parlist RPAREN . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 168

state 157

    (20) funcbody -> LPAREN RPAREN block . end

    end             shift and go to state 169


state 158

    (31) dotid -> SDOT names dotid .

    COLON           reduce using rule 31 (dotid -> SDOT names dotid .)
    LPAREN          reduce using rule 31 (dotid -> SDOT names dotid .)


state 159

    (9) stat -> while exp do block end .

    SEMI            reduce using rule 9 (stat -> while exp do block end .)
    return          reduce using rule 9 (stat -> while exp do block end .)
    break           reduce using rule 9 (stat -> while exp do block end .)
    do              reduce using rule 9 (stat -> while exp do block end .)
    while           reduce using rule 9 (stat -> while exp do block end .)
    repeat          reduce using rule 9 (stat -> while exp do block end .)
    if              reduce using rule 9 (stat -> while exp do block end .)
    for             reduce using rule 9 (stat -> while exp do block end .)
    local           reduce using rule 9 (stat -> while exp do block end .)
    function        reduce using rule 9 (stat -> while exp do block end .)
    ID              reduce using rule 9 (stat -> while exp do block end .)
    RESID           reduce using rule 9 (stat -> while exp do block end .)
    LPAREN          reduce using rule 9 (stat -> while exp do block end .)
    end             reduce using rule 9 (stat -> while exp do block end .)
    until           reduce using rule 9 (stat -> while exp do block end .)
    else            reduce using rule 9 (stat -> while exp do block end .)
    elseif          reduce using rule 9 (stat -> while exp do block end .)
    $end            reduce using rule 9 (stat -> while exp do block end .)


state 160

    (84) fieldseplist -> fieldseplist fieldsep field .

    COMMA           reduce using rule 84 (fieldseplist -> fieldseplist fieldsep field .)
    SEMI            reduce using rule 84 (fieldseplist -> fieldseplist fieldsep field .)
    RCURLY          reduce using rule 84 (fieldseplist -> fieldseplist fieldsep field .)


state 161

    (86) field -> LSQUARE exp RSQUARE EQUALS . exp
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 170
    var                            shift and go to state 26
    names                          shift and go to state 5

state 162

    (12) stat -> if exp then block ifblock end .

    SEMI            reduce using rule 12 (stat -> if exp then block ifblock end .)
    return          reduce using rule 12 (stat -> if exp then block ifblock end .)
    break           reduce using rule 12 (stat -> if exp then block ifblock end .)
    do              reduce using rule 12 (stat -> if exp then block ifblock end .)
    while           reduce using rule 12 (stat -> if exp then block ifblock end .)
    repeat          reduce using rule 12 (stat -> if exp then block ifblock end .)
    if              reduce using rule 12 (stat -> if exp then block ifblock end .)
    for             reduce using rule 12 (stat -> if exp then block ifblock end .)
    local           reduce using rule 12 (stat -> if exp then block ifblock end .)
    function        reduce using rule 12 (stat -> if exp then block ifblock end .)
    ID              reduce using rule 12 (stat -> if exp then block ifblock end .)
    RESID           reduce using rule 12 (stat -> if exp then block ifblock end .)
    LPAREN          reduce using rule 12 (stat -> if exp then block ifblock end .)
    end             reduce using rule 12 (stat -> if exp then block ifblock end .)
    until           reduce using rule 12 (stat -> if exp then block ifblock end .)
    else            reduce using rule 12 (stat -> if exp then block ifblock end .)
    elseif          reduce using rule 12 (stat -> if exp then block ifblock end .)
    $end            reduce using rule 12 (stat -> if exp then block ifblock end .)


state 163

    (11) stat -> if exp then block ifblock else . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 171

state 164

    (37) ifblock -> ifblock elseif . exp then block
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    exp                            shift and go to state 172
    var                            shift and go to state 26
    names                          shift and go to state 5

state 165

    (15) stat -> for namelist in explist do block . end

    end             shift and go to state 173


state 166

    (13) stat -> for names EQUALS exp COMMA exp . do block end
    (14) stat -> for names EQUALS exp COMMA exp . COMMA exp do block end
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    do              shift and go to state 175
    COMMA           shift and go to state 174
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 167

    (25) comtrp -> COMMA TRPLDOTS .

    RPAREN          reduce using rule 25 (comtrp -> COMMA TRPLDOTS .)


state 168

    (21) funcbody -> LPAREN parlist RPAREN block . end

    end             shift and go to state 176


state 169

    (20) funcbody -> LPAREN RPAREN block end .

    SEMI            reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    return          reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    break           reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    do              reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    while           reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    repeat          reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    if              reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    for             reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    local           reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    function        reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    ID              reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    RESID           reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    LPAREN          reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    $end            reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    end             reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    until           reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    else            reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    elseif          reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)


state 170

    (86) field -> LSQUARE exp RSQUARE EQUALS exp .
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 86 (field -> LSQUARE exp RSQUARE EQUALS exp .)
    SEMI            reduce using rule 86 (field -> LSQUARE exp RSQUARE EQUALS exp .)
    RCURLY          reduce using rule 86 (field -> LSQUARE exp RSQUARE EQUALS exp .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 171

    (11) stat -> if exp then block ifblock else block . end

    end             shift and go to state 177


state 172

    (37) ifblock -> ifblock elseif exp . then block
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    then            shift and go to state 178
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 173

    (15) stat -> for namelist in explist do block end .

    SEMI            reduce using rule 15 (stat -> for namelist in explist do block end .)
    return          reduce using rule 15 (stat -> for namelist in explist do block end .)
    break           reduce using rule 15 (stat -> for namelist in explist do block end .)
    do              reduce using rule 15 (stat -> for namelist in explist do block end .)
    while           reduce using rule 15 (stat -> for namelist in explist do block end .)
    repeat          reduce using rule 15 (stat -> for namelist in explist do block end .)
    if              reduce using rule 15 (stat -> for namelist in explist do block end .)
    for             reduce using rule 15 (stat -> for namelist in explist do block end .)
    local           reduce using rule 15 (stat -> for namelist in explist do block end .)
    function        reduce using rule 15 (stat -> for namelist in explist do block end .)
    ID              reduce using rule 15 (stat -> for namelist in explist do block end .)
    RESID           reduce using rule 15 (stat -> for namelist in explist do block end .)
    LPAREN          reduce using rule 15 (stat -> for namelist in explist do block end .)
    end             reduce using rule 15 (stat -> for namelist in explist do block end .)
    until           reduce using rule 15 (stat -> for namelist in explist do block end .)
    else            reduce using rule 15 (stat -> for namelist in explist do block end .)
    elseif          reduce using rule 15 (stat -> for namelist in explist do block end .)
    $end            reduce using rule 15 (stat -> for namelist in explist do block end .)


state 174

    (14) stat -> for names EQUALS exp COMMA exp COMMA . exp do block end
    (46) exp -> . nil
    (47) exp -> . false
    (48) exp -> . true
    (49) exp -> . Number
    (50) exp -> . STRING
    (51) exp -> . TRPLDOTS
    (52) exp -> . function
    (53) exp -> . prefixexp
    (54) exp -> . exp PLUS exp
    (55) exp -> . exp MINUS exp
    (56) exp -> . exp TIMES exp
    (57) exp -> . exp DIVIDE exp
    (58) exp -> . exp POWER exp
    (59) exp -> . exp LT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GT exp
    (62) exp -> . exp GE exp
    (63) exp -> . exp NE exp
    (64) exp -> . exp CHECKEQ exp
    (65) exp -> . exp and exp
    (66) exp -> . exp or exp
    (67) exp -> . exp MODULO exp
    (68) exp -> . exp DBLDOTS exp
    (69) exp -> . unop exp
    (70) exp -> . tableconstructor
    (71) Number -> . INTEGER
    (72) Number -> . FLOAT
    (73) Number -> . HEX
    (75) prefixexp -> . var
    (76) prefixexp -> . LPAREN exp RPAREN
    (77) unop -> . MINUS
    (78) unop -> . not
    (79) unop -> . HASH
    (80) tableconstructor -> . LCURLY fieldlist RCURLY
    (81) tableconstructor -> . LCURLY RCURLY
    (40) var -> . names
    (41) var -> . prefixexp LSQUARE exp RSQUARE
    (42) var -> . prefixexp SDOT names
    (91) names -> . ID
    (92) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 36
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 25
    unop                           shift and go to state 18
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    names                          shift and go to state 5
    exp                            shift and go to state 179
    var                            shift and go to state 26

state 175

    (13) stat -> for names EQUALS exp COMMA exp do . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 180

state 176

    (21) funcbody -> LPAREN parlist RPAREN block end .

    SEMI            reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    return          reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    break           reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    do              reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    while           reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    repeat          reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    if              reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    for             reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    local           reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    function        reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    ID              reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    RESID           reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    LPAREN          reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    $end            reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    end             reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    until           reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    else            reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    elseif          reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)


state 177

    (11) stat -> if exp then block ifblock else block end .

    SEMI            reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    return          reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    break           reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    do              reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    while           reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    repeat          reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    if              reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    for             reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    local           reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    function        reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    ID              reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    RESID           reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    LPAREN          reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    end             reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    until           reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    else            reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    elseif          reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    $end            reduce using rule 11 (stat -> if exp then block ifblock else block end .)


state 178

    (37) ifblock -> ifblock elseif exp then . block
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    else            reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)
    elseif          reduce using rule 74 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 181

state 179

    (14) stat -> for names EQUALS exp COMMA exp COMMA exp . do block end
    (54) exp -> exp . PLUS exp
    (55) exp -> exp . MINUS exp
    (56) exp -> exp . TIMES exp
    (57) exp -> exp . DIVIDE exp
    (58) exp -> exp . POWER exp
    (59) exp -> exp . LT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GT exp
    (62) exp -> exp . GE exp
    (63) exp -> exp . NE exp
    (64) exp -> exp . CHECKEQ exp
    (65) exp -> exp . and exp
    (66) exp -> exp . or exp
    (67) exp -> exp . MODULO exp
    (68) exp -> exp . DBLDOTS exp

    do              shift and go to state 182
    PLUS            shift and go to state 76
    MINUS           shift and go to state 79
    TIMES           shift and go to state 72
    DIVIDE          shift and go to state 81
    POWER           shift and go to state 69
    LT              shift and go to state 74
    LE              shift and go to state 67
    GT              shift and go to state 75
    GE              shift and go to state 71
    NE              shift and go to state 80
    CHECKEQ         shift and go to state 73
    and             shift and go to state 66
    or              shift and go to state 70
    MODULO          shift and go to state 77
    DBLDOTS         shift and go to state 78


state 180

    (13) stat -> for names EQUALS exp COMMA exp do block . end

    end             shift and go to state 183


state 181

    (37) ifblock -> ifblock elseif exp then block .

    else            reduce using rule 37 (ifblock -> ifblock elseif exp then block .)
    end             reduce using rule 37 (ifblock -> ifblock elseif exp then block .)
    elseif          reduce using rule 37 (ifblock -> ifblock elseif exp then block .)


state 182

    (14) stat -> for names EQUALS exp COMMA exp COMMA exp do . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (74) empty -> .

    do              reduce using rule 74 (empty -> .)
    while           reduce using rule 74 (empty -> .)
    repeat          reduce using rule 74 (empty -> .)
    if              reduce using rule 74 (empty -> .)
    for             reduce using rule 74 (empty -> .)
    local           reduce using rule 74 (empty -> .)
    function        reduce using rule 74 (empty -> .)
    ID              reduce using rule 74 (empty -> .)
    RESID           reduce using rule 74 (empty -> .)
    LPAREN          reduce using rule 74 (empty -> .)
    end             reduce using rule 74 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 184

state 183

    (13) stat -> for names EQUALS exp COMMA exp do block end .

    SEMI            reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    return          reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    break           reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    do              reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    while           reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    repeat          reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    if              reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    for             reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    local           reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    function        reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    ID              reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    RESID           reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    LPAREN          reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    end             reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    until           reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    else            reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    elseif          reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    $end            reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)


state 184

    (14) stat -> for names EQUALS exp COMMA exp COMMA exp do block . end

    end             shift and go to state 185


state 185

    (14) stat -> for names EQUALS exp COMMA exp COMMA exp do block end .

    SEMI            reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    return          reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    break           reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    do              reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    while           reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    repeat          reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    if              reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    for             reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    local           reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    function        reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    ID              reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    RESID           reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    LPAREN          reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    end             reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    until           reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    else            reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    elseif          reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    $end            reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for function in state 53 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 53 resolved as shift
WARNING: shift/reduce conflict for ID in state 53 resolved as shift
WARNING: shift/reduce conflict for RESID in state 53 resolved as shift
