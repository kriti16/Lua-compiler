Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    NEWLINE
    TDASH

Grammar

Rule 0     S' -> chunk
Rule 1     chunk -> chunk stat
Rule 2     chunk -> chunk stat SEMI
Rule 3     chunk -> chunk stat laststat
Rule 4     chunk -> chunk stat SEMI laststat SEMI
Rule 5     chunk -> empty
Rule 6     block -> chunk
Rule 7     stat -> varlist EQUALS explist
Rule 8     stat -> do block end
Rule 9     stat -> while exp do block end
Rule 10    stat -> repeat block until exp
Rule 11    stat -> if exp then block ifblock else block end
Rule 12    stat -> if exp then block ifblock end
Rule 13    stat -> for names EQUALS exp COMMA exp do block end
Rule 14    stat -> for names EQUALS exp COMMA exp COMMA exp do block end
Rule 15    stat -> for namelist in explist do block end
Rule 16    stat -> local namelist
Rule 17    stat -> local namelist EQUALS explist
Rule 18    stat -> function funcname funcbody
Rule 19    stat -> local function names funcbody
Rule 20    funcbody -> LPAREN RPAREN block end
Rule 21    funcbody -> LPAREN parlist RPAREN block end
Rule 22    parlist -> namelist
Rule 23    parlist -> namelist COMMA TRPLDOTS
Rule 24    parlist -> TRPLDOTS
Rule 25    laststat -> return explist
Rule 26    laststat -> return
Rule 27    laststat -> break
Rule 28    funcname -> names dotid COLON
Rule 29    funcname -> names dotid
Rule 30    dotid -> SDOT names dotid
Rule 31    dotid -> empty
Rule 32    comvar -> COMMA var comvar
Rule 33    comvar -> empty
Rule 34    comid -> COMMA names comid
Rule 35    comid -> empty
Rule 36    comexp -> COMMA exp comexp
Rule 37    comexp -> empty
Rule 38    ifblock -> ifblock elseif exp then block
Rule 39    ifblock -> empty
Rule 40    varlist -> var comvar
Rule 41    var -> names
Rule 42    var -> prefixexp
Rule 43    var -> prefixexp LSQUARE exp RSQUARE
Rule 44    var -> prefixexp SDOT names
Rule 45    namelist -> names comid
Rule 46    explist -> comexp exp
Rule 47    exp -> nil
Rule 48    exp -> false
Rule 49    exp -> true
Rule 50    exp -> Number
Rule 51    exp -> STRING
Rule 52    exp -> TRPLDOTS
Rule 53    exp -> function
Rule 54    exp -> prefixexp
Rule 55    exp -> exp binop exp
Rule 56    exp -> unop exp
Rule 57    exp -> tableconstructor
Rule 58    Number -> INTEGER
Rule 59    Number -> FLOAT
Rule 60    Number -> HEX
Rule 61    empty -> <empty>
Rule 62    prefixexp -> var
Rule 63    prefixexp -> LPAREN exp RPAREN
Rule 64    binop -> PLUS
Rule 65    binop -> MINUS
Rule 66    binop -> TIMES
Rule 67    binop -> DIVIDE
Rule 68    binop -> POWER
Rule 69    binop -> LT
Rule 70    binop -> LE
Rule 71    binop -> GT
Rule 72    binop -> GE
Rule 73    binop -> NE
Rule 74    binop -> CHECKEQ
Rule 75    binop -> and
Rule 76    binop -> or
Rule 77    binop -> MODULO
Rule 78    binop -> DBLDOTS
Rule 79    unop -> MINUS
Rule 80    unop -> not
Rule 81    unop -> HASH
Rule 82    tableconstructor -> LCURLY fieldlist RCURLY
Rule 83    tableconstructor -> LCURLY RCURLY
Rule 84    fieldlist -> field fieldseplist fieldsep
Rule 85    fieldlist -> field fieldseplist fieldsep fieldsep
Rule 86    fieldseplist -> fieldsep field fieldseplist
Rule 87    fieldseplist -> empty
Rule 88    field -> LSQUARE exp RSQUARE EQUALS exp
Rule 89    field -> names EQUALS exp
Rule 90    field -> exp
Rule 91    fieldsep -> COMMA
Rule 92    fieldsep -> SEMI
Rule 93    names -> ID
Rule 94    names -> RESID

Terminals, with rules where they appear

CHECKEQ              : 74
COLON                : 28
COMMA                : 13 14 14 23 32 34 36 91
DBLDOTS              : 78
DIVIDE               : 67
EQUALS               : 7 13 14 17 88 89
FLOAT                : 59
GE                   : 72
GT                   : 71
HASH                 : 81
HEX                  : 60
ID                   : 93
INTEGER              : 58
LCURLY               : 82 83
LE                   : 70
LPAREN               : 20 21 63
LSQUARE              : 43 88
LT                   : 69
MINUS                : 65 79
MODULO               : 77
NE                   : 73
NEWLINE              : 
PLUS                 : 64
POWER                : 68
RCURLY               : 82 83
RESID                : 94
RPAREN               : 20 21 63
RSQUARE              : 43 88
SDOT                 : 30 44
SEMI                 : 2 4 4 92
STRING               : 51
TDASH                : 
TIMES                : 66
TRPLDOTS             : 23 24 52
and                  : 75
break                : 27
do                   : 8 9 13 14 15
else                 : 11
elseif               : 38
end                  : 8 9 11 12 13 14 15 20 21
error                : 
false                : 48
for                  : 13 14 15
function             : 18 19 53
if                   : 11 12
in                   : 15
local                : 16 17 19
nil                  : 47
not                  : 80
or                   : 76
repeat               : 10
return               : 25 26
then                 : 11 12 38
true                 : 49
until                : 10
while                : 9

Nonterminals, with rules where they appear

Number               : 50
binop                : 55
block                : 8 9 10 11 11 12 13 14 15 20 21 38
chunk                : 1 2 3 4 6 0
comexp               : 36 46
comid                : 34 45
comvar               : 32 40
dotid                : 28 29 30
empty                : 5 31 33 35 37 39 87
exp                  : 9 10 11 12 13 13 14 14 14 36 38 43 46 55 55 56 63 88 88 89 90
explist              : 7 15 17 25
field                : 84 85 86
fieldlist            : 82
fieldsep             : 84 85 85 86
fieldseplist         : 84 85 86
funcbody             : 18 19
funcname             : 18
ifblock              : 11 12 38
laststat             : 3 4
namelist             : 15 16 17 22 23
names                : 13 14 19 28 29 30 34 41 44 45 89
parlist              : 21
prefixexp            : 42 43 44 54
stat                 : 1 2 3 4
tableconstructor     : 57
unop                 : 56
var                  : 32 40 62
varlist              : 7

Parsing method: LALR

state 0

    (0) S' -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    $end            reduce using rule 61 (empty -> .)

    chunk                          shift and go to state 2
    empty                          shift and go to state 1

state 1

    (5) chunk -> empty .

    do              reduce using rule 5 (chunk -> empty .)
    while           reduce using rule 5 (chunk -> empty .)
    repeat          reduce using rule 5 (chunk -> empty .)
    if              reduce using rule 5 (chunk -> empty .)
    for             reduce using rule 5 (chunk -> empty .)
    local           reduce using rule 5 (chunk -> empty .)
    function        reduce using rule 5 (chunk -> empty .)
    ID              reduce using rule 5 (chunk -> empty .)
    RESID           reduce using rule 5 (chunk -> empty .)
    LPAREN          reduce using rule 5 (chunk -> empty .)
    end             reduce using rule 5 (chunk -> empty .)
    $end            reduce using rule 5 (chunk -> empty .)
    else            reduce using rule 5 (chunk -> empty .)
    elseif          reduce using rule 5 (chunk -> empty .)
    until           reduce using rule 5 (chunk -> empty .)


state 2

    (0) S' -> chunk .
    (1) chunk -> chunk . stat
    (2) chunk -> chunk . stat SEMI
    (3) chunk -> chunk . stat laststat
    (4) chunk -> chunk . stat SEMI laststat SEMI
    (7) stat -> . varlist EQUALS explist
    (8) stat -> . do block end
    (9) stat -> . while exp do block end
    (10) stat -> . repeat block until exp
    (11) stat -> . if exp then block ifblock else block end
    (12) stat -> . if exp then block ifblock end
    (13) stat -> . for names EQUALS exp COMMA exp do block end
    (14) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (15) stat -> . for namelist in explist do block end
    (16) stat -> . local namelist
    (17) stat -> . local namelist EQUALS explist
    (18) stat -> . function funcname funcbody
    (19) stat -> . local function names funcbody
    (40) varlist -> . var comvar
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN

    do              shift and go to state 13
    while           shift and go to state 17
    repeat          shift and go to state 15
    if              shift and go to state 6
    for             shift and go to state 8
    local           shift and go to state 11
    function        shift and go to state 12
    ID              shift and go to state 16
    RESID           shift and go to state 3
    LPAREN          shift and go to state 4

    prefixexp                      shift and go to state 7
    stat                           shift and go to state 14
    varlist                        shift and go to state 9
    names                          shift and go to state 5
    var                            shift and go to state 10

state 3

    (94) names -> RESID .

    LSQUARE         reduce using rule 94 (names -> RESID .)
    SDOT            reduce using rule 94 (names -> RESID .)
    PLUS            reduce using rule 94 (names -> RESID .)
    MINUS           reduce using rule 94 (names -> RESID .)
    TIMES           reduce using rule 94 (names -> RESID .)
    DIVIDE          reduce using rule 94 (names -> RESID .)
    POWER           reduce using rule 94 (names -> RESID .)
    LT              reduce using rule 94 (names -> RESID .)
    LE              reduce using rule 94 (names -> RESID .)
    GT              reduce using rule 94 (names -> RESID .)
    GE              reduce using rule 94 (names -> RESID .)
    NE              reduce using rule 94 (names -> RESID .)
    CHECKEQ         reduce using rule 94 (names -> RESID .)
    and             reduce using rule 94 (names -> RESID .)
    or              reduce using rule 94 (names -> RESID .)
    MODULO          reduce using rule 94 (names -> RESID .)
    DBLDOTS         reduce using rule 94 (names -> RESID .)
    COMMA           reduce using rule 94 (names -> RESID .)
    SEMI            reduce using rule 94 (names -> RESID .)
    RPAREN          reduce using rule 94 (names -> RESID .)
    then            reduce using rule 94 (names -> RESID .)
    do              reduce using rule 94 (names -> RESID .)
    RSQUARE         reduce using rule 94 (names -> RESID .)
    return          reduce using rule 94 (names -> RESID .)
    break           reduce using rule 94 (names -> RESID .)
    while           reduce using rule 94 (names -> RESID .)
    repeat          reduce using rule 94 (names -> RESID .)
    if              reduce using rule 94 (names -> RESID .)
    for             reduce using rule 94 (names -> RESID .)
    local           reduce using rule 94 (names -> RESID .)
    function        reduce using rule 94 (names -> RESID .)
    ID              reduce using rule 94 (names -> RESID .)
    RESID           reduce using rule 94 (names -> RESID .)
    LPAREN          reduce using rule 94 (names -> RESID .)
    $end            reduce using rule 94 (names -> RESID .)
    end             reduce using rule 94 (names -> RESID .)
    until           reduce using rule 94 (names -> RESID .)
    else            reduce using rule 94 (names -> RESID .)
    elseif          reduce using rule 94 (names -> RESID .)
    nil             reduce using rule 94 (names -> RESID .)
    false           reduce using rule 94 (names -> RESID .)
    true            reduce using rule 94 (names -> RESID .)
    STRING          reduce using rule 94 (names -> RESID .)
    TRPLDOTS        reduce using rule 94 (names -> RESID .)
    INTEGER         reduce using rule 94 (names -> RESID .)
    FLOAT           reduce using rule 94 (names -> RESID .)
    HEX             reduce using rule 94 (names -> RESID .)
    not             reduce using rule 94 (names -> RESID .)
    HASH            reduce using rule 94 (names -> RESID .)
    LCURLY          reduce using rule 94 (names -> RESID .)
    EQUALS          reduce using rule 94 (names -> RESID .)
    COLON           reduce using rule 94 (names -> RESID .)
    in              reduce using rule 94 (names -> RESID .)


state 4

    (63) prefixexp -> LPAREN . exp RPAREN
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 36
    var                            shift and go to state 25
    names                          shift and go to state 5

state 5

    (41) var -> names .

    LSQUARE         reduce using rule 41 (var -> names .)
    SDOT            reduce using rule 41 (var -> names .)
    do              reduce using rule 41 (var -> names .)
    PLUS            reduce using rule 41 (var -> names .)
    MINUS           reduce using rule 41 (var -> names .)
    TIMES           reduce using rule 41 (var -> names .)
    DIVIDE          reduce using rule 41 (var -> names .)
    POWER           reduce using rule 41 (var -> names .)
    LT              reduce using rule 41 (var -> names .)
    LE              reduce using rule 41 (var -> names .)
    GT              reduce using rule 41 (var -> names .)
    GE              reduce using rule 41 (var -> names .)
    NE              reduce using rule 41 (var -> names .)
    CHECKEQ         reduce using rule 41 (var -> names .)
    and             reduce using rule 41 (var -> names .)
    or              reduce using rule 41 (var -> names .)
    MODULO          reduce using rule 41 (var -> names .)
    DBLDOTS         reduce using rule 41 (var -> names .)
    COMMA           reduce using rule 41 (var -> names .)
    EQUALS          reduce using rule 41 (var -> names .)
    nil             reduce using rule 41 (var -> names .)
    false           reduce using rule 41 (var -> names .)
    true            reduce using rule 41 (var -> names .)
    STRING          reduce using rule 41 (var -> names .)
    TRPLDOTS        reduce using rule 41 (var -> names .)
    function        reduce using rule 41 (var -> names .)
    INTEGER         reduce using rule 41 (var -> names .)
    FLOAT           reduce using rule 41 (var -> names .)
    HEX             reduce using rule 41 (var -> names .)
    LPAREN          reduce using rule 41 (var -> names .)
    not             reduce using rule 41 (var -> names .)
    HASH            reduce using rule 41 (var -> names .)
    LCURLY          reduce using rule 41 (var -> names .)
    ID              reduce using rule 41 (var -> names .)
    RESID           reduce using rule 41 (var -> names .)
    RPAREN          reduce using rule 41 (var -> names .)
    SEMI            reduce using rule 41 (var -> names .)
    then            reduce using rule 41 (var -> names .)
    RSQUARE         reduce using rule 41 (var -> names .)
    return          reduce using rule 41 (var -> names .)
    break           reduce using rule 41 (var -> names .)
    while           reduce using rule 41 (var -> names .)
    repeat          reduce using rule 41 (var -> names .)
    if              reduce using rule 41 (var -> names .)
    for             reduce using rule 41 (var -> names .)
    local           reduce using rule 41 (var -> names .)
    $end            reduce using rule 41 (var -> names .)
    end             reduce using rule 41 (var -> names .)
    until           reduce using rule 41 (var -> names .)
    else            reduce using rule 41 (var -> names .)
    elseif          reduce using rule 41 (var -> names .)


state 6

    (11) stat -> if . exp then block ifblock else block end
    (12) stat -> if . exp then block ifblock end
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 37
    var                            shift and go to state 25
    names                          shift and go to state 5

state 7

    (42) var -> prefixexp .
    (43) var -> prefixexp . LSQUARE exp RSQUARE
    (44) var -> prefixexp . SDOT names

  ! shift/reduce conflict for LSQUARE resolved as shift
  ! shift/reduce conflict for SDOT resolved as shift
    COMMA           reduce using rule 42 (var -> prefixexp .)
    EQUALS          reduce using rule 42 (var -> prefixexp .)
    LSQUARE         shift and go to state 38
    SDOT            shift and go to state 39

  ! LSQUARE         [ reduce using rule 42 (var -> prefixexp .) ]
  ! SDOT            [ reduce using rule 42 (var -> prefixexp .) ]


state 8

    (13) stat -> for . names EQUALS exp COMMA exp do block end
    (14) stat -> for . names EQUALS exp COMMA exp COMMA exp do block end
    (15) stat -> for . namelist in explist do block end
    (93) names -> . ID
    (94) names -> . RESID
    (45) namelist -> . names comid

    ID              shift and go to state 16
    RESID           shift and go to state 3

    namelist                       shift and go to state 40
    names                          shift and go to state 41

state 9

    (7) stat -> varlist . EQUALS explist

    EQUALS          shift and go to state 42


state 10

    (40) varlist -> var . comvar
    (62) prefixexp -> var .
    (32) comvar -> . COMMA var comvar
    (33) comvar -> . empty
    (61) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
  ! reduce/reduce conflict for EQUALS resolved using rule 61 (empty -> .)
    LSQUARE         reduce using rule 62 (prefixexp -> var .)
    SDOT            reduce using rule 62 (prefixexp -> var .)
    COMMA           shift and go to state 43
    EQUALS          reduce using rule 61 (empty -> .)

  ! COMMA           [ reduce using rule 62 (prefixexp -> var .) ]
  ! EQUALS          [ reduce using rule 62 (prefixexp -> var .) ]

    comvar                         shift and go to state 44
    empty                          shift and go to state 45

state 11

    (16) stat -> local . namelist
    (17) stat -> local . namelist EQUALS explist
    (19) stat -> local . function names funcbody
    (45) namelist -> . names comid
    (93) names -> . ID
    (94) names -> . RESID

    function        shift and go to state 46
    ID              shift and go to state 16
    RESID           shift and go to state 3

    namelist                       shift and go to state 47
    names                          shift and go to state 48

state 12

    (18) stat -> function . funcname funcbody
    (28) funcname -> . names dotid COLON
    (29) funcname -> . names dotid
    (93) names -> . ID
    (94) names -> . RESID

    ID              shift and go to state 16
    RESID           shift and go to state 3

    names                          shift and go to state 50
    funcname                       shift and go to state 49

state 13

    (8) stat -> do . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)

    empty                          shift and go to state 1
    chunk                          shift and go to state 51
    block                          shift and go to state 52

state 14

    (1) chunk -> chunk stat .
    (2) chunk -> chunk stat . SEMI
    (3) chunk -> chunk stat . laststat
    (4) chunk -> chunk stat . SEMI laststat SEMI
    (25) laststat -> . return explist
    (26) laststat -> . return
    (27) laststat -> . break

    do              reduce using rule 1 (chunk -> chunk stat .)
    while           reduce using rule 1 (chunk -> chunk stat .)
    repeat          reduce using rule 1 (chunk -> chunk stat .)
    if              reduce using rule 1 (chunk -> chunk stat .)
    for             reduce using rule 1 (chunk -> chunk stat .)
    local           reduce using rule 1 (chunk -> chunk stat .)
    function        reduce using rule 1 (chunk -> chunk stat .)
    ID              reduce using rule 1 (chunk -> chunk stat .)
    RESID           reduce using rule 1 (chunk -> chunk stat .)
    LPAREN          reduce using rule 1 (chunk -> chunk stat .)
    end             reduce using rule 1 (chunk -> chunk stat .)
    $end            reduce using rule 1 (chunk -> chunk stat .)
    else            reduce using rule 1 (chunk -> chunk stat .)
    elseif          reduce using rule 1 (chunk -> chunk stat .)
    until           reduce using rule 1 (chunk -> chunk stat .)
    SEMI            shift and go to state 54
    return          shift and go to state 53
    break           shift and go to state 56

    laststat                       shift and go to state 55

state 15

    (10) stat -> repeat . block until exp
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    until           reduce using rule 61 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 57

state 16

    (93) names -> ID .

    LSQUARE         reduce using rule 93 (names -> ID .)
    SDOT            reduce using rule 93 (names -> ID .)
    PLUS            reduce using rule 93 (names -> ID .)
    MINUS           reduce using rule 93 (names -> ID .)
    TIMES           reduce using rule 93 (names -> ID .)
    DIVIDE          reduce using rule 93 (names -> ID .)
    POWER           reduce using rule 93 (names -> ID .)
    LT              reduce using rule 93 (names -> ID .)
    LE              reduce using rule 93 (names -> ID .)
    GT              reduce using rule 93 (names -> ID .)
    GE              reduce using rule 93 (names -> ID .)
    NE              reduce using rule 93 (names -> ID .)
    CHECKEQ         reduce using rule 93 (names -> ID .)
    and             reduce using rule 93 (names -> ID .)
    or              reduce using rule 93 (names -> ID .)
    MODULO          reduce using rule 93 (names -> ID .)
    DBLDOTS         reduce using rule 93 (names -> ID .)
    COMMA           reduce using rule 93 (names -> ID .)
    SEMI            reduce using rule 93 (names -> ID .)
    RPAREN          reduce using rule 93 (names -> ID .)
    then            reduce using rule 93 (names -> ID .)
    do              reduce using rule 93 (names -> ID .)
    RSQUARE         reduce using rule 93 (names -> ID .)
    return          reduce using rule 93 (names -> ID .)
    break           reduce using rule 93 (names -> ID .)
    while           reduce using rule 93 (names -> ID .)
    repeat          reduce using rule 93 (names -> ID .)
    if              reduce using rule 93 (names -> ID .)
    for             reduce using rule 93 (names -> ID .)
    local           reduce using rule 93 (names -> ID .)
    function        reduce using rule 93 (names -> ID .)
    ID              reduce using rule 93 (names -> ID .)
    RESID           reduce using rule 93 (names -> ID .)
    LPAREN          reduce using rule 93 (names -> ID .)
    $end            reduce using rule 93 (names -> ID .)
    end             reduce using rule 93 (names -> ID .)
    until           reduce using rule 93 (names -> ID .)
    else            reduce using rule 93 (names -> ID .)
    elseif          reduce using rule 93 (names -> ID .)
    nil             reduce using rule 93 (names -> ID .)
    false           reduce using rule 93 (names -> ID .)
    true            reduce using rule 93 (names -> ID .)
    STRING          reduce using rule 93 (names -> ID .)
    TRPLDOTS        reduce using rule 93 (names -> ID .)
    INTEGER         reduce using rule 93 (names -> ID .)
    FLOAT           reduce using rule 93 (names -> ID .)
    HEX             reduce using rule 93 (names -> ID .)
    not             reduce using rule 93 (names -> ID .)
    HASH            reduce using rule 93 (names -> ID .)
    LCURLY          reduce using rule 93 (names -> ID .)
    EQUALS          reduce using rule 93 (names -> ID .)
    COLON           reduce using rule 93 (names -> ID .)
    in              reduce using rule 93 (names -> ID .)


state 17

    (9) stat -> while . exp do block end
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 58
    var                            shift and go to state 25
    names                          shift and go to state 5

state 18

    (57) exp -> tableconstructor .

    PLUS            reduce using rule 57 (exp -> tableconstructor .)
    MINUS           reduce using rule 57 (exp -> tableconstructor .)
    TIMES           reduce using rule 57 (exp -> tableconstructor .)
    DIVIDE          reduce using rule 57 (exp -> tableconstructor .)
    POWER           reduce using rule 57 (exp -> tableconstructor .)
    LT              reduce using rule 57 (exp -> tableconstructor .)
    LE              reduce using rule 57 (exp -> tableconstructor .)
    GT              reduce using rule 57 (exp -> tableconstructor .)
    GE              reduce using rule 57 (exp -> tableconstructor .)
    NE              reduce using rule 57 (exp -> tableconstructor .)
    CHECKEQ         reduce using rule 57 (exp -> tableconstructor .)
    and             reduce using rule 57 (exp -> tableconstructor .)
    or              reduce using rule 57 (exp -> tableconstructor .)
    MODULO          reduce using rule 57 (exp -> tableconstructor .)
    DBLDOTS         reduce using rule 57 (exp -> tableconstructor .)
    COMMA           reduce using rule 57 (exp -> tableconstructor .)
    SEMI            reduce using rule 57 (exp -> tableconstructor .)
    then            reduce using rule 57 (exp -> tableconstructor .)
    do              reduce using rule 57 (exp -> tableconstructor .)
    RPAREN          reduce using rule 57 (exp -> tableconstructor .)
    RSQUARE         reduce using rule 57 (exp -> tableconstructor .)
    return          reduce using rule 57 (exp -> tableconstructor .)
    break           reduce using rule 57 (exp -> tableconstructor .)
    while           reduce using rule 57 (exp -> tableconstructor .)
    repeat          reduce using rule 57 (exp -> tableconstructor .)
    if              reduce using rule 57 (exp -> tableconstructor .)
    for             reduce using rule 57 (exp -> tableconstructor .)
    local           reduce using rule 57 (exp -> tableconstructor .)
    function        reduce using rule 57 (exp -> tableconstructor .)
    ID              reduce using rule 57 (exp -> tableconstructor .)
    RESID           reduce using rule 57 (exp -> tableconstructor .)
    LPAREN          reduce using rule 57 (exp -> tableconstructor .)
    $end            reduce using rule 57 (exp -> tableconstructor .)
    end             reduce using rule 57 (exp -> tableconstructor .)
    until           reduce using rule 57 (exp -> tableconstructor .)
    else            reduce using rule 57 (exp -> tableconstructor .)
    elseif          reduce using rule 57 (exp -> tableconstructor .)
    nil             reduce using rule 57 (exp -> tableconstructor .)
    false           reduce using rule 57 (exp -> tableconstructor .)
    true            reduce using rule 57 (exp -> tableconstructor .)
    STRING          reduce using rule 57 (exp -> tableconstructor .)
    TRPLDOTS        reduce using rule 57 (exp -> tableconstructor .)
    INTEGER         reduce using rule 57 (exp -> tableconstructor .)
    FLOAT           reduce using rule 57 (exp -> tableconstructor .)
    HEX             reduce using rule 57 (exp -> tableconstructor .)
    not             reduce using rule 57 (exp -> tableconstructor .)
    HASH            reduce using rule 57 (exp -> tableconstructor .)
    LCURLY          reduce using rule 57 (exp -> tableconstructor .)


state 19

    (56) exp -> unop . exp
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    unop                           shift and go to state 19
    prefixexp                      shift and go to state 24
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 59
    var                            shift and go to state 25
    names                          shift and go to state 5

state 20

    (48) exp -> false .

    PLUS            reduce using rule 48 (exp -> false .)
    MINUS           reduce using rule 48 (exp -> false .)
    TIMES           reduce using rule 48 (exp -> false .)
    DIVIDE          reduce using rule 48 (exp -> false .)
    POWER           reduce using rule 48 (exp -> false .)
    LT              reduce using rule 48 (exp -> false .)
    LE              reduce using rule 48 (exp -> false .)
    GT              reduce using rule 48 (exp -> false .)
    GE              reduce using rule 48 (exp -> false .)
    NE              reduce using rule 48 (exp -> false .)
    CHECKEQ         reduce using rule 48 (exp -> false .)
    and             reduce using rule 48 (exp -> false .)
    or              reduce using rule 48 (exp -> false .)
    MODULO          reduce using rule 48 (exp -> false .)
    DBLDOTS         reduce using rule 48 (exp -> false .)
    COMMA           reduce using rule 48 (exp -> false .)
    SEMI            reduce using rule 48 (exp -> false .)
    then            reduce using rule 48 (exp -> false .)
    do              reduce using rule 48 (exp -> false .)
    RPAREN          reduce using rule 48 (exp -> false .)
    RSQUARE         reduce using rule 48 (exp -> false .)
    return          reduce using rule 48 (exp -> false .)
    break           reduce using rule 48 (exp -> false .)
    while           reduce using rule 48 (exp -> false .)
    repeat          reduce using rule 48 (exp -> false .)
    if              reduce using rule 48 (exp -> false .)
    for             reduce using rule 48 (exp -> false .)
    local           reduce using rule 48 (exp -> false .)
    function        reduce using rule 48 (exp -> false .)
    ID              reduce using rule 48 (exp -> false .)
    RESID           reduce using rule 48 (exp -> false .)
    LPAREN          reduce using rule 48 (exp -> false .)
    $end            reduce using rule 48 (exp -> false .)
    end             reduce using rule 48 (exp -> false .)
    until           reduce using rule 48 (exp -> false .)
    else            reduce using rule 48 (exp -> false .)
    elseif          reduce using rule 48 (exp -> false .)
    nil             reduce using rule 48 (exp -> false .)
    false           reduce using rule 48 (exp -> false .)
    true            reduce using rule 48 (exp -> false .)
    STRING          reduce using rule 48 (exp -> false .)
    TRPLDOTS        reduce using rule 48 (exp -> false .)
    INTEGER         reduce using rule 48 (exp -> false .)
    FLOAT           reduce using rule 48 (exp -> false .)
    HEX             reduce using rule 48 (exp -> false .)
    not             reduce using rule 48 (exp -> false .)
    HASH            reduce using rule 48 (exp -> false .)
    LCURLY          reduce using rule 48 (exp -> false .)


state 21

    (82) tableconstructor -> LCURLY . fieldlist RCURLY
    (83) tableconstructor -> LCURLY . RCURLY
    (84) fieldlist -> . field fieldseplist fieldsep
    (85) fieldlist -> . field fieldseplist fieldsep fieldsep
    (88) field -> . LSQUARE exp RSQUARE EQUALS exp
    (89) field -> . names EQUALS exp
    (90) field -> . exp
    (93) names -> . ID
    (94) names -> . RESID
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names

    RCURLY          shift and go to state 61
    LSQUARE         shift and go to state 65
    ID              shift and go to state 16
    RESID           shift and go to state 3
    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21

    prefixexp                      shift and go to state 24
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    field                          shift and go to state 62
    unop                           shift and go to state 19
    fieldlist                      shift and go to state 63
    exp                            shift and go to state 64
    var                            shift and go to state 25
    names                          shift and go to state 60

state 22

    (79) unop -> MINUS .

    nil             reduce using rule 79 (unop -> MINUS .)
    false           reduce using rule 79 (unop -> MINUS .)
    true            reduce using rule 79 (unop -> MINUS .)
    STRING          reduce using rule 79 (unop -> MINUS .)
    TRPLDOTS        reduce using rule 79 (unop -> MINUS .)
    function        reduce using rule 79 (unop -> MINUS .)
    INTEGER         reduce using rule 79 (unop -> MINUS .)
    FLOAT           reduce using rule 79 (unop -> MINUS .)
    HEX             reduce using rule 79 (unop -> MINUS .)
    LPAREN          reduce using rule 79 (unop -> MINUS .)
    MINUS           reduce using rule 79 (unop -> MINUS .)
    not             reduce using rule 79 (unop -> MINUS .)
    HASH            reduce using rule 79 (unop -> MINUS .)
    LCURLY          reduce using rule 79 (unop -> MINUS .)
    ID              reduce using rule 79 (unop -> MINUS .)
    RESID           reduce using rule 79 (unop -> MINUS .)


state 23

    (51) exp -> STRING .

    PLUS            reduce using rule 51 (exp -> STRING .)
    MINUS           reduce using rule 51 (exp -> STRING .)
    TIMES           reduce using rule 51 (exp -> STRING .)
    DIVIDE          reduce using rule 51 (exp -> STRING .)
    POWER           reduce using rule 51 (exp -> STRING .)
    LT              reduce using rule 51 (exp -> STRING .)
    LE              reduce using rule 51 (exp -> STRING .)
    GT              reduce using rule 51 (exp -> STRING .)
    GE              reduce using rule 51 (exp -> STRING .)
    NE              reduce using rule 51 (exp -> STRING .)
    CHECKEQ         reduce using rule 51 (exp -> STRING .)
    and             reduce using rule 51 (exp -> STRING .)
    or              reduce using rule 51 (exp -> STRING .)
    MODULO          reduce using rule 51 (exp -> STRING .)
    DBLDOTS         reduce using rule 51 (exp -> STRING .)
    COMMA           reduce using rule 51 (exp -> STRING .)
    SEMI            reduce using rule 51 (exp -> STRING .)
    then            reduce using rule 51 (exp -> STRING .)
    do              reduce using rule 51 (exp -> STRING .)
    RPAREN          reduce using rule 51 (exp -> STRING .)
    RSQUARE         reduce using rule 51 (exp -> STRING .)
    return          reduce using rule 51 (exp -> STRING .)
    break           reduce using rule 51 (exp -> STRING .)
    while           reduce using rule 51 (exp -> STRING .)
    repeat          reduce using rule 51 (exp -> STRING .)
    if              reduce using rule 51 (exp -> STRING .)
    for             reduce using rule 51 (exp -> STRING .)
    local           reduce using rule 51 (exp -> STRING .)
    function        reduce using rule 51 (exp -> STRING .)
    ID              reduce using rule 51 (exp -> STRING .)
    RESID           reduce using rule 51 (exp -> STRING .)
    LPAREN          reduce using rule 51 (exp -> STRING .)
    $end            reduce using rule 51 (exp -> STRING .)
    end             reduce using rule 51 (exp -> STRING .)
    until           reduce using rule 51 (exp -> STRING .)
    else            reduce using rule 51 (exp -> STRING .)
    elseif          reduce using rule 51 (exp -> STRING .)
    nil             reduce using rule 51 (exp -> STRING .)
    false           reduce using rule 51 (exp -> STRING .)
    true            reduce using rule 51 (exp -> STRING .)
    STRING          reduce using rule 51 (exp -> STRING .)
    TRPLDOTS        reduce using rule 51 (exp -> STRING .)
    INTEGER         reduce using rule 51 (exp -> STRING .)
    FLOAT           reduce using rule 51 (exp -> STRING .)
    HEX             reduce using rule 51 (exp -> STRING .)
    not             reduce using rule 51 (exp -> STRING .)
    HASH            reduce using rule 51 (exp -> STRING .)
    LCURLY          reduce using rule 51 (exp -> STRING .)


state 24

    (54) exp -> prefixexp .
    (42) var -> prefixexp .
    (43) var -> prefixexp . LSQUARE exp RSQUARE
    (44) var -> prefixexp . SDOT names

  ! reduce/reduce conflict for do resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for PLUS resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for MINUS resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for TIMES resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for POWER resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for LT resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for LE resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for GT resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for GE resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for NE resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for CHECKEQ resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for and resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for or resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for MODULO resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for DBLDOTS resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for COMMA resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for nil resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for false resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for true resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for STRING resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for TRPLDOTS resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for function resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for INTEGER resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for FLOAT resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for HEX resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for LPAREN resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for not resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for HASH resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for LCURLY resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for ID resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for RESID resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for SEMI resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for RPAREN resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for then resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for RSQUARE resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for return resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for break resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for while resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for repeat resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for if resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for for resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for local resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for $end resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for end resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for until resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for else resolved using rule 42 (var -> prefixexp .)
  ! reduce/reduce conflict for elseif resolved using rule 42 (var -> prefixexp .)
  ! shift/reduce conflict for LSQUARE resolved as shift
  ! shift/reduce conflict for SDOT resolved as shift
    do              reduce using rule 42 (var -> prefixexp .)
    PLUS            reduce using rule 42 (var -> prefixexp .)
    MINUS           reduce using rule 42 (var -> prefixexp .)
    TIMES           reduce using rule 42 (var -> prefixexp .)
    DIVIDE          reduce using rule 42 (var -> prefixexp .)
    POWER           reduce using rule 42 (var -> prefixexp .)
    LT              reduce using rule 42 (var -> prefixexp .)
    LE              reduce using rule 42 (var -> prefixexp .)
    GT              reduce using rule 42 (var -> prefixexp .)
    GE              reduce using rule 42 (var -> prefixexp .)
    NE              reduce using rule 42 (var -> prefixexp .)
    CHECKEQ         reduce using rule 42 (var -> prefixexp .)
    and             reduce using rule 42 (var -> prefixexp .)
    or              reduce using rule 42 (var -> prefixexp .)
    MODULO          reduce using rule 42 (var -> prefixexp .)
    DBLDOTS         reduce using rule 42 (var -> prefixexp .)
    COMMA           reduce using rule 42 (var -> prefixexp .)
    nil             reduce using rule 42 (var -> prefixexp .)
    false           reduce using rule 42 (var -> prefixexp .)
    true            reduce using rule 42 (var -> prefixexp .)
    STRING          reduce using rule 42 (var -> prefixexp .)
    TRPLDOTS        reduce using rule 42 (var -> prefixexp .)
    function        reduce using rule 42 (var -> prefixexp .)
    INTEGER         reduce using rule 42 (var -> prefixexp .)
    FLOAT           reduce using rule 42 (var -> prefixexp .)
    HEX             reduce using rule 42 (var -> prefixexp .)
    LPAREN          reduce using rule 42 (var -> prefixexp .)
    not             reduce using rule 42 (var -> prefixexp .)
    HASH            reduce using rule 42 (var -> prefixexp .)
    LCURLY          reduce using rule 42 (var -> prefixexp .)
    ID              reduce using rule 42 (var -> prefixexp .)
    RESID           reduce using rule 42 (var -> prefixexp .)
    SEMI            reduce using rule 42 (var -> prefixexp .)
    RPAREN          reduce using rule 42 (var -> prefixexp .)
    then            reduce using rule 42 (var -> prefixexp .)
    RSQUARE         reduce using rule 42 (var -> prefixexp .)
    return          reduce using rule 42 (var -> prefixexp .)
    break           reduce using rule 42 (var -> prefixexp .)
    while           reduce using rule 42 (var -> prefixexp .)
    repeat          reduce using rule 42 (var -> prefixexp .)
    if              reduce using rule 42 (var -> prefixexp .)
    for             reduce using rule 42 (var -> prefixexp .)
    local           reduce using rule 42 (var -> prefixexp .)
    $end            reduce using rule 42 (var -> prefixexp .)
    end             reduce using rule 42 (var -> prefixexp .)
    until           reduce using rule 42 (var -> prefixexp .)
    else            reduce using rule 42 (var -> prefixexp .)
    elseif          reduce using rule 42 (var -> prefixexp .)
    LSQUARE         shift and go to state 38
    SDOT            shift and go to state 39

  ! PLUS            [ reduce using rule 54 (exp -> prefixexp .) ]
  ! MINUS           [ reduce using rule 54 (exp -> prefixexp .) ]
  ! TIMES           [ reduce using rule 54 (exp -> prefixexp .) ]
  ! DIVIDE          [ reduce using rule 54 (exp -> prefixexp .) ]
  ! POWER           [ reduce using rule 54 (exp -> prefixexp .) ]
  ! LT              [ reduce using rule 54 (exp -> prefixexp .) ]
  ! LE              [ reduce using rule 54 (exp -> prefixexp .) ]
  ! GT              [ reduce using rule 54 (exp -> prefixexp .) ]
  ! GE              [ reduce using rule 54 (exp -> prefixexp .) ]
  ! NE              [ reduce using rule 54 (exp -> prefixexp .) ]
  ! CHECKEQ         [ reduce using rule 54 (exp -> prefixexp .) ]
  ! and             [ reduce using rule 54 (exp -> prefixexp .) ]
  ! or              [ reduce using rule 54 (exp -> prefixexp .) ]
  ! MODULO          [ reduce using rule 54 (exp -> prefixexp .) ]
  ! DBLDOTS         [ reduce using rule 54 (exp -> prefixexp .) ]
  ! COMMA           [ reduce using rule 54 (exp -> prefixexp .) ]
  ! SEMI            [ reduce using rule 54 (exp -> prefixexp .) ]
  ! then            [ reduce using rule 54 (exp -> prefixexp .) ]
  ! do              [ reduce using rule 54 (exp -> prefixexp .) ]
  ! RPAREN          [ reduce using rule 54 (exp -> prefixexp .) ]
  ! RSQUARE         [ reduce using rule 54 (exp -> prefixexp .) ]
  ! return          [ reduce using rule 54 (exp -> prefixexp .) ]
  ! break           [ reduce using rule 54 (exp -> prefixexp .) ]
  ! while           [ reduce using rule 54 (exp -> prefixexp .) ]
  ! repeat          [ reduce using rule 54 (exp -> prefixexp .) ]
  ! if              [ reduce using rule 54 (exp -> prefixexp .) ]
  ! for             [ reduce using rule 54 (exp -> prefixexp .) ]
  ! local           [ reduce using rule 54 (exp -> prefixexp .) ]
  ! function        [ reduce using rule 54 (exp -> prefixexp .) ]
  ! ID              [ reduce using rule 54 (exp -> prefixexp .) ]
  ! RESID           [ reduce using rule 54 (exp -> prefixexp .) ]
  ! LPAREN          [ reduce using rule 54 (exp -> prefixexp .) ]
  ! $end            [ reduce using rule 54 (exp -> prefixexp .) ]
  ! end             [ reduce using rule 54 (exp -> prefixexp .) ]
  ! until           [ reduce using rule 54 (exp -> prefixexp .) ]
  ! else            [ reduce using rule 54 (exp -> prefixexp .) ]
  ! elseif          [ reduce using rule 54 (exp -> prefixexp .) ]
  ! nil             [ reduce using rule 54 (exp -> prefixexp .) ]
  ! false           [ reduce using rule 54 (exp -> prefixexp .) ]
  ! true            [ reduce using rule 54 (exp -> prefixexp .) ]
  ! STRING          [ reduce using rule 54 (exp -> prefixexp .) ]
  ! TRPLDOTS        [ reduce using rule 54 (exp -> prefixexp .) ]
  ! INTEGER         [ reduce using rule 54 (exp -> prefixexp .) ]
  ! FLOAT           [ reduce using rule 54 (exp -> prefixexp .) ]
  ! HEX             [ reduce using rule 54 (exp -> prefixexp .) ]
  ! not             [ reduce using rule 54 (exp -> prefixexp .) ]
  ! HASH            [ reduce using rule 54 (exp -> prefixexp .) ]
  ! LCURLY          [ reduce using rule 54 (exp -> prefixexp .) ]
  ! LSQUARE         [ reduce using rule 42 (var -> prefixexp .) ]
  ! SDOT            [ reduce using rule 42 (var -> prefixexp .) ]


state 25

    (62) prefixexp -> var .

    LSQUARE         reduce using rule 62 (prefixexp -> var .)
    SDOT            reduce using rule 62 (prefixexp -> var .)
    RSQUARE         reduce using rule 62 (prefixexp -> var .)
    PLUS            reduce using rule 62 (prefixexp -> var .)
    MINUS           reduce using rule 62 (prefixexp -> var .)
    TIMES           reduce using rule 62 (prefixexp -> var .)
    DIVIDE          reduce using rule 62 (prefixexp -> var .)
    POWER           reduce using rule 62 (prefixexp -> var .)
    LT              reduce using rule 62 (prefixexp -> var .)
    LE              reduce using rule 62 (prefixexp -> var .)
    GT              reduce using rule 62 (prefixexp -> var .)
    GE              reduce using rule 62 (prefixexp -> var .)
    NE              reduce using rule 62 (prefixexp -> var .)
    CHECKEQ         reduce using rule 62 (prefixexp -> var .)
    and             reduce using rule 62 (prefixexp -> var .)
    or              reduce using rule 62 (prefixexp -> var .)
    MODULO          reduce using rule 62 (prefixexp -> var .)
    DBLDOTS         reduce using rule 62 (prefixexp -> var .)
    COMMA           reduce using rule 62 (prefixexp -> var .)
    nil             reduce using rule 62 (prefixexp -> var .)
    false           reduce using rule 62 (prefixexp -> var .)
    true            reduce using rule 62 (prefixexp -> var .)
    STRING          reduce using rule 62 (prefixexp -> var .)
    TRPLDOTS        reduce using rule 62 (prefixexp -> var .)
    function        reduce using rule 62 (prefixexp -> var .)
    INTEGER         reduce using rule 62 (prefixexp -> var .)
    FLOAT           reduce using rule 62 (prefixexp -> var .)
    HEX             reduce using rule 62 (prefixexp -> var .)
    LPAREN          reduce using rule 62 (prefixexp -> var .)
    not             reduce using rule 62 (prefixexp -> var .)
    HASH            reduce using rule 62 (prefixexp -> var .)
    LCURLY          reduce using rule 62 (prefixexp -> var .)
    ID              reduce using rule 62 (prefixexp -> var .)
    RESID           reduce using rule 62 (prefixexp -> var .)
    SEMI            reduce using rule 62 (prefixexp -> var .)
    RPAREN          reduce using rule 62 (prefixexp -> var .)
    then            reduce using rule 62 (prefixexp -> var .)
    do              reduce using rule 62 (prefixexp -> var .)
    return          reduce using rule 62 (prefixexp -> var .)
    break           reduce using rule 62 (prefixexp -> var .)
    while           reduce using rule 62 (prefixexp -> var .)
    repeat          reduce using rule 62 (prefixexp -> var .)
    if              reduce using rule 62 (prefixexp -> var .)
    for             reduce using rule 62 (prefixexp -> var .)
    local           reduce using rule 62 (prefixexp -> var .)
    $end            reduce using rule 62 (prefixexp -> var .)
    end             reduce using rule 62 (prefixexp -> var .)
    until           reduce using rule 62 (prefixexp -> var .)
    else            reduce using rule 62 (prefixexp -> var .)
    elseif          reduce using rule 62 (prefixexp -> var .)


state 26

    (58) Number -> INTEGER .

    PLUS            reduce using rule 58 (Number -> INTEGER .)
    MINUS           reduce using rule 58 (Number -> INTEGER .)
    TIMES           reduce using rule 58 (Number -> INTEGER .)
    DIVIDE          reduce using rule 58 (Number -> INTEGER .)
    POWER           reduce using rule 58 (Number -> INTEGER .)
    LT              reduce using rule 58 (Number -> INTEGER .)
    LE              reduce using rule 58 (Number -> INTEGER .)
    GT              reduce using rule 58 (Number -> INTEGER .)
    GE              reduce using rule 58 (Number -> INTEGER .)
    NE              reduce using rule 58 (Number -> INTEGER .)
    CHECKEQ         reduce using rule 58 (Number -> INTEGER .)
    and             reduce using rule 58 (Number -> INTEGER .)
    or              reduce using rule 58 (Number -> INTEGER .)
    MODULO          reduce using rule 58 (Number -> INTEGER .)
    DBLDOTS         reduce using rule 58 (Number -> INTEGER .)
    COMMA           reduce using rule 58 (Number -> INTEGER .)
    SEMI            reduce using rule 58 (Number -> INTEGER .)
    RSQUARE         reduce using rule 58 (Number -> INTEGER .)
    RPAREN          reduce using rule 58 (Number -> INTEGER .)
    then            reduce using rule 58 (Number -> INTEGER .)
    do              reduce using rule 58 (Number -> INTEGER .)
    return          reduce using rule 58 (Number -> INTEGER .)
    break           reduce using rule 58 (Number -> INTEGER .)
    while           reduce using rule 58 (Number -> INTEGER .)
    repeat          reduce using rule 58 (Number -> INTEGER .)
    if              reduce using rule 58 (Number -> INTEGER .)
    for             reduce using rule 58 (Number -> INTEGER .)
    local           reduce using rule 58 (Number -> INTEGER .)
    function        reduce using rule 58 (Number -> INTEGER .)
    ID              reduce using rule 58 (Number -> INTEGER .)
    RESID           reduce using rule 58 (Number -> INTEGER .)
    LPAREN          reduce using rule 58 (Number -> INTEGER .)
    $end            reduce using rule 58 (Number -> INTEGER .)
    end             reduce using rule 58 (Number -> INTEGER .)
    until           reduce using rule 58 (Number -> INTEGER .)
    else            reduce using rule 58 (Number -> INTEGER .)
    elseif          reduce using rule 58 (Number -> INTEGER .)
    nil             reduce using rule 58 (Number -> INTEGER .)
    false           reduce using rule 58 (Number -> INTEGER .)
    true            reduce using rule 58 (Number -> INTEGER .)
    STRING          reduce using rule 58 (Number -> INTEGER .)
    TRPLDOTS        reduce using rule 58 (Number -> INTEGER .)
    INTEGER         reduce using rule 58 (Number -> INTEGER .)
    FLOAT           reduce using rule 58 (Number -> INTEGER .)
    HEX             reduce using rule 58 (Number -> INTEGER .)
    not             reduce using rule 58 (Number -> INTEGER .)
    HASH            reduce using rule 58 (Number -> INTEGER .)
    LCURLY          reduce using rule 58 (Number -> INTEGER .)


state 27

    (53) exp -> function .

    PLUS            reduce using rule 53 (exp -> function .)
    MINUS           reduce using rule 53 (exp -> function .)
    TIMES           reduce using rule 53 (exp -> function .)
    DIVIDE          reduce using rule 53 (exp -> function .)
    POWER           reduce using rule 53 (exp -> function .)
    LT              reduce using rule 53 (exp -> function .)
    LE              reduce using rule 53 (exp -> function .)
    GT              reduce using rule 53 (exp -> function .)
    GE              reduce using rule 53 (exp -> function .)
    NE              reduce using rule 53 (exp -> function .)
    CHECKEQ         reduce using rule 53 (exp -> function .)
    and             reduce using rule 53 (exp -> function .)
    or              reduce using rule 53 (exp -> function .)
    MODULO          reduce using rule 53 (exp -> function .)
    DBLDOTS         reduce using rule 53 (exp -> function .)
    COMMA           reduce using rule 53 (exp -> function .)
    SEMI            reduce using rule 53 (exp -> function .)
    then            reduce using rule 53 (exp -> function .)
    do              reduce using rule 53 (exp -> function .)
    RPAREN          reduce using rule 53 (exp -> function .)
    RSQUARE         reduce using rule 53 (exp -> function .)
    return          reduce using rule 53 (exp -> function .)
    break           reduce using rule 53 (exp -> function .)
    while           reduce using rule 53 (exp -> function .)
    repeat          reduce using rule 53 (exp -> function .)
    if              reduce using rule 53 (exp -> function .)
    for             reduce using rule 53 (exp -> function .)
    local           reduce using rule 53 (exp -> function .)
    function        reduce using rule 53 (exp -> function .)
    ID              reduce using rule 53 (exp -> function .)
    RESID           reduce using rule 53 (exp -> function .)
    LPAREN          reduce using rule 53 (exp -> function .)
    $end            reduce using rule 53 (exp -> function .)
    end             reduce using rule 53 (exp -> function .)
    until           reduce using rule 53 (exp -> function .)
    else            reduce using rule 53 (exp -> function .)
    elseif          reduce using rule 53 (exp -> function .)
    nil             reduce using rule 53 (exp -> function .)
    false           reduce using rule 53 (exp -> function .)
    true            reduce using rule 53 (exp -> function .)
    STRING          reduce using rule 53 (exp -> function .)
    TRPLDOTS        reduce using rule 53 (exp -> function .)
    INTEGER         reduce using rule 53 (exp -> function .)
    FLOAT           reduce using rule 53 (exp -> function .)
    HEX             reduce using rule 53 (exp -> function .)
    not             reduce using rule 53 (exp -> function .)
    HASH            reduce using rule 53 (exp -> function .)
    LCURLY          reduce using rule 53 (exp -> function .)


state 28

    (81) unop -> HASH .

    nil             reduce using rule 81 (unop -> HASH .)
    false           reduce using rule 81 (unop -> HASH .)
    true            reduce using rule 81 (unop -> HASH .)
    STRING          reduce using rule 81 (unop -> HASH .)
    TRPLDOTS        reduce using rule 81 (unop -> HASH .)
    function        reduce using rule 81 (unop -> HASH .)
    INTEGER         reduce using rule 81 (unop -> HASH .)
    FLOAT           reduce using rule 81 (unop -> HASH .)
    HEX             reduce using rule 81 (unop -> HASH .)
    LPAREN          reduce using rule 81 (unop -> HASH .)
    MINUS           reduce using rule 81 (unop -> HASH .)
    not             reduce using rule 81 (unop -> HASH .)
    HASH            reduce using rule 81 (unop -> HASH .)
    LCURLY          reduce using rule 81 (unop -> HASH .)
    ID              reduce using rule 81 (unop -> HASH .)
    RESID           reduce using rule 81 (unop -> HASH .)


state 29

    (52) exp -> TRPLDOTS .

    PLUS            reduce using rule 52 (exp -> TRPLDOTS .)
    MINUS           reduce using rule 52 (exp -> TRPLDOTS .)
    TIMES           reduce using rule 52 (exp -> TRPLDOTS .)
    DIVIDE          reduce using rule 52 (exp -> TRPLDOTS .)
    POWER           reduce using rule 52 (exp -> TRPLDOTS .)
    LT              reduce using rule 52 (exp -> TRPLDOTS .)
    LE              reduce using rule 52 (exp -> TRPLDOTS .)
    GT              reduce using rule 52 (exp -> TRPLDOTS .)
    GE              reduce using rule 52 (exp -> TRPLDOTS .)
    NE              reduce using rule 52 (exp -> TRPLDOTS .)
    CHECKEQ         reduce using rule 52 (exp -> TRPLDOTS .)
    and             reduce using rule 52 (exp -> TRPLDOTS .)
    or              reduce using rule 52 (exp -> TRPLDOTS .)
    MODULO          reduce using rule 52 (exp -> TRPLDOTS .)
    DBLDOTS         reduce using rule 52 (exp -> TRPLDOTS .)
    COMMA           reduce using rule 52 (exp -> TRPLDOTS .)
    SEMI            reduce using rule 52 (exp -> TRPLDOTS .)
    then            reduce using rule 52 (exp -> TRPLDOTS .)
    do              reduce using rule 52 (exp -> TRPLDOTS .)
    RPAREN          reduce using rule 52 (exp -> TRPLDOTS .)
    RSQUARE         reduce using rule 52 (exp -> TRPLDOTS .)
    return          reduce using rule 52 (exp -> TRPLDOTS .)
    break           reduce using rule 52 (exp -> TRPLDOTS .)
    while           reduce using rule 52 (exp -> TRPLDOTS .)
    repeat          reduce using rule 52 (exp -> TRPLDOTS .)
    if              reduce using rule 52 (exp -> TRPLDOTS .)
    for             reduce using rule 52 (exp -> TRPLDOTS .)
    local           reduce using rule 52 (exp -> TRPLDOTS .)
    function        reduce using rule 52 (exp -> TRPLDOTS .)
    ID              reduce using rule 52 (exp -> TRPLDOTS .)
    RESID           reduce using rule 52 (exp -> TRPLDOTS .)
    LPAREN          reduce using rule 52 (exp -> TRPLDOTS .)
    $end            reduce using rule 52 (exp -> TRPLDOTS .)
    end             reduce using rule 52 (exp -> TRPLDOTS .)
    until           reduce using rule 52 (exp -> TRPLDOTS .)
    else            reduce using rule 52 (exp -> TRPLDOTS .)
    elseif          reduce using rule 52 (exp -> TRPLDOTS .)
    nil             reduce using rule 52 (exp -> TRPLDOTS .)
    false           reduce using rule 52 (exp -> TRPLDOTS .)
    true            reduce using rule 52 (exp -> TRPLDOTS .)
    STRING          reduce using rule 52 (exp -> TRPLDOTS .)
    TRPLDOTS        reduce using rule 52 (exp -> TRPLDOTS .)
    INTEGER         reduce using rule 52 (exp -> TRPLDOTS .)
    FLOAT           reduce using rule 52 (exp -> TRPLDOTS .)
    HEX             reduce using rule 52 (exp -> TRPLDOTS .)
    not             reduce using rule 52 (exp -> TRPLDOTS .)
    HASH            reduce using rule 52 (exp -> TRPLDOTS .)
    LCURLY          reduce using rule 52 (exp -> TRPLDOTS .)


state 30

    (47) exp -> nil .

    PLUS            reduce using rule 47 (exp -> nil .)
    MINUS           reduce using rule 47 (exp -> nil .)
    TIMES           reduce using rule 47 (exp -> nil .)
    DIVIDE          reduce using rule 47 (exp -> nil .)
    POWER           reduce using rule 47 (exp -> nil .)
    LT              reduce using rule 47 (exp -> nil .)
    LE              reduce using rule 47 (exp -> nil .)
    GT              reduce using rule 47 (exp -> nil .)
    GE              reduce using rule 47 (exp -> nil .)
    NE              reduce using rule 47 (exp -> nil .)
    CHECKEQ         reduce using rule 47 (exp -> nil .)
    and             reduce using rule 47 (exp -> nil .)
    or              reduce using rule 47 (exp -> nil .)
    MODULO          reduce using rule 47 (exp -> nil .)
    DBLDOTS         reduce using rule 47 (exp -> nil .)
    COMMA           reduce using rule 47 (exp -> nil .)
    SEMI            reduce using rule 47 (exp -> nil .)
    then            reduce using rule 47 (exp -> nil .)
    do              reduce using rule 47 (exp -> nil .)
    RPAREN          reduce using rule 47 (exp -> nil .)
    RSQUARE         reduce using rule 47 (exp -> nil .)
    return          reduce using rule 47 (exp -> nil .)
    break           reduce using rule 47 (exp -> nil .)
    while           reduce using rule 47 (exp -> nil .)
    repeat          reduce using rule 47 (exp -> nil .)
    if              reduce using rule 47 (exp -> nil .)
    for             reduce using rule 47 (exp -> nil .)
    local           reduce using rule 47 (exp -> nil .)
    function        reduce using rule 47 (exp -> nil .)
    ID              reduce using rule 47 (exp -> nil .)
    RESID           reduce using rule 47 (exp -> nil .)
    LPAREN          reduce using rule 47 (exp -> nil .)
    $end            reduce using rule 47 (exp -> nil .)
    end             reduce using rule 47 (exp -> nil .)
    until           reduce using rule 47 (exp -> nil .)
    else            reduce using rule 47 (exp -> nil .)
    elseif          reduce using rule 47 (exp -> nil .)
    nil             reduce using rule 47 (exp -> nil .)
    false           reduce using rule 47 (exp -> nil .)
    true            reduce using rule 47 (exp -> nil .)
    STRING          reduce using rule 47 (exp -> nil .)
    TRPLDOTS        reduce using rule 47 (exp -> nil .)
    INTEGER         reduce using rule 47 (exp -> nil .)
    FLOAT           reduce using rule 47 (exp -> nil .)
    HEX             reduce using rule 47 (exp -> nil .)
    not             reduce using rule 47 (exp -> nil .)
    HASH            reduce using rule 47 (exp -> nil .)
    LCURLY          reduce using rule 47 (exp -> nil .)


state 31

    (60) Number -> HEX .

    PLUS            reduce using rule 60 (Number -> HEX .)
    MINUS           reduce using rule 60 (Number -> HEX .)
    TIMES           reduce using rule 60 (Number -> HEX .)
    DIVIDE          reduce using rule 60 (Number -> HEX .)
    POWER           reduce using rule 60 (Number -> HEX .)
    LT              reduce using rule 60 (Number -> HEX .)
    LE              reduce using rule 60 (Number -> HEX .)
    GT              reduce using rule 60 (Number -> HEX .)
    GE              reduce using rule 60 (Number -> HEX .)
    NE              reduce using rule 60 (Number -> HEX .)
    CHECKEQ         reduce using rule 60 (Number -> HEX .)
    and             reduce using rule 60 (Number -> HEX .)
    or              reduce using rule 60 (Number -> HEX .)
    MODULO          reduce using rule 60 (Number -> HEX .)
    DBLDOTS         reduce using rule 60 (Number -> HEX .)
    COMMA           reduce using rule 60 (Number -> HEX .)
    SEMI            reduce using rule 60 (Number -> HEX .)
    RSQUARE         reduce using rule 60 (Number -> HEX .)
    RPAREN          reduce using rule 60 (Number -> HEX .)
    then            reduce using rule 60 (Number -> HEX .)
    do              reduce using rule 60 (Number -> HEX .)
    return          reduce using rule 60 (Number -> HEX .)
    break           reduce using rule 60 (Number -> HEX .)
    while           reduce using rule 60 (Number -> HEX .)
    repeat          reduce using rule 60 (Number -> HEX .)
    if              reduce using rule 60 (Number -> HEX .)
    for             reduce using rule 60 (Number -> HEX .)
    local           reduce using rule 60 (Number -> HEX .)
    function        reduce using rule 60 (Number -> HEX .)
    ID              reduce using rule 60 (Number -> HEX .)
    RESID           reduce using rule 60 (Number -> HEX .)
    LPAREN          reduce using rule 60 (Number -> HEX .)
    $end            reduce using rule 60 (Number -> HEX .)
    end             reduce using rule 60 (Number -> HEX .)
    until           reduce using rule 60 (Number -> HEX .)
    else            reduce using rule 60 (Number -> HEX .)
    elseif          reduce using rule 60 (Number -> HEX .)
    nil             reduce using rule 60 (Number -> HEX .)
    false           reduce using rule 60 (Number -> HEX .)
    true            reduce using rule 60 (Number -> HEX .)
    STRING          reduce using rule 60 (Number -> HEX .)
    TRPLDOTS        reduce using rule 60 (Number -> HEX .)
    INTEGER         reduce using rule 60 (Number -> HEX .)
    FLOAT           reduce using rule 60 (Number -> HEX .)
    HEX             reduce using rule 60 (Number -> HEX .)
    not             reduce using rule 60 (Number -> HEX .)
    HASH            reduce using rule 60 (Number -> HEX .)
    LCURLY          reduce using rule 60 (Number -> HEX .)


state 32

    (80) unop -> not .

    nil             reduce using rule 80 (unop -> not .)
    false           reduce using rule 80 (unop -> not .)
    true            reduce using rule 80 (unop -> not .)
    STRING          reduce using rule 80 (unop -> not .)
    TRPLDOTS        reduce using rule 80 (unop -> not .)
    function        reduce using rule 80 (unop -> not .)
    INTEGER         reduce using rule 80 (unop -> not .)
    FLOAT           reduce using rule 80 (unop -> not .)
    HEX             reduce using rule 80 (unop -> not .)
    LPAREN          reduce using rule 80 (unop -> not .)
    MINUS           reduce using rule 80 (unop -> not .)
    not             reduce using rule 80 (unop -> not .)
    HASH            reduce using rule 80 (unop -> not .)
    LCURLY          reduce using rule 80 (unop -> not .)
    ID              reduce using rule 80 (unop -> not .)
    RESID           reduce using rule 80 (unop -> not .)


state 33

    (49) exp -> true .

    PLUS            reduce using rule 49 (exp -> true .)
    MINUS           reduce using rule 49 (exp -> true .)
    TIMES           reduce using rule 49 (exp -> true .)
    DIVIDE          reduce using rule 49 (exp -> true .)
    POWER           reduce using rule 49 (exp -> true .)
    LT              reduce using rule 49 (exp -> true .)
    LE              reduce using rule 49 (exp -> true .)
    GT              reduce using rule 49 (exp -> true .)
    GE              reduce using rule 49 (exp -> true .)
    NE              reduce using rule 49 (exp -> true .)
    CHECKEQ         reduce using rule 49 (exp -> true .)
    and             reduce using rule 49 (exp -> true .)
    or              reduce using rule 49 (exp -> true .)
    MODULO          reduce using rule 49 (exp -> true .)
    DBLDOTS         reduce using rule 49 (exp -> true .)
    COMMA           reduce using rule 49 (exp -> true .)
    SEMI            reduce using rule 49 (exp -> true .)
    then            reduce using rule 49 (exp -> true .)
    do              reduce using rule 49 (exp -> true .)
    RPAREN          reduce using rule 49 (exp -> true .)
    RSQUARE         reduce using rule 49 (exp -> true .)
    return          reduce using rule 49 (exp -> true .)
    break           reduce using rule 49 (exp -> true .)
    while           reduce using rule 49 (exp -> true .)
    repeat          reduce using rule 49 (exp -> true .)
    if              reduce using rule 49 (exp -> true .)
    for             reduce using rule 49 (exp -> true .)
    local           reduce using rule 49 (exp -> true .)
    function        reduce using rule 49 (exp -> true .)
    ID              reduce using rule 49 (exp -> true .)
    RESID           reduce using rule 49 (exp -> true .)
    LPAREN          reduce using rule 49 (exp -> true .)
    $end            reduce using rule 49 (exp -> true .)
    end             reduce using rule 49 (exp -> true .)
    until           reduce using rule 49 (exp -> true .)
    else            reduce using rule 49 (exp -> true .)
    elseif          reduce using rule 49 (exp -> true .)
    nil             reduce using rule 49 (exp -> true .)
    false           reduce using rule 49 (exp -> true .)
    true            reduce using rule 49 (exp -> true .)
    STRING          reduce using rule 49 (exp -> true .)
    TRPLDOTS        reduce using rule 49 (exp -> true .)
    INTEGER         reduce using rule 49 (exp -> true .)
    FLOAT           reduce using rule 49 (exp -> true .)
    HEX             reduce using rule 49 (exp -> true .)
    not             reduce using rule 49 (exp -> true .)
    HASH            reduce using rule 49 (exp -> true .)
    LCURLY          reduce using rule 49 (exp -> true .)


state 34

    (59) Number -> FLOAT .

    PLUS            reduce using rule 59 (Number -> FLOAT .)
    MINUS           reduce using rule 59 (Number -> FLOAT .)
    TIMES           reduce using rule 59 (Number -> FLOAT .)
    DIVIDE          reduce using rule 59 (Number -> FLOAT .)
    POWER           reduce using rule 59 (Number -> FLOAT .)
    LT              reduce using rule 59 (Number -> FLOAT .)
    LE              reduce using rule 59 (Number -> FLOAT .)
    GT              reduce using rule 59 (Number -> FLOAT .)
    GE              reduce using rule 59 (Number -> FLOAT .)
    NE              reduce using rule 59 (Number -> FLOAT .)
    CHECKEQ         reduce using rule 59 (Number -> FLOAT .)
    and             reduce using rule 59 (Number -> FLOAT .)
    or              reduce using rule 59 (Number -> FLOAT .)
    MODULO          reduce using rule 59 (Number -> FLOAT .)
    DBLDOTS         reduce using rule 59 (Number -> FLOAT .)
    COMMA           reduce using rule 59 (Number -> FLOAT .)
    SEMI            reduce using rule 59 (Number -> FLOAT .)
    RSQUARE         reduce using rule 59 (Number -> FLOAT .)
    RPAREN          reduce using rule 59 (Number -> FLOAT .)
    then            reduce using rule 59 (Number -> FLOAT .)
    do              reduce using rule 59 (Number -> FLOAT .)
    return          reduce using rule 59 (Number -> FLOAT .)
    break           reduce using rule 59 (Number -> FLOAT .)
    while           reduce using rule 59 (Number -> FLOAT .)
    repeat          reduce using rule 59 (Number -> FLOAT .)
    if              reduce using rule 59 (Number -> FLOAT .)
    for             reduce using rule 59 (Number -> FLOAT .)
    local           reduce using rule 59 (Number -> FLOAT .)
    function        reduce using rule 59 (Number -> FLOAT .)
    ID              reduce using rule 59 (Number -> FLOAT .)
    RESID           reduce using rule 59 (Number -> FLOAT .)
    LPAREN          reduce using rule 59 (Number -> FLOAT .)
    $end            reduce using rule 59 (Number -> FLOAT .)
    end             reduce using rule 59 (Number -> FLOAT .)
    until           reduce using rule 59 (Number -> FLOAT .)
    else            reduce using rule 59 (Number -> FLOAT .)
    elseif          reduce using rule 59 (Number -> FLOAT .)
    nil             reduce using rule 59 (Number -> FLOAT .)
    false           reduce using rule 59 (Number -> FLOAT .)
    true            reduce using rule 59 (Number -> FLOAT .)
    STRING          reduce using rule 59 (Number -> FLOAT .)
    TRPLDOTS        reduce using rule 59 (Number -> FLOAT .)
    INTEGER         reduce using rule 59 (Number -> FLOAT .)
    FLOAT           reduce using rule 59 (Number -> FLOAT .)
    HEX             reduce using rule 59 (Number -> FLOAT .)
    not             reduce using rule 59 (Number -> FLOAT .)
    HASH            reduce using rule 59 (Number -> FLOAT .)
    LCURLY          reduce using rule 59 (Number -> FLOAT .)


state 35

    (50) exp -> Number .

    PLUS            reduce using rule 50 (exp -> Number .)
    MINUS           reduce using rule 50 (exp -> Number .)
    TIMES           reduce using rule 50 (exp -> Number .)
    DIVIDE          reduce using rule 50 (exp -> Number .)
    POWER           reduce using rule 50 (exp -> Number .)
    LT              reduce using rule 50 (exp -> Number .)
    LE              reduce using rule 50 (exp -> Number .)
    GT              reduce using rule 50 (exp -> Number .)
    GE              reduce using rule 50 (exp -> Number .)
    NE              reduce using rule 50 (exp -> Number .)
    CHECKEQ         reduce using rule 50 (exp -> Number .)
    and             reduce using rule 50 (exp -> Number .)
    or              reduce using rule 50 (exp -> Number .)
    MODULO          reduce using rule 50 (exp -> Number .)
    DBLDOTS         reduce using rule 50 (exp -> Number .)
    COMMA           reduce using rule 50 (exp -> Number .)
    SEMI            reduce using rule 50 (exp -> Number .)
    then            reduce using rule 50 (exp -> Number .)
    do              reduce using rule 50 (exp -> Number .)
    RPAREN          reduce using rule 50 (exp -> Number .)
    RSQUARE         reduce using rule 50 (exp -> Number .)
    return          reduce using rule 50 (exp -> Number .)
    break           reduce using rule 50 (exp -> Number .)
    while           reduce using rule 50 (exp -> Number .)
    repeat          reduce using rule 50 (exp -> Number .)
    if              reduce using rule 50 (exp -> Number .)
    for             reduce using rule 50 (exp -> Number .)
    local           reduce using rule 50 (exp -> Number .)
    function        reduce using rule 50 (exp -> Number .)
    ID              reduce using rule 50 (exp -> Number .)
    RESID           reduce using rule 50 (exp -> Number .)
    LPAREN          reduce using rule 50 (exp -> Number .)
    $end            reduce using rule 50 (exp -> Number .)
    end             reduce using rule 50 (exp -> Number .)
    until           reduce using rule 50 (exp -> Number .)
    else            reduce using rule 50 (exp -> Number .)
    elseif          reduce using rule 50 (exp -> Number .)
    nil             reduce using rule 50 (exp -> Number .)
    false           reduce using rule 50 (exp -> Number .)
    true            reduce using rule 50 (exp -> Number .)
    STRING          reduce using rule 50 (exp -> Number .)
    TRPLDOTS        reduce using rule 50 (exp -> Number .)
    INTEGER         reduce using rule 50 (exp -> Number .)
    FLOAT           reduce using rule 50 (exp -> Number .)
    HEX             reduce using rule 50 (exp -> Number .)
    not             reduce using rule 50 (exp -> Number .)
    HASH            reduce using rule 50 (exp -> Number .)
    LCURLY          reduce using rule 50 (exp -> Number .)


state 36

    (63) prefixexp -> LPAREN exp . RPAREN
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    RPAREN          shift and go to state 68
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 37

    (11) stat -> if exp . then block ifblock else block end
    (12) stat -> if exp . then block ifblock end
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    then            shift and go to state 83
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 38

    (43) var -> prefixexp LSQUARE . exp RSQUARE
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 84
    var                            shift and go to state 25
    names                          shift and go to state 5

state 39

    (44) var -> prefixexp SDOT . names
    (93) names -> . ID
    (94) names -> . RESID

    ID              shift and go to state 16
    RESID           shift and go to state 3

    names                          shift and go to state 85

state 40

    (15) stat -> for namelist . in explist do block end

    in              shift and go to state 86


state 41

    (13) stat -> for names . EQUALS exp COMMA exp do block end
    (14) stat -> for names . EQUALS exp COMMA exp COMMA exp do block end
    (45) namelist -> names . comid
    (34) comid -> . COMMA names comid
    (35) comid -> . empty
    (61) empty -> .

    EQUALS          shift and go to state 87
    COMMA           shift and go to state 89
    in              reduce using rule 61 (empty -> .)

    empty                          shift and go to state 88
    comid                          shift and go to state 90

state 42

    (7) stat -> varlist EQUALS . explist
    (46) explist -> . comexp exp
    (36) comexp -> . COMMA exp comexp
    (37) comexp -> . empty
    (61) empty -> .

    COMMA           shift and go to state 92
    nil             reduce using rule 61 (empty -> .)
    false           reduce using rule 61 (empty -> .)
    true            reduce using rule 61 (empty -> .)
    STRING          reduce using rule 61 (empty -> .)
    TRPLDOTS        reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    INTEGER         reduce using rule 61 (empty -> .)
    FLOAT           reduce using rule 61 (empty -> .)
    HEX             reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    MINUS           reduce using rule 61 (empty -> .)
    not             reduce using rule 61 (empty -> .)
    HASH            reduce using rule 61 (empty -> .)
    LCURLY          reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)

    explist                        shift and go to state 93
    empty                          shift and go to state 94
    comexp                         shift and go to state 91

state 43

    (32) comvar -> COMMA . var comvar
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN

    ID              shift and go to state 16
    RESID           shift and go to state 3
    LPAREN          shift and go to state 4

    var                            shift and go to state 95
    prefixexp                      shift and go to state 7
    names                          shift and go to state 5

state 44

    (40) varlist -> var comvar .

    EQUALS          reduce using rule 40 (varlist -> var comvar .)


state 45

    (33) comvar -> empty .

    EQUALS          reduce using rule 33 (comvar -> empty .)


state 46

    (19) stat -> local function . names funcbody
    (93) names -> . ID
    (94) names -> . RESID

    ID              shift and go to state 16
    RESID           shift and go to state 3

    names                          shift and go to state 96

state 47

    (16) stat -> local namelist .
    (17) stat -> local namelist . EQUALS explist

    SEMI            reduce using rule 16 (stat -> local namelist .)
    return          reduce using rule 16 (stat -> local namelist .)
    break           reduce using rule 16 (stat -> local namelist .)
    do              reduce using rule 16 (stat -> local namelist .)
    while           reduce using rule 16 (stat -> local namelist .)
    repeat          reduce using rule 16 (stat -> local namelist .)
    if              reduce using rule 16 (stat -> local namelist .)
    for             reduce using rule 16 (stat -> local namelist .)
    local           reduce using rule 16 (stat -> local namelist .)
    function        reduce using rule 16 (stat -> local namelist .)
    ID              reduce using rule 16 (stat -> local namelist .)
    RESID           reduce using rule 16 (stat -> local namelist .)
    LPAREN          reduce using rule 16 (stat -> local namelist .)
    $end            reduce using rule 16 (stat -> local namelist .)
    end             reduce using rule 16 (stat -> local namelist .)
    until           reduce using rule 16 (stat -> local namelist .)
    else            reduce using rule 16 (stat -> local namelist .)
    elseif          reduce using rule 16 (stat -> local namelist .)
    EQUALS          shift and go to state 97


state 48

    (45) namelist -> names . comid
    (34) comid -> . COMMA names comid
    (35) comid -> . empty
    (61) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 89
    EQUALS          reduce using rule 61 (empty -> .)
    SEMI            reduce using rule 61 (empty -> .)
    return          reduce using rule 61 (empty -> .)
    break           reduce using rule 61 (empty -> .)
    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    $end            reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)
    until           reduce using rule 61 (empty -> .)
    else            reduce using rule 61 (empty -> .)
    elseif          reduce using rule 61 (empty -> .)
    RPAREN          reduce using rule 61 (empty -> .)

  ! COMMA           [ reduce using rule 61 (empty -> .) ]

    empty                          shift and go to state 88
    comid                          shift and go to state 90

state 49

    (18) stat -> function funcname . funcbody
    (20) funcbody -> . LPAREN RPAREN block end
    (21) funcbody -> . LPAREN parlist RPAREN block end

    LPAREN          shift and go to state 99

    funcbody                       shift and go to state 98

state 50

    (28) funcname -> names . dotid COLON
    (29) funcname -> names . dotid
    (30) dotid -> . SDOT names dotid
    (31) dotid -> . empty
    (61) empty -> .

    SDOT            shift and go to state 100
    COLON           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)

    dotid                          shift and go to state 101
    empty                          shift and go to state 102

state 51

    (6) block -> chunk .
    (1) chunk -> chunk . stat
    (2) chunk -> chunk . stat SEMI
    (3) chunk -> chunk . stat laststat
    (4) chunk -> chunk . stat SEMI laststat SEMI
    (7) stat -> . varlist EQUALS explist
    (8) stat -> . do block end
    (9) stat -> . while exp do block end
    (10) stat -> . repeat block until exp
    (11) stat -> . if exp then block ifblock else block end
    (12) stat -> . if exp then block ifblock end
    (13) stat -> . for names EQUALS exp COMMA exp do block end
    (14) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (15) stat -> . for namelist in explist do block end
    (16) stat -> . local namelist
    (17) stat -> . local namelist EQUALS explist
    (18) stat -> . function funcname funcbody
    (19) stat -> . local function names funcbody
    (40) varlist -> . var comvar
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN

    until           reduce using rule 6 (block -> chunk .)
    end             reduce using rule 6 (block -> chunk .)
    else            reduce using rule 6 (block -> chunk .)
    elseif          reduce using rule 6 (block -> chunk .)
    do              shift and go to state 13
    while           shift and go to state 17
    repeat          shift and go to state 15
    if              shift and go to state 6
    for             shift and go to state 8
    local           shift and go to state 11
    function        shift and go to state 12
    ID              shift and go to state 16
    RESID           shift and go to state 3
    LPAREN          shift and go to state 4

    prefixexp                      shift and go to state 7
    stat                           shift and go to state 14
    varlist                        shift and go to state 9
    names                          shift and go to state 5
    var                            shift and go to state 10

state 52

    (8) stat -> do block . end

    end             shift and go to state 103


state 53

    (25) laststat -> return . explist
    (26) laststat -> return .
    (46) explist -> . comexp exp
    (36) comexp -> . COMMA exp comexp
    (37) comexp -> . empty
    (61) empty -> .

  ! reduce/reduce conflict for function resolved using rule 26 (laststat -> return .)
  ! reduce/reduce conflict for LPAREN resolved using rule 26 (laststat -> return .)
  ! reduce/reduce conflict for ID resolved using rule 26 (laststat -> return .)
  ! reduce/reduce conflict for RESID resolved using rule 26 (laststat -> return .)
    do              reduce using rule 26 (laststat -> return .)
    while           reduce using rule 26 (laststat -> return .)
    repeat          reduce using rule 26 (laststat -> return .)
    if              reduce using rule 26 (laststat -> return .)
    for             reduce using rule 26 (laststat -> return .)
    local           reduce using rule 26 (laststat -> return .)
    function        reduce using rule 26 (laststat -> return .)
    ID              reduce using rule 26 (laststat -> return .)
    RESID           reduce using rule 26 (laststat -> return .)
    LPAREN          reduce using rule 26 (laststat -> return .)
    $end            reduce using rule 26 (laststat -> return .)
    end             reduce using rule 26 (laststat -> return .)
    until           reduce using rule 26 (laststat -> return .)
    else            reduce using rule 26 (laststat -> return .)
    elseif          reduce using rule 26 (laststat -> return .)
    SEMI            reduce using rule 26 (laststat -> return .)
    COMMA           shift and go to state 92
    nil             reduce using rule 61 (empty -> .)
    false           reduce using rule 61 (empty -> .)
    true            reduce using rule 61 (empty -> .)
    STRING          reduce using rule 61 (empty -> .)
    TRPLDOTS        reduce using rule 61 (empty -> .)
    INTEGER         reduce using rule 61 (empty -> .)
    FLOAT           reduce using rule 61 (empty -> .)
    HEX             reduce using rule 61 (empty -> .)
    MINUS           reduce using rule 61 (empty -> .)
    not             reduce using rule 61 (empty -> .)
    HASH            reduce using rule 61 (empty -> .)
    LCURLY          reduce using rule 61 (empty -> .)

  ! function        [ reduce using rule 61 (empty -> .) ]
  ! LPAREN          [ reduce using rule 61 (empty -> .) ]
  ! ID              [ reduce using rule 61 (empty -> .) ]
  ! RESID           [ reduce using rule 61 (empty -> .) ]

    explist                        shift and go to state 104
    empty                          shift and go to state 94
    comexp                         shift and go to state 91

state 54

    (2) chunk -> chunk stat SEMI .
    (4) chunk -> chunk stat SEMI . laststat SEMI
    (25) laststat -> . return explist
    (26) laststat -> . return
    (27) laststat -> . break

    do              reduce using rule 2 (chunk -> chunk stat SEMI .)
    while           reduce using rule 2 (chunk -> chunk stat SEMI .)
    repeat          reduce using rule 2 (chunk -> chunk stat SEMI .)
    if              reduce using rule 2 (chunk -> chunk stat SEMI .)
    for             reduce using rule 2 (chunk -> chunk stat SEMI .)
    local           reduce using rule 2 (chunk -> chunk stat SEMI .)
    function        reduce using rule 2 (chunk -> chunk stat SEMI .)
    ID              reduce using rule 2 (chunk -> chunk stat SEMI .)
    RESID           reduce using rule 2 (chunk -> chunk stat SEMI .)
    LPAREN          reduce using rule 2 (chunk -> chunk stat SEMI .)
    end             reduce using rule 2 (chunk -> chunk stat SEMI .)
    $end            reduce using rule 2 (chunk -> chunk stat SEMI .)
    else            reduce using rule 2 (chunk -> chunk stat SEMI .)
    elseif          reduce using rule 2 (chunk -> chunk stat SEMI .)
    until           reduce using rule 2 (chunk -> chunk stat SEMI .)
    return          shift and go to state 53
    break           shift and go to state 56

    laststat                       shift and go to state 105

state 55

    (3) chunk -> chunk stat laststat .

    do              reduce using rule 3 (chunk -> chunk stat laststat .)
    while           reduce using rule 3 (chunk -> chunk stat laststat .)
    repeat          reduce using rule 3 (chunk -> chunk stat laststat .)
    if              reduce using rule 3 (chunk -> chunk stat laststat .)
    for             reduce using rule 3 (chunk -> chunk stat laststat .)
    local           reduce using rule 3 (chunk -> chunk stat laststat .)
    function        reduce using rule 3 (chunk -> chunk stat laststat .)
    ID              reduce using rule 3 (chunk -> chunk stat laststat .)
    RESID           reduce using rule 3 (chunk -> chunk stat laststat .)
    LPAREN          reduce using rule 3 (chunk -> chunk stat laststat .)
    end             reduce using rule 3 (chunk -> chunk stat laststat .)
    $end            reduce using rule 3 (chunk -> chunk stat laststat .)
    else            reduce using rule 3 (chunk -> chunk stat laststat .)
    elseif          reduce using rule 3 (chunk -> chunk stat laststat .)
    until           reduce using rule 3 (chunk -> chunk stat laststat .)


state 56

    (27) laststat -> break .

    do              reduce using rule 27 (laststat -> break .)
    while           reduce using rule 27 (laststat -> break .)
    repeat          reduce using rule 27 (laststat -> break .)
    if              reduce using rule 27 (laststat -> break .)
    for             reduce using rule 27 (laststat -> break .)
    local           reduce using rule 27 (laststat -> break .)
    function        reduce using rule 27 (laststat -> break .)
    ID              reduce using rule 27 (laststat -> break .)
    RESID           reduce using rule 27 (laststat -> break .)
    LPAREN          reduce using rule 27 (laststat -> break .)
    $end            reduce using rule 27 (laststat -> break .)
    end             reduce using rule 27 (laststat -> break .)
    until           reduce using rule 27 (laststat -> break .)
    else            reduce using rule 27 (laststat -> break .)
    elseif          reduce using rule 27 (laststat -> break .)
    SEMI            reduce using rule 27 (laststat -> break .)


state 57

    (10) stat -> repeat block . until exp

    until           shift and go to state 106


state 58

    (9) stat -> while exp . do block end
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    do              shift and go to state 107
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 59

    (56) exp -> unop exp .
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for CHECKEQ resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for DBLDOTS resolved as shift
    COMMA           reduce using rule 56 (exp -> unop exp .)
    SEMI            reduce using rule 56 (exp -> unop exp .)
    then            reduce using rule 56 (exp -> unop exp .)
    do              reduce using rule 56 (exp -> unop exp .)
    RPAREN          reduce using rule 56 (exp -> unop exp .)
    RSQUARE         reduce using rule 56 (exp -> unop exp .)
    return          reduce using rule 56 (exp -> unop exp .)
    break           reduce using rule 56 (exp -> unop exp .)
    while           reduce using rule 56 (exp -> unop exp .)
    repeat          reduce using rule 56 (exp -> unop exp .)
    if              reduce using rule 56 (exp -> unop exp .)
    for             reduce using rule 56 (exp -> unop exp .)
    local           reduce using rule 56 (exp -> unop exp .)
    function        reduce using rule 56 (exp -> unop exp .)
    ID              reduce using rule 56 (exp -> unop exp .)
    RESID           reduce using rule 56 (exp -> unop exp .)
    LPAREN          reduce using rule 56 (exp -> unop exp .)
    $end            reduce using rule 56 (exp -> unop exp .)
    end             reduce using rule 56 (exp -> unop exp .)
    until           reduce using rule 56 (exp -> unop exp .)
    else            reduce using rule 56 (exp -> unop exp .)
    elseif          reduce using rule 56 (exp -> unop exp .)
    nil             reduce using rule 56 (exp -> unop exp .)
    false           reduce using rule 56 (exp -> unop exp .)
    true            reduce using rule 56 (exp -> unop exp .)
    STRING          reduce using rule 56 (exp -> unop exp .)
    TRPLDOTS        reduce using rule 56 (exp -> unop exp .)
    INTEGER         reduce using rule 56 (exp -> unop exp .)
    FLOAT           reduce using rule 56 (exp -> unop exp .)
    HEX             reduce using rule 56 (exp -> unop exp .)
    not             reduce using rule 56 (exp -> unop exp .)
    HASH            reduce using rule 56 (exp -> unop exp .)
    LCURLY          reduce using rule 56 (exp -> unop exp .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

  ! PLUS            [ reduce using rule 56 (exp -> unop exp .) ]
  ! MINUS           [ reduce using rule 56 (exp -> unop exp .) ]
  ! TIMES           [ reduce using rule 56 (exp -> unop exp .) ]
  ! DIVIDE          [ reduce using rule 56 (exp -> unop exp .) ]
  ! POWER           [ reduce using rule 56 (exp -> unop exp .) ]
  ! LT              [ reduce using rule 56 (exp -> unop exp .) ]
  ! LE              [ reduce using rule 56 (exp -> unop exp .) ]
  ! GT              [ reduce using rule 56 (exp -> unop exp .) ]
  ! GE              [ reduce using rule 56 (exp -> unop exp .) ]
  ! NE              [ reduce using rule 56 (exp -> unop exp .) ]
  ! CHECKEQ         [ reduce using rule 56 (exp -> unop exp .) ]
  ! and             [ reduce using rule 56 (exp -> unop exp .) ]
  ! or              [ reduce using rule 56 (exp -> unop exp .) ]
  ! MODULO          [ reduce using rule 56 (exp -> unop exp .) ]
  ! DBLDOTS         [ reduce using rule 56 (exp -> unop exp .) ]

    binop                          shift and go to state 70

state 60

    (89) field -> names . EQUALS exp
    (41) var -> names .

    EQUALS          shift and go to state 108
    LSQUARE         reduce using rule 41 (var -> names .)
    SDOT            reduce using rule 41 (var -> names .)
    PLUS            reduce using rule 41 (var -> names .)
    MINUS           reduce using rule 41 (var -> names .)
    TIMES           reduce using rule 41 (var -> names .)
    DIVIDE          reduce using rule 41 (var -> names .)
    POWER           reduce using rule 41 (var -> names .)
    LT              reduce using rule 41 (var -> names .)
    LE              reduce using rule 41 (var -> names .)
    GT              reduce using rule 41 (var -> names .)
    GE              reduce using rule 41 (var -> names .)
    NE              reduce using rule 41 (var -> names .)
    CHECKEQ         reduce using rule 41 (var -> names .)
    and             reduce using rule 41 (var -> names .)
    or              reduce using rule 41 (var -> names .)
    MODULO          reduce using rule 41 (var -> names .)
    DBLDOTS         reduce using rule 41 (var -> names .)
    COMMA           reduce using rule 41 (var -> names .)
    SEMI            reduce using rule 41 (var -> names .)


state 61

    (83) tableconstructor -> LCURLY RCURLY .

    do              reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    COMMA           reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    PLUS            reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    MINUS           reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    TIMES           reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    DIVIDE          reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    POWER           reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    LT              reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    LE              reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    GT              reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    GE              reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    NE              reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    CHECKEQ         reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    and             reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    or              reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    MODULO          reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    DBLDOTS         reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    SEMI            reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    nil             reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    false           reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    true            reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    STRING          reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    TRPLDOTS        reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    function        reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    INTEGER         reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    FLOAT           reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    HEX             reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    LPAREN          reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    not             reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    HASH            reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    LCURLY          reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    ID              reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    RESID           reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    then            reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    RPAREN          reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    RSQUARE         reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    return          reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    break           reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    while           reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    repeat          reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    if              reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    for             reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    local           reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    $end            reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    end             reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    until           reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    else            reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)
    elseif          reduce using rule 83 (tableconstructor -> LCURLY RCURLY .)


state 62

    (84) fieldlist -> field . fieldseplist fieldsep
    (85) fieldlist -> field . fieldseplist fieldsep fieldsep
    (86) fieldseplist -> . fieldsep field fieldseplist
    (87) fieldseplist -> . empty
    (91) fieldsep -> . COMMA
    (92) fieldsep -> . SEMI
    (61) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for SEMI resolved as shift
    COMMA           shift and go to state 111
    SEMI            shift and go to state 110

  ! COMMA           [ reduce using rule 61 (empty -> .) ]
  ! SEMI            [ reduce using rule 61 (empty -> .) ]

    fieldsep                       shift and go to state 109
    fieldseplist                   shift and go to state 112
    empty                          shift and go to state 113

state 63

    (82) tableconstructor -> LCURLY fieldlist . RCURLY

    RCURLY          shift and go to state 114


state 64

    (90) field -> exp .
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    COMMA           reduce using rule 90 (field -> exp .)
    SEMI            reduce using rule 90 (field -> exp .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 65

    (88) field -> LSQUARE . exp RSQUARE EQUALS exp
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 115
    var                            shift and go to state 25
    names                          shift and go to state 5

state 66

    (75) binop -> and .

    nil             reduce using rule 75 (binop -> and .)
    false           reduce using rule 75 (binop -> and .)
    true            reduce using rule 75 (binop -> and .)
    STRING          reduce using rule 75 (binop -> and .)
    TRPLDOTS        reduce using rule 75 (binop -> and .)
    function        reduce using rule 75 (binop -> and .)
    INTEGER         reduce using rule 75 (binop -> and .)
    FLOAT           reduce using rule 75 (binop -> and .)
    HEX             reduce using rule 75 (binop -> and .)
    LPAREN          reduce using rule 75 (binop -> and .)
    MINUS           reduce using rule 75 (binop -> and .)
    not             reduce using rule 75 (binop -> and .)
    HASH            reduce using rule 75 (binop -> and .)
    LCURLY          reduce using rule 75 (binop -> and .)
    ID              reduce using rule 75 (binop -> and .)
    RESID           reduce using rule 75 (binop -> and .)


state 67

    (70) binop -> LE .

    nil             reduce using rule 70 (binop -> LE .)
    false           reduce using rule 70 (binop -> LE .)
    true            reduce using rule 70 (binop -> LE .)
    STRING          reduce using rule 70 (binop -> LE .)
    TRPLDOTS        reduce using rule 70 (binop -> LE .)
    function        reduce using rule 70 (binop -> LE .)
    INTEGER         reduce using rule 70 (binop -> LE .)
    FLOAT           reduce using rule 70 (binop -> LE .)
    HEX             reduce using rule 70 (binop -> LE .)
    LPAREN          reduce using rule 70 (binop -> LE .)
    MINUS           reduce using rule 70 (binop -> LE .)
    not             reduce using rule 70 (binop -> LE .)
    HASH            reduce using rule 70 (binop -> LE .)
    LCURLY          reduce using rule 70 (binop -> LE .)
    ID              reduce using rule 70 (binop -> LE .)
    RESID           reduce using rule 70 (binop -> LE .)


state 68

    (63) prefixexp -> LPAREN exp RPAREN .

    LSQUARE         reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    SDOT            reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    RSQUARE         reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    POWER           reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    LE              reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    GE              reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    CHECKEQ         reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    and             reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    or              reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    MODULO          reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    DBLDOTS         reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    nil             reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    false           reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    true            reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    STRING          reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    TRPLDOTS        reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    function        reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    INTEGER         reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    FLOAT           reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    HEX             reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    not             reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    HASH            reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    LCURLY          reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    RESID           reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    SEMI            reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    then            reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    do              reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    return          reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    break           reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    while           reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    repeat          reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    if              reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    for             reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    local           reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    $end            reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    end             reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    until           reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    else            reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    elseif          reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)
    EQUALS          reduce using rule 63 (prefixexp -> LPAREN exp RPAREN .)


state 69

    (68) binop -> POWER .

    nil             reduce using rule 68 (binop -> POWER .)
    false           reduce using rule 68 (binop -> POWER .)
    true            reduce using rule 68 (binop -> POWER .)
    STRING          reduce using rule 68 (binop -> POWER .)
    TRPLDOTS        reduce using rule 68 (binop -> POWER .)
    function        reduce using rule 68 (binop -> POWER .)
    INTEGER         reduce using rule 68 (binop -> POWER .)
    FLOAT           reduce using rule 68 (binop -> POWER .)
    HEX             reduce using rule 68 (binop -> POWER .)
    LPAREN          reduce using rule 68 (binop -> POWER .)
    MINUS           reduce using rule 68 (binop -> POWER .)
    not             reduce using rule 68 (binop -> POWER .)
    HASH            reduce using rule 68 (binop -> POWER .)
    LCURLY          reduce using rule 68 (binop -> POWER .)
    ID              reduce using rule 68 (binop -> POWER .)
    RESID           reduce using rule 68 (binop -> POWER .)


state 70

    (55) exp -> exp binop . exp
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 116
    var                            shift and go to state 25
    names                          shift and go to state 5

state 71

    (76) binop -> or .

    nil             reduce using rule 76 (binop -> or .)
    false           reduce using rule 76 (binop -> or .)
    true            reduce using rule 76 (binop -> or .)
    STRING          reduce using rule 76 (binop -> or .)
    TRPLDOTS        reduce using rule 76 (binop -> or .)
    function        reduce using rule 76 (binop -> or .)
    INTEGER         reduce using rule 76 (binop -> or .)
    FLOAT           reduce using rule 76 (binop -> or .)
    HEX             reduce using rule 76 (binop -> or .)
    LPAREN          reduce using rule 76 (binop -> or .)
    MINUS           reduce using rule 76 (binop -> or .)
    not             reduce using rule 76 (binop -> or .)
    HASH            reduce using rule 76 (binop -> or .)
    LCURLY          reduce using rule 76 (binop -> or .)
    ID              reduce using rule 76 (binop -> or .)
    RESID           reduce using rule 76 (binop -> or .)


state 72

    (72) binop -> GE .

    nil             reduce using rule 72 (binop -> GE .)
    false           reduce using rule 72 (binop -> GE .)
    true            reduce using rule 72 (binop -> GE .)
    STRING          reduce using rule 72 (binop -> GE .)
    TRPLDOTS        reduce using rule 72 (binop -> GE .)
    function        reduce using rule 72 (binop -> GE .)
    INTEGER         reduce using rule 72 (binop -> GE .)
    FLOAT           reduce using rule 72 (binop -> GE .)
    HEX             reduce using rule 72 (binop -> GE .)
    LPAREN          reduce using rule 72 (binop -> GE .)
    MINUS           reduce using rule 72 (binop -> GE .)
    not             reduce using rule 72 (binop -> GE .)
    HASH            reduce using rule 72 (binop -> GE .)
    LCURLY          reduce using rule 72 (binop -> GE .)
    ID              reduce using rule 72 (binop -> GE .)
    RESID           reduce using rule 72 (binop -> GE .)


state 73

    (66) binop -> TIMES .

    nil             reduce using rule 66 (binop -> TIMES .)
    false           reduce using rule 66 (binop -> TIMES .)
    true            reduce using rule 66 (binop -> TIMES .)
    STRING          reduce using rule 66 (binop -> TIMES .)
    TRPLDOTS        reduce using rule 66 (binop -> TIMES .)
    function        reduce using rule 66 (binop -> TIMES .)
    INTEGER         reduce using rule 66 (binop -> TIMES .)
    FLOAT           reduce using rule 66 (binop -> TIMES .)
    HEX             reduce using rule 66 (binop -> TIMES .)
    LPAREN          reduce using rule 66 (binop -> TIMES .)
    MINUS           reduce using rule 66 (binop -> TIMES .)
    not             reduce using rule 66 (binop -> TIMES .)
    HASH            reduce using rule 66 (binop -> TIMES .)
    LCURLY          reduce using rule 66 (binop -> TIMES .)
    ID              reduce using rule 66 (binop -> TIMES .)
    RESID           reduce using rule 66 (binop -> TIMES .)


state 74

    (74) binop -> CHECKEQ .

    nil             reduce using rule 74 (binop -> CHECKEQ .)
    false           reduce using rule 74 (binop -> CHECKEQ .)
    true            reduce using rule 74 (binop -> CHECKEQ .)
    STRING          reduce using rule 74 (binop -> CHECKEQ .)
    TRPLDOTS        reduce using rule 74 (binop -> CHECKEQ .)
    function        reduce using rule 74 (binop -> CHECKEQ .)
    INTEGER         reduce using rule 74 (binop -> CHECKEQ .)
    FLOAT           reduce using rule 74 (binop -> CHECKEQ .)
    HEX             reduce using rule 74 (binop -> CHECKEQ .)
    LPAREN          reduce using rule 74 (binop -> CHECKEQ .)
    MINUS           reduce using rule 74 (binop -> CHECKEQ .)
    not             reduce using rule 74 (binop -> CHECKEQ .)
    HASH            reduce using rule 74 (binop -> CHECKEQ .)
    LCURLY          reduce using rule 74 (binop -> CHECKEQ .)
    ID              reduce using rule 74 (binop -> CHECKEQ .)
    RESID           reduce using rule 74 (binop -> CHECKEQ .)


state 75

    (69) binop -> LT .

    nil             reduce using rule 69 (binop -> LT .)
    false           reduce using rule 69 (binop -> LT .)
    true            reduce using rule 69 (binop -> LT .)
    STRING          reduce using rule 69 (binop -> LT .)
    TRPLDOTS        reduce using rule 69 (binop -> LT .)
    function        reduce using rule 69 (binop -> LT .)
    INTEGER         reduce using rule 69 (binop -> LT .)
    FLOAT           reduce using rule 69 (binop -> LT .)
    HEX             reduce using rule 69 (binop -> LT .)
    LPAREN          reduce using rule 69 (binop -> LT .)
    MINUS           reduce using rule 69 (binop -> LT .)
    not             reduce using rule 69 (binop -> LT .)
    HASH            reduce using rule 69 (binop -> LT .)
    LCURLY          reduce using rule 69 (binop -> LT .)
    ID              reduce using rule 69 (binop -> LT .)
    RESID           reduce using rule 69 (binop -> LT .)


state 76

    (71) binop -> GT .

    nil             reduce using rule 71 (binop -> GT .)
    false           reduce using rule 71 (binop -> GT .)
    true            reduce using rule 71 (binop -> GT .)
    STRING          reduce using rule 71 (binop -> GT .)
    TRPLDOTS        reduce using rule 71 (binop -> GT .)
    function        reduce using rule 71 (binop -> GT .)
    INTEGER         reduce using rule 71 (binop -> GT .)
    FLOAT           reduce using rule 71 (binop -> GT .)
    HEX             reduce using rule 71 (binop -> GT .)
    LPAREN          reduce using rule 71 (binop -> GT .)
    MINUS           reduce using rule 71 (binop -> GT .)
    not             reduce using rule 71 (binop -> GT .)
    HASH            reduce using rule 71 (binop -> GT .)
    LCURLY          reduce using rule 71 (binop -> GT .)
    ID              reduce using rule 71 (binop -> GT .)
    RESID           reduce using rule 71 (binop -> GT .)


state 77

    (64) binop -> PLUS .

    nil             reduce using rule 64 (binop -> PLUS .)
    false           reduce using rule 64 (binop -> PLUS .)
    true            reduce using rule 64 (binop -> PLUS .)
    STRING          reduce using rule 64 (binop -> PLUS .)
    TRPLDOTS        reduce using rule 64 (binop -> PLUS .)
    function        reduce using rule 64 (binop -> PLUS .)
    INTEGER         reduce using rule 64 (binop -> PLUS .)
    FLOAT           reduce using rule 64 (binop -> PLUS .)
    HEX             reduce using rule 64 (binop -> PLUS .)
    LPAREN          reduce using rule 64 (binop -> PLUS .)
    MINUS           reduce using rule 64 (binop -> PLUS .)
    not             reduce using rule 64 (binop -> PLUS .)
    HASH            reduce using rule 64 (binop -> PLUS .)
    LCURLY          reduce using rule 64 (binop -> PLUS .)
    ID              reduce using rule 64 (binop -> PLUS .)
    RESID           reduce using rule 64 (binop -> PLUS .)


state 78

    (77) binop -> MODULO .

    nil             reduce using rule 77 (binop -> MODULO .)
    false           reduce using rule 77 (binop -> MODULO .)
    true            reduce using rule 77 (binop -> MODULO .)
    STRING          reduce using rule 77 (binop -> MODULO .)
    TRPLDOTS        reduce using rule 77 (binop -> MODULO .)
    function        reduce using rule 77 (binop -> MODULO .)
    INTEGER         reduce using rule 77 (binop -> MODULO .)
    FLOAT           reduce using rule 77 (binop -> MODULO .)
    HEX             reduce using rule 77 (binop -> MODULO .)
    LPAREN          reduce using rule 77 (binop -> MODULO .)
    MINUS           reduce using rule 77 (binop -> MODULO .)
    not             reduce using rule 77 (binop -> MODULO .)
    HASH            reduce using rule 77 (binop -> MODULO .)
    LCURLY          reduce using rule 77 (binop -> MODULO .)
    ID              reduce using rule 77 (binop -> MODULO .)
    RESID           reduce using rule 77 (binop -> MODULO .)


state 79

    (78) binop -> DBLDOTS .

    nil             reduce using rule 78 (binop -> DBLDOTS .)
    false           reduce using rule 78 (binop -> DBLDOTS .)
    true            reduce using rule 78 (binop -> DBLDOTS .)
    STRING          reduce using rule 78 (binop -> DBLDOTS .)
    TRPLDOTS        reduce using rule 78 (binop -> DBLDOTS .)
    function        reduce using rule 78 (binop -> DBLDOTS .)
    INTEGER         reduce using rule 78 (binop -> DBLDOTS .)
    FLOAT           reduce using rule 78 (binop -> DBLDOTS .)
    HEX             reduce using rule 78 (binop -> DBLDOTS .)
    LPAREN          reduce using rule 78 (binop -> DBLDOTS .)
    MINUS           reduce using rule 78 (binop -> DBLDOTS .)
    not             reduce using rule 78 (binop -> DBLDOTS .)
    HASH            reduce using rule 78 (binop -> DBLDOTS .)
    LCURLY          reduce using rule 78 (binop -> DBLDOTS .)
    ID              reduce using rule 78 (binop -> DBLDOTS .)
    RESID           reduce using rule 78 (binop -> DBLDOTS .)


state 80

    (65) binop -> MINUS .

    nil             reduce using rule 65 (binop -> MINUS .)
    false           reduce using rule 65 (binop -> MINUS .)
    true            reduce using rule 65 (binop -> MINUS .)
    STRING          reduce using rule 65 (binop -> MINUS .)
    TRPLDOTS        reduce using rule 65 (binop -> MINUS .)
    function        reduce using rule 65 (binop -> MINUS .)
    INTEGER         reduce using rule 65 (binop -> MINUS .)
    FLOAT           reduce using rule 65 (binop -> MINUS .)
    HEX             reduce using rule 65 (binop -> MINUS .)
    LPAREN          reduce using rule 65 (binop -> MINUS .)
    MINUS           reduce using rule 65 (binop -> MINUS .)
    not             reduce using rule 65 (binop -> MINUS .)
    HASH            reduce using rule 65 (binop -> MINUS .)
    LCURLY          reduce using rule 65 (binop -> MINUS .)
    ID              reduce using rule 65 (binop -> MINUS .)
    RESID           reduce using rule 65 (binop -> MINUS .)


state 81

    (73) binop -> NE .

    nil             reduce using rule 73 (binop -> NE .)
    false           reduce using rule 73 (binop -> NE .)
    true            reduce using rule 73 (binop -> NE .)
    STRING          reduce using rule 73 (binop -> NE .)
    TRPLDOTS        reduce using rule 73 (binop -> NE .)
    function        reduce using rule 73 (binop -> NE .)
    INTEGER         reduce using rule 73 (binop -> NE .)
    FLOAT           reduce using rule 73 (binop -> NE .)
    HEX             reduce using rule 73 (binop -> NE .)
    LPAREN          reduce using rule 73 (binop -> NE .)
    MINUS           reduce using rule 73 (binop -> NE .)
    not             reduce using rule 73 (binop -> NE .)
    HASH            reduce using rule 73 (binop -> NE .)
    LCURLY          reduce using rule 73 (binop -> NE .)
    ID              reduce using rule 73 (binop -> NE .)
    RESID           reduce using rule 73 (binop -> NE .)


state 82

    (67) binop -> DIVIDE .

    nil             reduce using rule 67 (binop -> DIVIDE .)
    false           reduce using rule 67 (binop -> DIVIDE .)
    true            reduce using rule 67 (binop -> DIVIDE .)
    STRING          reduce using rule 67 (binop -> DIVIDE .)
    TRPLDOTS        reduce using rule 67 (binop -> DIVIDE .)
    function        reduce using rule 67 (binop -> DIVIDE .)
    INTEGER         reduce using rule 67 (binop -> DIVIDE .)
    FLOAT           reduce using rule 67 (binop -> DIVIDE .)
    HEX             reduce using rule 67 (binop -> DIVIDE .)
    LPAREN          reduce using rule 67 (binop -> DIVIDE .)
    MINUS           reduce using rule 67 (binop -> DIVIDE .)
    not             reduce using rule 67 (binop -> DIVIDE .)
    HASH            reduce using rule 67 (binop -> DIVIDE .)
    LCURLY          reduce using rule 67 (binop -> DIVIDE .)
    ID              reduce using rule 67 (binop -> DIVIDE .)
    RESID           reduce using rule 67 (binop -> DIVIDE .)


state 83

    (11) stat -> if exp then . block ifblock else block end
    (12) stat -> if exp then . block ifblock end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    else            reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)
    elseif          reduce using rule 61 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 117

state 84

    (43) var -> prefixexp LSQUARE exp . RSQUARE
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    RSQUARE         shift and go to state 118
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 85

    (44) var -> prefixexp SDOT names .

    LSQUARE         reduce using rule 44 (var -> prefixexp SDOT names .)
    SDOT            reduce using rule 44 (var -> prefixexp SDOT names .)
    do              reduce using rule 44 (var -> prefixexp SDOT names .)
    PLUS            reduce using rule 44 (var -> prefixexp SDOT names .)
    MINUS           reduce using rule 44 (var -> prefixexp SDOT names .)
    TIMES           reduce using rule 44 (var -> prefixexp SDOT names .)
    DIVIDE          reduce using rule 44 (var -> prefixexp SDOT names .)
    POWER           reduce using rule 44 (var -> prefixexp SDOT names .)
    LT              reduce using rule 44 (var -> prefixexp SDOT names .)
    LE              reduce using rule 44 (var -> prefixexp SDOT names .)
    GT              reduce using rule 44 (var -> prefixexp SDOT names .)
    GE              reduce using rule 44 (var -> prefixexp SDOT names .)
    NE              reduce using rule 44 (var -> prefixexp SDOT names .)
    CHECKEQ         reduce using rule 44 (var -> prefixexp SDOT names .)
    and             reduce using rule 44 (var -> prefixexp SDOT names .)
    or              reduce using rule 44 (var -> prefixexp SDOT names .)
    MODULO          reduce using rule 44 (var -> prefixexp SDOT names .)
    DBLDOTS         reduce using rule 44 (var -> prefixexp SDOT names .)
    COMMA           reduce using rule 44 (var -> prefixexp SDOT names .)
    EQUALS          reduce using rule 44 (var -> prefixexp SDOT names .)
    nil             reduce using rule 44 (var -> prefixexp SDOT names .)
    false           reduce using rule 44 (var -> prefixexp SDOT names .)
    true            reduce using rule 44 (var -> prefixexp SDOT names .)
    STRING          reduce using rule 44 (var -> prefixexp SDOT names .)
    TRPLDOTS        reduce using rule 44 (var -> prefixexp SDOT names .)
    function        reduce using rule 44 (var -> prefixexp SDOT names .)
    INTEGER         reduce using rule 44 (var -> prefixexp SDOT names .)
    FLOAT           reduce using rule 44 (var -> prefixexp SDOT names .)
    HEX             reduce using rule 44 (var -> prefixexp SDOT names .)
    LPAREN          reduce using rule 44 (var -> prefixexp SDOT names .)
    not             reduce using rule 44 (var -> prefixexp SDOT names .)
    HASH            reduce using rule 44 (var -> prefixexp SDOT names .)
    LCURLY          reduce using rule 44 (var -> prefixexp SDOT names .)
    ID              reduce using rule 44 (var -> prefixexp SDOT names .)
    RESID           reduce using rule 44 (var -> prefixexp SDOT names .)
    SEMI            reduce using rule 44 (var -> prefixexp SDOT names .)
    RPAREN          reduce using rule 44 (var -> prefixexp SDOT names .)
    then            reduce using rule 44 (var -> prefixexp SDOT names .)
    RSQUARE         reduce using rule 44 (var -> prefixexp SDOT names .)
    return          reduce using rule 44 (var -> prefixexp SDOT names .)
    break           reduce using rule 44 (var -> prefixexp SDOT names .)
    while           reduce using rule 44 (var -> prefixexp SDOT names .)
    repeat          reduce using rule 44 (var -> prefixexp SDOT names .)
    if              reduce using rule 44 (var -> prefixexp SDOT names .)
    for             reduce using rule 44 (var -> prefixexp SDOT names .)
    local           reduce using rule 44 (var -> prefixexp SDOT names .)
    $end            reduce using rule 44 (var -> prefixexp SDOT names .)
    end             reduce using rule 44 (var -> prefixexp SDOT names .)
    until           reduce using rule 44 (var -> prefixexp SDOT names .)
    else            reduce using rule 44 (var -> prefixexp SDOT names .)
    elseif          reduce using rule 44 (var -> prefixexp SDOT names .)


state 86

    (15) stat -> for namelist in . explist do block end
    (46) explist -> . comexp exp
    (36) comexp -> . COMMA exp comexp
    (37) comexp -> . empty
    (61) empty -> .

    COMMA           shift and go to state 92
    nil             reduce using rule 61 (empty -> .)
    false           reduce using rule 61 (empty -> .)
    true            reduce using rule 61 (empty -> .)
    STRING          reduce using rule 61 (empty -> .)
    TRPLDOTS        reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    INTEGER         reduce using rule 61 (empty -> .)
    FLOAT           reduce using rule 61 (empty -> .)
    HEX             reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    MINUS           reduce using rule 61 (empty -> .)
    not             reduce using rule 61 (empty -> .)
    HASH            reduce using rule 61 (empty -> .)
    LCURLY          reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)

    comexp                         shift and go to state 91
    explist                        shift and go to state 119
    empty                          shift and go to state 94

state 87

    (13) stat -> for names EQUALS . exp COMMA exp do block end
    (14) stat -> for names EQUALS . exp COMMA exp COMMA exp do block end
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    names                          shift and go to state 5
    exp                            shift and go to state 120
    var                            shift and go to state 25

state 88

    (35) comid -> empty .

    EQUALS          reduce using rule 35 (comid -> empty .)
    SEMI            reduce using rule 35 (comid -> empty .)
    return          reduce using rule 35 (comid -> empty .)
    break           reduce using rule 35 (comid -> empty .)
    do              reduce using rule 35 (comid -> empty .)
    while           reduce using rule 35 (comid -> empty .)
    repeat          reduce using rule 35 (comid -> empty .)
    if              reduce using rule 35 (comid -> empty .)
    for             reduce using rule 35 (comid -> empty .)
    local           reduce using rule 35 (comid -> empty .)
    function        reduce using rule 35 (comid -> empty .)
    ID              reduce using rule 35 (comid -> empty .)
    RESID           reduce using rule 35 (comid -> empty .)
    LPAREN          reduce using rule 35 (comid -> empty .)
    $end            reduce using rule 35 (comid -> empty .)
    end             reduce using rule 35 (comid -> empty .)
    until           reduce using rule 35 (comid -> empty .)
    else            reduce using rule 35 (comid -> empty .)
    elseif          reduce using rule 35 (comid -> empty .)
    COMMA           reduce using rule 35 (comid -> empty .)
    RPAREN          reduce using rule 35 (comid -> empty .)
    in              reduce using rule 35 (comid -> empty .)


state 89

    (34) comid -> COMMA . names comid
    (93) names -> . ID
    (94) names -> . RESID

    ID              shift and go to state 16
    RESID           shift and go to state 3

    names                          shift and go to state 121

state 90

    (45) namelist -> names comid .

    COMMA           reduce using rule 45 (namelist -> names comid .)
    RPAREN          reduce using rule 45 (namelist -> names comid .)
    in              reduce using rule 45 (namelist -> names comid .)
    EQUALS          reduce using rule 45 (namelist -> names comid .)
    SEMI            reduce using rule 45 (namelist -> names comid .)
    return          reduce using rule 45 (namelist -> names comid .)
    break           reduce using rule 45 (namelist -> names comid .)
    do              reduce using rule 45 (namelist -> names comid .)
    while           reduce using rule 45 (namelist -> names comid .)
    repeat          reduce using rule 45 (namelist -> names comid .)
    if              reduce using rule 45 (namelist -> names comid .)
    for             reduce using rule 45 (namelist -> names comid .)
    local           reduce using rule 45 (namelist -> names comid .)
    function        reduce using rule 45 (namelist -> names comid .)
    ID              reduce using rule 45 (namelist -> names comid .)
    RESID           reduce using rule 45 (namelist -> names comid .)
    LPAREN          reduce using rule 45 (namelist -> names comid .)
    $end            reduce using rule 45 (namelist -> names comid .)
    end             reduce using rule 45 (namelist -> names comid .)
    until           reduce using rule 45 (namelist -> names comid .)
    else            reduce using rule 45 (namelist -> names comid .)
    elseif          reduce using rule 45 (namelist -> names comid .)


state 91

    (46) explist -> comexp . exp
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 122
    var                            shift and go to state 25
    names                          shift and go to state 5

state 92

    (36) comexp -> COMMA . exp comexp
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 123
    var                            shift and go to state 25
    names                          shift and go to state 5

state 93

    (7) stat -> varlist EQUALS explist .

    SEMI            reduce using rule 7 (stat -> varlist EQUALS explist .)
    return          reduce using rule 7 (stat -> varlist EQUALS explist .)
    break           reduce using rule 7 (stat -> varlist EQUALS explist .)
    do              reduce using rule 7 (stat -> varlist EQUALS explist .)
    while           reduce using rule 7 (stat -> varlist EQUALS explist .)
    repeat          reduce using rule 7 (stat -> varlist EQUALS explist .)
    if              reduce using rule 7 (stat -> varlist EQUALS explist .)
    for             reduce using rule 7 (stat -> varlist EQUALS explist .)
    local           reduce using rule 7 (stat -> varlist EQUALS explist .)
    function        reduce using rule 7 (stat -> varlist EQUALS explist .)
    ID              reduce using rule 7 (stat -> varlist EQUALS explist .)
    RESID           reduce using rule 7 (stat -> varlist EQUALS explist .)
    LPAREN          reduce using rule 7 (stat -> varlist EQUALS explist .)
    $end            reduce using rule 7 (stat -> varlist EQUALS explist .)
    end             reduce using rule 7 (stat -> varlist EQUALS explist .)
    until           reduce using rule 7 (stat -> varlist EQUALS explist .)
    else            reduce using rule 7 (stat -> varlist EQUALS explist .)
    elseif          reduce using rule 7 (stat -> varlist EQUALS explist .)


state 94

    (37) comexp -> empty .

    nil             reduce using rule 37 (comexp -> empty .)
    false           reduce using rule 37 (comexp -> empty .)
    true            reduce using rule 37 (comexp -> empty .)
    STRING          reduce using rule 37 (comexp -> empty .)
    TRPLDOTS        reduce using rule 37 (comexp -> empty .)
    function        reduce using rule 37 (comexp -> empty .)
    INTEGER         reduce using rule 37 (comexp -> empty .)
    FLOAT           reduce using rule 37 (comexp -> empty .)
    HEX             reduce using rule 37 (comexp -> empty .)
    LPAREN          reduce using rule 37 (comexp -> empty .)
    MINUS           reduce using rule 37 (comexp -> empty .)
    not             reduce using rule 37 (comexp -> empty .)
    HASH            reduce using rule 37 (comexp -> empty .)
    LCURLY          reduce using rule 37 (comexp -> empty .)
    ID              reduce using rule 37 (comexp -> empty .)
    RESID           reduce using rule 37 (comexp -> empty .)


state 95

    (32) comvar -> COMMA var . comvar
    (62) prefixexp -> var .
    (32) comvar -> . COMMA var comvar
    (33) comvar -> . empty
    (61) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
  ! reduce/reduce conflict for EQUALS resolved using rule 61 (empty -> .)
    LSQUARE         reduce using rule 62 (prefixexp -> var .)
    SDOT            reduce using rule 62 (prefixexp -> var .)
    COMMA           shift and go to state 43
    EQUALS          reduce using rule 61 (empty -> .)

  ! COMMA           [ reduce using rule 62 (prefixexp -> var .) ]
  ! EQUALS          [ reduce using rule 62 (prefixexp -> var .) ]

    comvar                         shift and go to state 124
    empty                          shift and go to state 45

state 96

    (19) stat -> local function names . funcbody
    (20) funcbody -> . LPAREN RPAREN block end
    (21) funcbody -> . LPAREN parlist RPAREN block end

    LPAREN          shift and go to state 99

    funcbody                       shift and go to state 125

state 97

    (17) stat -> local namelist EQUALS . explist
    (46) explist -> . comexp exp
    (36) comexp -> . COMMA exp comexp
    (37) comexp -> . empty
    (61) empty -> .

    COMMA           shift and go to state 92
    nil             reduce using rule 61 (empty -> .)
    false           reduce using rule 61 (empty -> .)
    true            reduce using rule 61 (empty -> .)
    STRING          reduce using rule 61 (empty -> .)
    TRPLDOTS        reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    INTEGER         reduce using rule 61 (empty -> .)
    FLOAT           reduce using rule 61 (empty -> .)
    HEX             reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    MINUS           reduce using rule 61 (empty -> .)
    not             reduce using rule 61 (empty -> .)
    HASH            reduce using rule 61 (empty -> .)
    LCURLY          reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)

    explist                        shift and go to state 126
    empty                          shift and go to state 94
    comexp                         shift and go to state 91

state 98

    (18) stat -> function funcname funcbody .

    SEMI            reduce using rule 18 (stat -> function funcname funcbody .)
    return          reduce using rule 18 (stat -> function funcname funcbody .)
    break           reduce using rule 18 (stat -> function funcname funcbody .)
    do              reduce using rule 18 (stat -> function funcname funcbody .)
    while           reduce using rule 18 (stat -> function funcname funcbody .)
    repeat          reduce using rule 18 (stat -> function funcname funcbody .)
    if              reduce using rule 18 (stat -> function funcname funcbody .)
    for             reduce using rule 18 (stat -> function funcname funcbody .)
    local           reduce using rule 18 (stat -> function funcname funcbody .)
    function        reduce using rule 18 (stat -> function funcname funcbody .)
    ID              reduce using rule 18 (stat -> function funcname funcbody .)
    RESID           reduce using rule 18 (stat -> function funcname funcbody .)
    LPAREN          reduce using rule 18 (stat -> function funcname funcbody .)
    $end            reduce using rule 18 (stat -> function funcname funcbody .)
    end             reduce using rule 18 (stat -> function funcname funcbody .)
    until           reduce using rule 18 (stat -> function funcname funcbody .)
    else            reduce using rule 18 (stat -> function funcname funcbody .)
    elseif          reduce using rule 18 (stat -> function funcname funcbody .)


state 99

    (20) funcbody -> LPAREN . RPAREN block end
    (21) funcbody -> LPAREN . parlist RPAREN block end
    (22) parlist -> . namelist
    (23) parlist -> . namelist COMMA TRPLDOTS
    (24) parlist -> . TRPLDOTS
    (45) namelist -> . names comid
    (93) names -> . ID
    (94) names -> . RESID

    RPAREN          shift and go to state 130
    TRPLDOTS        shift and go to state 128
    ID              shift and go to state 16
    RESID           shift and go to state 3

    namelist                       shift and go to state 127
    parlist                        shift and go to state 129
    names                          shift and go to state 48

state 100

    (30) dotid -> SDOT . names dotid
    (93) names -> . ID
    (94) names -> . RESID

    ID              shift and go to state 16
    RESID           shift and go to state 3

    names                          shift and go to state 131

state 101

    (28) funcname -> names dotid . COLON
    (29) funcname -> names dotid .

    COLON           shift and go to state 132
    LPAREN          reduce using rule 29 (funcname -> names dotid .)


state 102

    (31) dotid -> empty .

    COLON           reduce using rule 31 (dotid -> empty .)
    LPAREN          reduce using rule 31 (dotid -> empty .)


state 103

    (8) stat -> do block end .

    SEMI            reduce using rule 8 (stat -> do block end .)
    return          reduce using rule 8 (stat -> do block end .)
    break           reduce using rule 8 (stat -> do block end .)
    do              reduce using rule 8 (stat -> do block end .)
    while           reduce using rule 8 (stat -> do block end .)
    repeat          reduce using rule 8 (stat -> do block end .)
    if              reduce using rule 8 (stat -> do block end .)
    for             reduce using rule 8 (stat -> do block end .)
    local           reduce using rule 8 (stat -> do block end .)
    function        reduce using rule 8 (stat -> do block end .)
    ID              reduce using rule 8 (stat -> do block end .)
    RESID           reduce using rule 8 (stat -> do block end .)
    LPAREN          reduce using rule 8 (stat -> do block end .)
    $end            reduce using rule 8 (stat -> do block end .)
    end             reduce using rule 8 (stat -> do block end .)
    until           reduce using rule 8 (stat -> do block end .)
    else            reduce using rule 8 (stat -> do block end .)
    elseif          reduce using rule 8 (stat -> do block end .)


state 104

    (25) laststat -> return explist .

    do              reduce using rule 25 (laststat -> return explist .)
    while           reduce using rule 25 (laststat -> return explist .)
    repeat          reduce using rule 25 (laststat -> return explist .)
    if              reduce using rule 25 (laststat -> return explist .)
    for             reduce using rule 25 (laststat -> return explist .)
    local           reduce using rule 25 (laststat -> return explist .)
    function        reduce using rule 25 (laststat -> return explist .)
    ID              reduce using rule 25 (laststat -> return explist .)
    RESID           reduce using rule 25 (laststat -> return explist .)
    LPAREN          reduce using rule 25 (laststat -> return explist .)
    $end            reduce using rule 25 (laststat -> return explist .)
    end             reduce using rule 25 (laststat -> return explist .)
    until           reduce using rule 25 (laststat -> return explist .)
    else            reduce using rule 25 (laststat -> return explist .)
    elseif          reduce using rule 25 (laststat -> return explist .)
    SEMI            reduce using rule 25 (laststat -> return explist .)


state 105

    (4) chunk -> chunk stat SEMI laststat . SEMI

    SEMI            shift and go to state 133


state 106

    (10) stat -> repeat block until . exp
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 134
    var                            shift and go to state 25
    names                          shift and go to state 5

state 107

    (9) stat -> while exp do . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 135

state 108

    (89) field -> names EQUALS . exp
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    names                          shift and go to state 5
    exp                            shift and go to state 136
    var                            shift and go to state 25

state 109

    (86) fieldseplist -> fieldsep . field fieldseplist
    (88) field -> . LSQUARE exp RSQUARE EQUALS exp
    (89) field -> . names EQUALS exp
    (90) field -> . exp
    (93) names -> . ID
    (94) names -> . RESID
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names

    LSQUARE         shift and go to state 65
    ID              shift and go to state 16
    RESID           shift and go to state 3
    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21

    prefixexp                      shift and go to state 24
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    field                          shift and go to state 137
    unop                           shift and go to state 19
    names                          shift and go to state 60
    exp                            shift and go to state 64
    var                            shift and go to state 25

state 110

    (92) fieldsep -> SEMI .

    LSQUARE         reduce using rule 92 (fieldsep -> SEMI .)
    ID              reduce using rule 92 (fieldsep -> SEMI .)
    RESID           reduce using rule 92 (fieldsep -> SEMI .)
    nil             reduce using rule 92 (fieldsep -> SEMI .)
    false           reduce using rule 92 (fieldsep -> SEMI .)
    true            reduce using rule 92 (fieldsep -> SEMI .)
    STRING          reduce using rule 92 (fieldsep -> SEMI .)
    TRPLDOTS        reduce using rule 92 (fieldsep -> SEMI .)
    function        reduce using rule 92 (fieldsep -> SEMI .)
    INTEGER         reduce using rule 92 (fieldsep -> SEMI .)
    FLOAT           reduce using rule 92 (fieldsep -> SEMI .)
    HEX             reduce using rule 92 (fieldsep -> SEMI .)
    LPAREN          reduce using rule 92 (fieldsep -> SEMI .)
    MINUS           reduce using rule 92 (fieldsep -> SEMI .)
    not             reduce using rule 92 (fieldsep -> SEMI .)
    HASH            reduce using rule 92 (fieldsep -> SEMI .)
    LCURLY          reduce using rule 92 (fieldsep -> SEMI .)
    RCURLY          reduce using rule 92 (fieldsep -> SEMI .)
    COMMA           reduce using rule 92 (fieldsep -> SEMI .)
    SEMI            reduce using rule 92 (fieldsep -> SEMI .)


state 111

    (91) fieldsep -> COMMA .

    LSQUARE         reduce using rule 91 (fieldsep -> COMMA .)
    ID              reduce using rule 91 (fieldsep -> COMMA .)
    RESID           reduce using rule 91 (fieldsep -> COMMA .)
    nil             reduce using rule 91 (fieldsep -> COMMA .)
    false           reduce using rule 91 (fieldsep -> COMMA .)
    true            reduce using rule 91 (fieldsep -> COMMA .)
    STRING          reduce using rule 91 (fieldsep -> COMMA .)
    TRPLDOTS        reduce using rule 91 (fieldsep -> COMMA .)
    function        reduce using rule 91 (fieldsep -> COMMA .)
    INTEGER         reduce using rule 91 (fieldsep -> COMMA .)
    FLOAT           reduce using rule 91 (fieldsep -> COMMA .)
    HEX             reduce using rule 91 (fieldsep -> COMMA .)
    LPAREN          reduce using rule 91 (fieldsep -> COMMA .)
    MINUS           reduce using rule 91 (fieldsep -> COMMA .)
    not             reduce using rule 91 (fieldsep -> COMMA .)
    HASH            reduce using rule 91 (fieldsep -> COMMA .)
    LCURLY          reduce using rule 91 (fieldsep -> COMMA .)
    RCURLY          reduce using rule 91 (fieldsep -> COMMA .)
    COMMA           reduce using rule 91 (fieldsep -> COMMA .)
    SEMI            reduce using rule 91 (fieldsep -> COMMA .)


state 112

    (84) fieldlist -> field fieldseplist . fieldsep
    (85) fieldlist -> field fieldseplist . fieldsep fieldsep
    (91) fieldsep -> . COMMA
    (92) fieldsep -> . SEMI

    COMMA           shift and go to state 111
    SEMI            shift and go to state 110

    fieldsep                       shift and go to state 138

state 113

    (87) fieldseplist -> empty .

    COMMA           reduce using rule 87 (fieldseplist -> empty .)
    SEMI            reduce using rule 87 (fieldseplist -> empty .)


state 114

    (82) tableconstructor -> LCURLY fieldlist RCURLY .

    do              reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    COMMA           reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    PLUS            reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    MINUS           reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    TIMES           reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    DIVIDE          reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    POWER           reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LT              reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LE              reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    GT              reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    GE              reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    NE              reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    CHECKEQ         reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    and             reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    or              reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    MODULO          reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    DBLDOTS         reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    SEMI            reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    nil             reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    false           reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    true            reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    STRING          reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    TRPLDOTS        reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    function        reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    INTEGER         reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    FLOAT           reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    HEX             reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LPAREN          reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    not             reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    HASH            reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LCURLY          reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    ID              reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RESID           reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    then            reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RPAREN          reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RSQUARE         reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    return          reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    break           reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    while           reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    repeat          reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    if              reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    for             reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    local           reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    $end            reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    end             reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    until           reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    else            reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)
    elseif          reduce using rule 82 (tableconstructor -> LCURLY fieldlist RCURLY .)


state 115

    (88) field -> LSQUARE exp . RSQUARE EQUALS exp
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    RSQUARE         shift and go to state 139
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 116

    (55) exp -> exp binop exp .
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for CHECKEQ resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for DBLDOTS resolved as shift
    COMMA           reduce using rule 55 (exp -> exp binop exp .)
    SEMI            reduce using rule 55 (exp -> exp binop exp .)
    then            reduce using rule 55 (exp -> exp binop exp .)
    do              reduce using rule 55 (exp -> exp binop exp .)
    RPAREN          reduce using rule 55 (exp -> exp binop exp .)
    RSQUARE         reduce using rule 55 (exp -> exp binop exp .)
    return          reduce using rule 55 (exp -> exp binop exp .)
    break           reduce using rule 55 (exp -> exp binop exp .)
    while           reduce using rule 55 (exp -> exp binop exp .)
    repeat          reduce using rule 55 (exp -> exp binop exp .)
    if              reduce using rule 55 (exp -> exp binop exp .)
    for             reduce using rule 55 (exp -> exp binop exp .)
    local           reduce using rule 55 (exp -> exp binop exp .)
    function        reduce using rule 55 (exp -> exp binop exp .)
    ID              reduce using rule 55 (exp -> exp binop exp .)
    RESID           reduce using rule 55 (exp -> exp binop exp .)
    LPAREN          reduce using rule 55 (exp -> exp binop exp .)
    $end            reduce using rule 55 (exp -> exp binop exp .)
    end             reduce using rule 55 (exp -> exp binop exp .)
    until           reduce using rule 55 (exp -> exp binop exp .)
    else            reduce using rule 55 (exp -> exp binop exp .)
    elseif          reduce using rule 55 (exp -> exp binop exp .)
    nil             reduce using rule 55 (exp -> exp binop exp .)
    false           reduce using rule 55 (exp -> exp binop exp .)
    true            reduce using rule 55 (exp -> exp binop exp .)
    STRING          reduce using rule 55 (exp -> exp binop exp .)
    TRPLDOTS        reduce using rule 55 (exp -> exp binop exp .)
    INTEGER         reduce using rule 55 (exp -> exp binop exp .)
    FLOAT           reduce using rule 55 (exp -> exp binop exp .)
    HEX             reduce using rule 55 (exp -> exp binop exp .)
    not             reduce using rule 55 (exp -> exp binop exp .)
    HASH            reduce using rule 55 (exp -> exp binop exp .)
    LCURLY          reduce using rule 55 (exp -> exp binop exp .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

  ! PLUS            [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! MINUS           [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! TIMES           [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! DIVIDE          [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! POWER           [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! LT              [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! LE              [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! GT              [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! GE              [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! NE              [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! CHECKEQ         [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! and             [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! or              [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! MODULO          [ reduce using rule 55 (exp -> exp binop exp .) ]
  ! DBLDOTS         [ reduce using rule 55 (exp -> exp binop exp .) ]

    binop                          shift and go to state 70

state 117

    (11) stat -> if exp then block . ifblock else block end
    (12) stat -> if exp then block . ifblock end
    (38) ifblock -> . ifblock elseif exp then block
    (39) ifblock -> . empty
    (61) empty -> .

    else            reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)
    elseif          reduce using rule 61 (empty -> .)

    empty                          shift and go to state 140
    ifblock                        shift and go to state 141

state 118

    (43) var -> prefixexp LSQUARE exp RSQUARE .

    LSQUARE         reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    SDOT            reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    do              reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    PLUS            reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    MINUS           reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    TIMES           reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    DIVIDE          reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    POWER           reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    LT              reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    LE              reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    GT              reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    GE              reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    NE              reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    CHECKEQ         reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    and             reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    or              reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    MODULO          reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    DBLDOTS         reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    COMMA           reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    EQUALS          reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    nil             reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    false           reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    true            reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    STRING          reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    TRPLDOTS        reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    function        reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    INTEGER         reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    FLOAT           reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    HEX             reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    LPAREN          reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    not             reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    HASH            reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    LCURLY          reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    ID              reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    RESID           reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    SEMI            reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    RPAREN          reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    then            reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    RSQUARE         reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    return          reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    break           reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    while           reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    repeat          reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    if              reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    for             reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    local           reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    $end            reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    end             reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    until           reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    else            reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)
    elseif          reduce using rule 43 (var -> prefixexp LSQUARE exp RSQUARE .)


state 119

    (15) stat -> for namelist in explist . do block end

    do              shift and go to state 142


state 120

    (13) stat -> for names EQUALS exp . COMMA exp do block end
    (14) stat -> for names EQUALS exp . COMMA exp COMMA exp do block end
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    COMMA           shift and go to state 143
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 121

    (34) comid -> COMMA names . comid
    (34) comid -> . COMMA names comid
    (35) comid -> . empty
    (61) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 89
    in              reduce using rule 61 (empty -> .)
    EQUALS          reduce using rule 61 (empty -> .)
    SEMI            reduce using rule 61 (empty -> .)
    return          reduce using rule 61 (empty -> .)
    break           reduce using rule 61 (empty -> .)
    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    $end            reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)
    until           reduce using rule 61 (empty -> .)
    else            reduce using rule 61 (empty -> .)
    elseif          reduce using rule 61 (empty -> .)
    RPAREN          reduce using rule 61 (empty -> .)

  ! COMMA           [ reduce using rule 61 (empty -> .) ]

    empty                          shift and go to state 88
    comid                          shift and go to state 144

state 122

    (46) explist -> comexp exp .
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    SEMI            reduce using rule 46 (explist -> comexp exp .)
    return          reduce using rule 46 (explist -> comexp exp .)
    break           reduce using rule 46 (explist -> comexp exp .)
    do              reduce using rule 46 (explist -> comexp exp .)
    while           reduce using rule 46 (explist -> comexp exp .)
    repeat          reduce using rule 46 (explist -> comexp exp .)
    if              reduce using rule 46 (explist -> comexp exp .)
    for             reduce using rule 46 (explist -> comexp exp .)
    local           reduce using rule 46 (explist -> comexp exp .)
    function        reduce using rule 46 (explist -> comexp exp .)
    ID              reduce using rule 46 (explist -> comexp exp .)
    RESID           reduce using rule 46 (explist -> comexp exp .)
    LPAREN          reduce using rule 46 (explist -> comexp exp .)
    $end            reduce using rule 46 (explist -> comexp exp .)
    end             reduce using rule 46 (explist -> comexp exp .)
    until           reduce using rule 46 (explist -> comexp exp .)
    else            reduce using rule 46 (explist -> comexp exp .)
    elseif          reduce using rule 46 (explist -> comexp exp .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 123

    (36) comexp -> COMMA exp . comexp
    (55) exp -> exp . binop exp
    (36) comexp -> . COMMA exp comexp
    (37) comexp -> . empty
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS
    (61) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           shift and go to state 92
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79
    nil             reduce using rule 61 (empty -> .)
    false           reduce using rule 61 (empty -> .)
    true            reduce using rule 61 (empty -> .)
    STRING          reduce using rule 61 (empty -> .)
    TRPLDOTS        reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    INTEGER         reduce using rule 61 (empty -> .)
    FLOAT           reduce using rule 61 (empty -> .)
    HEX             reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    not             reduce using rule 61 (empty -> .)
    HASH            reduce using rule 61 (empty -> .)
    LCURLY          reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)

  ! MINUS           [ reduce using rule 61 (empty -> .) ]

    empty                          shift and go to state 94
    comexp                         shift and go to state 145
    binop                          shift and go to state 70

state 124

    (32) comvar -> COMMA var comvar .

    EQUALS          reduce using rule 32 (comvar -> COMMA var comvar .)


state 125

    (19) stat -> local function names funcbody .

    SEMI            reduce using rule 19 (stat -> local function names funcbody .)
    return          reduce using rule 19 (stat -> local function names funcbody .)
    break           reduce using rule 19 (stat -> local function names funcbody .)
    do              reduce using rule 19 (stat -> local function names funcbody .)
    while           reduce using rule 19 (stat -> local function names funcbody .)
    repeat          reduce using rule 19 (stat -> local function names funcbody .)
    if              reduce using rule 19 (stat -> local function names funcbody .)
    for             reduce using rule 19 (stat -> local function names funcbody .)
    local           reduce using rule 19 (stat -> local function names funcbody .)
    function        reduce using rule 19 (stat -> local function names funcbody .)
    ID              reduce using rule 19 (stat -> local function names funcbody .)
    RESID           reduce using rule 19 (stat -> local function names funcbody .)
    LPAREN          reduce using rule 19 (stat -> local function names funcbody .)
    $end            reduce using rule 19 (stat -> local function names funcbody .)
    end             reduce using rule 19 (stat -> local function names funcbody .)
    until           reduce using rule 19 (stat -> local function names funcbody .)
    else            reduce using rule 19 (stat -> local function names funcbody .)
    elseif          reduce using rule 19 (stat -> local function names funcbody .)


state 126

    (17) stat -> local namelist EQUALS explist .

    SEMI            reduce using rule 17 (stat -> local namelist EQUALS explist .)
    return          reduce using rule 17 (stat -> local namelist EQUALS explist .)
    break           reduce using rule 17 (stat -> local namelist EQUALS explist .)
    do              reduce using rule 17 (stat -> local namelist EQUALS explist .)
    while           reduce using rule 17 (stat -> local namelist EQUALS explist .)
    repeat          reduce using rule 17 (stat -> local namelist EQUALS explist .)
    if              reduce using rule 17 (stat -> local namelist EQUALS explist .)
    for             reduce using rule 17 (stat -> local namelist EQUALS explist .)
    local           reduce using rule 17 (stat -> local namelist EQUALS explist .)
    function        reduce using rule 17 (stat -> local namelist EQUALS explist .)
    ID              reduce using rule 17 (stat -> local namelist EQUALS explist .)
    RESID           reduce using rule 17 (stat -> local namelist EQUALS explist .)
    LPAREN          reduce using rule 17 (stat -> local namelist EQUALS explist .)
    $end            reduce using rule 17 (stat -> local namelist EQUALS explist .)
    end             reduce using rule 17 (stat -> local namelist EQUALS explist .)
    until           reduce using rule 17 (stat -> local namelist EQUALS explist .)
    else            reduce using rule 17 (stat -> local namelist EQUALS explist .)
    elseif          reduce using rule 17 (stat -> local namelist EQUALS explist .)


state 127

    (22) parlist -> namelist .
    (23) parlist -> namelist . COMMA TRPLDOTS

    RPAREN          reduce using rule 22 (parlist -> namelist .)
    COMMA           shift and go to state 146


state 128

    (24) parlist -> TRPLDOTS .

    RPAREN          reduce using rule 24 (parlist -> TRPLDOTS .)


state 129

    (21) funcbody -> LPAREN parlist . RPAREN block end

    RPAREN          shift and go to state 147


state 130

    (20) funcbody -> LPAREN RPAREN . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)

    empty                          shift and go to state 1
    chunk                          shift and go to state 51
    block                          shift and go to state 148

state 131

    (30) dotid -> SDOT names . dotid
    (30) dotid -> . SDOT names dotid
    (31) dotid -> . empty
    (61) empty -> .

    SDOT            shift and go to state 100
    COLON           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)

    dotid                          shift and go to state 149
    empty                          shift and go to state 102

state 132

    (28) funcname -> names dotid COLON .

    LPAREN          reduce using rule 28 (funcname -> names dotid COLON .)


state 133

    (4) chunk -> chunk stat SEMI laststat SEMI .

    do              reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    while           reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    repeat          reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    if              reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    for             reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    local           reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    function        reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    ID              reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    RESID           reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    LPAREN          reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    end             reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    $end            reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    else            reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    elseif          reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)
    until           reduce using rule 4 (chunk -> chunk stat SEMI laststat SEMI .)


state 134

    (10) stat -> repeat block until exp .
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    SEMI            reduce using rule 10 (stat -> repeat block until exp .)
    return          reduce using rule 10 (stat -> repeat block until exp .)
    break           reduce using rule 10 (stat -> repeat block until exp .)
    do              reduce using rule 10 (stat -> repeat block until exp .)
    while           reduce using rule 10 (stat -> repeat block until exp .)
    repeat          reduce using rule 10 (stat -> repeat block until exp .)
    if              reduce using rule 10 (stat -> repeat block until exp .)
    for             reduce using rule 10 (stat -> repeat block until exp .)
    local           reduce using rule 10 (stat -> repeat block until exp .)
    function        reduce using rule 10 (stat -> repeat block until exp .)
    ID              reduce using rule 10 (stat -> repeat block until exp .)
    RESID           reduce using rule 10 (stat -> repeat block until exp .)
    LPAREN          reduce using rule 10 (stat -> repeat block until exp .)
    $end            reduce using rule 10 (stat -> repeat block until exp .)
    end             reduce using rule 10 (stat -> repeat block until exp .)
    until           reduce using rule 10 (stat -> repeat block until exp .)
    else            reduce using rule 10 (stat -> repeat block until exp .)
    elseif          reduce using rule 10 (stat -> repeat block until exp .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 135

    (9) stat -> while exp do block . end

    end             shift and go to state 150


state 136

    (89) field -> names EQUALS exp .
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    COMMA           reduce using rule 89 (field -> names EQUALS exp .)
    SEMI            reduce using rule 89 (field -> names EQUALS exp .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 137

    (86) fieldseplist -> fieldsep field . fieldseplist
    (86) fieldseplist -> . fieldsep field fieldseplist
    (87) fieldseplist -> . empty
    (91) fieldsep -> . COMMA
    (92) fieldsep -> . SEMI
    (61) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for SEMI resolved as shift
    COMMA           shift and go to state 111
    SEMI            shift and go to state 110

  ! COMMA           [ reduce using rule 61 (empty -> .) ]
  ! SEMI            [ reduce using rule 61 (empty -> .) ]

    fieldsep                       shift and go to state 109
    fieldseplist                   shift and go to state 151
    empty                          shift and go to state 113

state 138

    (84) fieldlist -> field fieldseplist fieldsep .
    (85) fieldlist -> field fieldseplist fieldsep . fieldsep
    (91) fieldsep -> . COMMA
    (92) fieldsep -> . SEMI

    RCURLY          reduce using rule 84 (fieldlist -> field fieldseplist fieldsep .)
    COMMA           shift and go to state 111
    SEMI            shift and go to state 110

    fieldsep                       shift and go to state 152

state 139

    (88) field -> LSQUARE exp RSQUARE . EQUALS exp

    EQUALS          shift and go to state 153


state 140

    (39) ifblock -> empty .

    else            reduce using rule 39 (ifblock -> empty .)
    end             reduce using rule 39 (ifblock -> empty .)
    elseif          reduce using rule 39 (ifblock -> empty .)


state 141

    (11) stat -> if exp then block ifblock . else block end
    (12) stat -> if exp then block ifblock . end
    (38) ifblock -> ifblock . elseif exp then block

    else            shift and go to state 155
    end             shift and go to state 154
    elseif          shift and go to state 156


state 142

    (15) stat -> for namelist in explist do . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 157

state 143

    (13) stat -> for names EQUALS exp COMMA . exp do block end
    (14) stat -> for names EQUALS exp COMMA . exp COMMA exp do block end
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    names                          shift and go to state 5
    exp                            shift and go to state 158
    var                            shift and go to state 25

state 144

    (34) comid -> COMMA names comid .

    EQUALS          reduce using rule 34 (comid -> COMMA names comid .)
    SEMI            reduce using rule 34 (comid -> COMMA names comid .)
    return          reduce using rule 34 (comid -> COMMA names comid .)
    break           reduce using rule 34 (comid -> COMMA names comid .)
    do              reduce using rule 34 (comid -> COMMA names comid .)
    while           reduce using rule 34 (comid -> COMMA names comid .)
    repeat          reduce using rule 34 (comid -> COMMA names comid .)
    if              reduce using rule 34 (comid -> COMMA names comid .)
    for             reduce using rule 34 (comid -> COMMA names comid .)
    local           reduce using rule 34 (comid -> COMMA names comid .)
    function        reduce using rule 34 (comid -> COMMA names comid .)
    ID              reduce using rule 34 (comid -> COMMA names comid .)
    RESID           reduce using rule 34 (comid -> COMMA names comid .)
    LPAREN          reduce using rule 34 (comid -> COMMA names comid .)
    $end            reduce using rule 34 (comid -> COMMA names comid .)
    end             reduce using rule 34 (comid -> COMMA names comid .)
    until           reduce using rule 34 (comid -> COMMA names comid .)
    else            reduce using rule 34 (comid -> COMMA names comid .)
    elseif          reduce using rule 34 (comid -> COMMA names comid .)
    COMMA           reduce using rule 34 (comid -> COMMA names comid .)
    RPAREN          reduce using rule 34 (comid -> COMMA names comid .)
    in              reduce using rule 34 (comid -> COMMA names comid .)


state 145

    (36) comexp -> COMMA exp comexp .

    nil             reduce using rule 36 (comexp -> COMMA exp comexp .)
    false           reduce using rule 36 (comexp -> COMMA exp comexp .)
    true            reduce using rule 36 (comexp -> COMMA exp comexp .)
    STRING          reduce using rule 36 (comexp -> COMMA exp comexp .)
    TRPLDOTS        reduce using rule 36 (comexp -> COMMA exp comexp .)
    function        reduce using rule 36 (comexp -> COMMA exp comexp .)
    INTEGER         reduce using rule 36 (comexp -> COMMA exp comexp .)
    FLOAT           reduce using rule 36 (comexp -> COMMA exp comexp .)
    HEX             reduce using rule 36 (comexp -> COMMA exp comexp .)
    LPAREN          reduce using rule 36 (comexp -> COMMA exp comexp .)
    MINUS           reduce using rule 36 (comexp -> COMMA exp comexp .)
    not             reduce using rule 36 (comexp -> COMMA exp comexp .)
    HASH            reduce using rule 36 (comexp -> COMMA exp comexp .)
    LCURLY          reduce using rule 36 (comexp -> COMMA exp comexp .)
    ID              reduce using rule 36 (comexp -> COMMA exp comexp .)
    RESID           reduce using rule 36 (comexp -> COMMA exp comexp .)


state 146

    (23) parlist -> namelist COMMA . TRPLDOTS

    TRPLDOTS        shift and go to state 159


state 147

    (21) funcbody -> LPAREN parlist RPAREN . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 160

state 148

    (20) funcbody -> LPAREN RPAREN block . end

    end             shift and go to state 161


state 149

    (30) dotid -> SDOT names dotid .

    COLON           reduce using rule 30 (dotid -> SDOT names dotid .)
    LPAREN          reduce using rule 30 (dotid -> SDOT names dotid .)


state 150

    (9) stat -> while exp do block end .

    SEMI            reduce using rule 9 (stat -> while exp do block end .)
    return          reduce using rule 9 (stat -> while exp do block end .)
    break           reduce using rule 9 (stat -> while exp do block end .)
    do              reduce using rule 9 (stat -> while exp do block end .)
    while           reduce using rule 9 (stat -> while exp do block end .)
    repeat          reduce using rule 9 (stat -> while exp do block end .)
    if              reduce using rule 9 (stat -> while exp do block end .)
    for             reduce using rule 9 (stat -> while exp do block end .)
    local           reduce using rule 9 (stat -> while exp do block end .)
    function        reduce using rule 9 (stat -> while exp do block end .)
    ID              reduce using rule 9 (stat -> while exp do block end .)
    RESID           reduce using rule 9 (stat -> while exp do block end .)
    LPAREN          reduce using rule 9 (stat -> while exp do block end .)
    $end            reduce using rule 9 (stat -> while exp do block end .)
    end             reduce using rule 9 (stat -> while exp do block end .)
    until           reduce using rule 9 (stat -> while exp do block end .)
    else            reduce using rule 9 (stat -> while exp do block end .)
    elseif          reduce using rule 9 (stat -> while exp do block end .)


state 151

    (86) fieldseplist -> fieldsep field fieldseplist .

    COMMA           reduce using rule 86 (fieldseplist -> fieldsep field fieldseplist .)
    SEMI            reduce using rule 86 (fieldseplist -> fieldsep field fieldseplist .)


state 152

    (85) fieldlist -> field fieldseplist fieldsep fieldsep .

    RCURLY          reduce using rule 85 (fieldlist -> field fieldseplist fieldsep fieldsep .)


state 153

    (88) field -> LSQUARE exp RSQUARE EQUALS . exp
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 162
    var                            shift and go to state 25
    names                          shift and go to state 5

state 154

    (12) stat -> if exp then block ifblock end .

    SEMI            reduce using rule 12 (stat -> if exp then block ifblock end .)
    return          reduce using rule 12 (stat -> if exp then block ifblock end .)
    break           reduce using rule 12 (stat -> if exp then block ifblock end .)
    do              reduce using rule 12 (stat -> if exp then block ifblock end .)
    while           reduce using rule 12 (stat -> if exp then block ifblock end .)
    repeat          reduce using rule 12 (stat -> if exp then block ifblock end .)
    if              reduce using rule 12 (stat -> if exp then block ifblock end .)
    for             reduce using rule 12 (stat -> if exp then block ifblock end .)
    local           reduce using rule 12 (stat -> if exp then block ifblock end .)
    function        reduce using rule 12 (stat -> if exp then block ifblock end .)
    ID              reduce using rule 12 (stat -> if exp then block ifblock end .)
    RESID           reduce using rule 12 (stat -> if exp then block ifblock end .)
    LPAREN          reduce using rule 12 (stat -> if exp then block ifblock end .)
    $end            reduce using rule 12 (stat -> if exp then block ifblock end .)
    end             reduce using rule 12 (stat -> if exp then block ifblock end .)
    until           reduce using rule 12 (stat -> if exp then block ifblock end .)
    else            reduce using rule 12 (stat -> if exp then block ifblock end .)
    elseif          reduce using rule 12 (stat -> if exp then block ifblock end .)


state 155

    (11) stat -> if exp then block ifblock else . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 163

state 156

    (38) ifblock -> ifblock elseif . exp then block
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    exp                            shift and go to state 164
    var                            shift and go to state 25
    names                          shift and go to state 5

state 157

    (15) stat -> for namelist in explist do block . end

    end             shift and go to state 165


state 158

    (13) stat -> for names EQUALS exp COMMA exp . do block end
    (14) stat -> for names EQUALS exp COMMA exp . COMMA exp do block end
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    do              shift and go to state 167
    COMMA           shift and go to state 166
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 159

    (23) parlist -> namelist COMMA TRPLDOTS .

    RPAREN          reduce using rule 23 (parlist -> namelist COMMA TRPLDOTS .)


state 160

    (21) funcbody -> LPAREN parlist RPAREN block . end

    end             shift and go to state 168


state 161

    (20) funcbody -> LPAREN RPAREN block end .

    SEMI            reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    return          reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    break           reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    do              reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    while           reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    repeat          reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    if              reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    for             reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    local           reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    function        reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    ID              reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    RESID           reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    LPAREN          reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    $end            reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    end             reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    until           reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    else            reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)
    elseif          reduce using rule 20 (funcbody -> LPAREN RPAREN block end .)


state 162

    (88) field -> LSQUARE exp RSQUARE EQUALS exp .
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    COMMA           reduce using rule 88 (field -> LSQUARE exp RSQUARE EQUALS exp .)
    SEMI            reduce using rule 88 (field -> LSQUARE exp RSQUARE EQUALS exp .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 163

    (11) stat -> if exp then block ifblock else block . end

    end             shift and go to state 169


state 164

    (38) ifblock -> ifblock elseif exp . then block
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    then            shift and go to state 170
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 165

    (15) stat -> for namelist in explist do block end .

    SEMI            reduce using rule 15 (stat -> for namelist in explist do block end .)
    return          reduce using rule 15 (stat -> for namelist in explist do block end .)
    break           reduce using rule 15 (stat -> for namelist in explist do block end .)
    do              reduce using rule 15 (stat -> for namelist in explist do block end .)
    while           reduce using rule 15 (stat -> for namelist in explist do block end .)
    repeat          reduce using rule 15 (stat -> for namelist in explist do block end .)
    if              reduce using rule 15 (stat -> for namelist in explist do block end .)
    for             reduce using rule 15 (stat -> for namelist in explist do block end .)
    local           reduce using rule 15 (stat -> for namelist in explist do block end .)
    function        reduce using rule 15 (stat -> for namelist in explist do block end .)
    ID              reduce using rule 15 (stat -> for namelist in explist do block end .)
    RESID           reduce using rule 15 (stat -> for namelist in explist do block end .)
    LPAREN          reduce using rule 15 (stat -> for namelist in explist do block end .)
    $end            reduce using rule 15 (stat -> for namelist in explist do block end .)
    end             reduce using rule 15 (stat -> for namelist in explist do block end .)
    until           reduce using rule 15 (stat -> for namelist in explist do block end .)
    else            reduce using rule 15 (stat -> for namelist in explist do block end .)
    elseif          reduce using rule 15 (stat -> for namelist in explist do block end .)


state 166

    (14) stat -> for names EQUALS exp COMMA exp COMMA . exp do block end
    (47) exp -> . nil
    (48) exp -> . false
    (49) exp -> . true
    (50) exp -> . Number
    (51) exp -> . STRING
    (52) exp -> . TRPLDOTS
    (53) exp -> . function
    (54) exp -> . prefixexp
    (55) exp -> . exp binop exp
    (56) exp -> . unop exp
    (57) exp -> . tableconstructor
    (58) Number -> . INTEGER
    (59) Number -> . FLOAT
    (60) Number -> . HEX
    (62) prefixexp -> . var
    (63) prefixexp -> . LPAREN exp RPAREN
    (79) unop -> . MINUS
    (80) unop -> . not
    (81) unop -> . HASH
    (82) tableconstructor -> . LCURLY fieldlist RCURLY
    (83) tableconstructor -> . LCURLY RCURLY
    (41) var -> . names
    (42) var -> . prefixexp
    (43) var -> . prefixexp LSQUARE exp RSQUARE
    (44) var -> . prefixexp SDOT names
    (93) names -> . ID
    (94) names -> . RESID

    nil             shift and go to state 30
    false           shift and go to state 20
    true            shift and go to state 33
    STRING          shift and go to state 23
    TRPLDOTS        shift and go to state 29
    function        shift and go to state 27
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 34
    HEX             shift and go to state 31
    LPAREN          shift and go to state 4
    MINUS           shift and go to state 22
    not             shift and go to state 32
    HASH            shift and go to state 28
    LCURLY          shift and go to state 21
    ID              shift and go to state 16
    RESID           shift and go to state 3

    prefixexp                      shift and go to state 24
    unop                           shift and go to state 19
    tableconstructor               shift and go to state 18
    Number                         shift and go to state 35
    names                          shift and go to state 5
    exp                            shift and go to state 171
    var                            shift and go to state 25

state 167

    (13) stat -> for names EQUALS exp COMMA exp do . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 172

state 168

    (21) funcbody -> LPAREN parlist RPAREN block end .

    SEMI            reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    return          reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    break           reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    do              reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    while           reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    repeat          reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    if              reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    for             reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    local           reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    function        reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    ID              reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    RESID           reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    LPAREN          reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    $end            reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    end             reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    until           reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    else            reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)
    elseif          reduce using rule 21 (funcbody -> LPAREN parlist RPAREN block end .)


state 169

    (11) stat -> if exp then block ifblock else block end .

    SEMI            reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    return          reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    break           reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    do              reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    while           reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    repeat          reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    if              reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    for             reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    local           reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    function        reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    ID              reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    RESID           reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    LPAREN          reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    $end            reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    end             reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    until           reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    else            reduce using rule 11 (stat -> if exp then block ifblock else block end .)
    elseif          reduce using rule 11 (stat -> if exp then block ifblock else block end .)


state 170

    (38) ifblock -> ifblock elseif exp then . block
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    else            reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)
    elseif          reduce using rule 61 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 173

state 171

    (14) stat -> for names EQUALS exp COMMA exp COMMA exp . do block end
    (55) exp -> exp . binop exp
    (64) binop -> . PLUS
    (65) binop -> . MINUS
    (66) binop -> . TIMES
    (67) binop -> . DIVIDE
    (68) binop -> . POWER
    (69) binop -> . LT
    (70) binop -> . LE
    (71) binop -> . GT
    (72) binop -> . GE
    (73) binop -> . NE
    (74) binop -> . CHECKEQ
    (75) binop -> . and
    (76) binop -> . or
    (77) binop -> . MODULO
    (78) binop -> . DBLDOTS

    do              shift and go to state 174
    PLUS            shift and go to state 77
    MINUS           shift and go to state 80
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 82
    POWER           shift and go to state 69
    LT              shift and go to state 75
    LE              shift and go to state 67
    GT              shift and go to state 76
    GE              shift and go to state 72
    NE              shift and go to state 81
    CHECKEQ         shift and go to state 74
    and             shift and go to state 66
    or              shift and go to state 71
    MODULO          shift and go to state 78
    DBLDOTS         shift and go to state 79

    binop                          shift and go to state 70

state 172

    (13) stat -> for names EQUALS exp COMMA exp do block . end

    end             shift and go to state 175


state 173

    (38) ifblock -> ifblock elseif exp then block .

    else            reduce using rule 38 (ifblock -> ifblock elseif exp then block .)
    end             reduce using rule 38 (ifblock -> ifblock elseif exp then block .)
    elseif          reduce using rule 38 (ifblock -> ifblock elseif exp then block .)


state 174

    (14) stat -> for names EQUALS exp COMMA exp COMMA exp do . block end
    (6) block -> . chunk
    (1) chunk -> . chunk stat
    (2) chunk -> . chunk stat SEMI
    (3) chunk -> . chunk stat laststat
    (4) chunk -> . chunk stat SEMI laststat SEMI
    (5) chunk -> . empty
    (61) empty -> .

    do              reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    repeat          reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    local           reduce using rule 61 (empty -> .)
    function        reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    RESID           reduce using rule 61 (empty -> .)
    LPAREN          reduce using rule 61 (empty -> .)
    end             reduce using rule 61 (empty -> .)

    chunk                          shift and go to state 51
    empty                          shift and go to state 1
    block                          shift and go to state 176

state 175

    (13) stat -> for names EQUALS exp COMMA exp do block end .

    SEMI            reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    return          reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    break           reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    do              reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    while           reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    repeat          reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    if              reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    for             reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    local           reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    function        reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    ID              reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    RESID           reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    LPAREN          reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    $end            reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    end             reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    until           reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    else            reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)
    elseif          reduce using rule 13 (stat -> for names EQUALS exp COMMA exp do block end .)


state 176

    (14) stat -> for names EQUALS exp COMMA exp COMMA exp do block . end

    end             shift and go to state 177


state 177

    (14) stat -> for names EQUALS exp COMMA exp COMMA exp do block end .

    SEMI            reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    return          reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    break           reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    do              reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    while           reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    repeat          reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    if              reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    for             reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    local           reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    function        reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    ID              reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    RESID           reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    LPAREN          reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    $end            reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    end             reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    until           reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    else            reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    elseif          reduce using rule 14 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LSQUARE in state 7 resolved as shift
WARNING: shift/reduce conflict for SDOT in state 7 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 10 resolved as shift
WARNING: shift/reduce conflict for LSQUARE in state 24 resolved as shift
WARNING: shift/reduce conflict for SDOT in state 24 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 48 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 59 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 59 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 59 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 59 resolved as shift
WARNING: shift/reduce conflict for POWER in state 59 resolved as shift
WARNING: shift/reduce conflict for LT in state 59 resolved as shift
WARNING: shift/reduce conflict for LE in state 59 resolved as shift
WARNING: shift/reduce conflict for GT in state 59 resolved as shift
WARNING: shift/reduce conflict for GE in state 59 resolved as shift
WARNING: shift/reduce conflict for NE in state 59 resolved as shift
WARNING: shift/reduce conflict for CHECKEQ in state 59 resolved as shift
WARNING: shift/reduce conflict for and in state 59 resolved as shift
WARNING: shift/reduce conflict for or in state 59 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 59 resolved as shift
WARNING: shift/reduce conflict for DBLDOTS in state 59 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 62 resolved as shift
WARNING: shift/reduce conflict for SEMI in state 62 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 95 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 116 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for POWER in state 116 resolved as shift
WARNING: shift/reduce conflict for LT in state 116 resolved as shift
WARNING: shift/reduce conflict for LE in state 116 resolved as shift
WARNING: shift/reduce conflict for GT in state 116 resolved as shift
WARNING: shift/reduce conflict for GE in state 116 resolved as shift
WARNING: shift/reduce conflict for NE in state 116 resolved as shift
WARNING: shift/reduce conflict for CHECKEQ in state 116 resolved as shift
WARNING: shift/reduce conflict for and in state 116 resolved as shift
WARNING: shift/reduce conflict for or in state 116 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 116 resolved as shift
WARNING: shift/reduce conflict for DBLDOTS in state 116 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 123 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 137 resolved as shift
WARNING: shift/reduce conflict for SEMI in state 137 resolved as shift
WARNING: reduce/reduce conflict in state 10 resolved using rule (empty -> <empty>)
WARNING: rejected rule (prefixexp -> var) in state 10
WARNING: reduce/reduce conflict in state 24 resolved using rule (var -> prefixexp)
WARNING: rejected rule (exp -> prefixexp) in state 24
WARNING: reduce/reduce conflict in state 53 resolved using rule (laststat -> return)
WARNING: rejected rule (empty -> <empty>) in state 53
WARNING: reduce/reduce conflict in state 95 resolved using rule (empty -> <empty>)
WARNING: rejected rule (prefixexp -> var) in state 95
WARNING: Rule (exp -> prefixexp) is never reduced
