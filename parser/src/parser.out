Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    NEWLINE
    TDASH

Grammar

Rule 0     S' -> sdash
Rule 1     sdash -> chunk
Rule 2     sdash -> chunk laststat
Rule 3     sdash -> chunk laststat SEMI
Rule 4     chunk -> chunk stat
Rule 5     chunk -> chunk stat SEMI
Rule 6     chunk -> stat
Rule 7     chunk -> stat SEMI
Rule 8     block -> sdash
Rule 9     stat -> varlist EQUALS explist
Rule 10    stat -> do block end
Rule 11    stat -> functioncall
Rule 12    stat -> while exp do block end
Rule 13    stat -> repeat block until exp
Rule 14    stat -> if exp then block ifblock else block end
Rule 15    stat -> if exp then block ifblock end
Rule 16    stat -> for names EQUALS exp COMMA exp do block end
Rule 17    stat -> for names EQUALS exp COMMA exp COMMA exp do block end
Rule 18    stat -> for namelist in explist do block end
Rule 19    stat -> local namelist
Rule 20    stat -> local namelist EQUALS explist
Rule 21    stat -> function funcname funcbody
Rule 22    stat -> local function names funcbody
Rule 23    funcbody -> LPAREN RPAREN block end
Rule 24    funcbody -> LPAREN parlist RPAREN block end
Rule 25    functioncall -> prefixexp args
Rule 26    args -> LPAREN RPAREN
Rule 27    args -> LPAREN explist RPAREN
Rule 28    args -> tableconstructor
Rule 29    args -> STRING
Rule 30    parlist -> namelist
Rule 31    parlist -> namelist comtrp
Rule 32    parlist -> TRPLDOTS
Rule 33    comtrp -> COMMA TRPLDOTS
Rule 34    laststat -> return explist
Rule 35    laststat -> return
Rule 36    laststat -> break
Rule 37    funcname -> names dotid COLON
Rule 38    funcname -> names
Rule 39    dotid -> SDOT names dotid
Rule 40    dotid -> empty
Rule 41    comvar -> COMMA var comvar
Rule 42    comvar -> empty
Rule 43    comid -> COMMA names comid
Rule 44    comid -> empty
Rule 45    ifblock -> ifblock elseif exp then block
Rule 46    ifblock -> empty
Rule 47    varlist -> var comvar
Rule 48    var -> names
Rule 49    var -> prefixexp LSQUARE exp RSQUARE
Rule 50    var -> prefixexp SDOT names
Rule 51    namelist -> names comid
Rule 52    explist -> explist COMMA exp
Rule 53    explist -> exp
Rule 54    exp -> nil
Rule 55    exp -> false
Rule 56    exp -> true
Rule 57    exp -> Number
Rule 58    exp -> STRING
Rule 59    exp -> TRPLDOTS
Rule 60    exp -> function
Rule 61    exp -> prefixexp
Rule 62    exp -> exp PLUS exp
Rule 63    exp -> exp MINUS exp
Rule 64    exp -> exp TIMES exp
Rule 65    exp -> exp DIVIDE exp
Rule 66    exp -> exp POWER exp
Rule 67    exp -> exp LT exp
Rule 68    exp -> exp LE exp
Rule 69    exp -> exp GT exp
Rule 70    exp -> exp GE exp
Rule 71    exp -> exp NE exp
Rule 72    exp -> exp CHECKEQ exp
Rule 73    exp -> exp and exp
Rule 74    exp -> exp or exp
Rule 75    exp -> exp MODULO exp
Rule 76    exp -> exp DBLDOTS exp
Rule 77    exp -> tableconstructor
Rule 78    exp -> unop exp
Rule 79    Number -> INTEGER
Rule 80    Number -> FLOAT
Rule 81    Number -> HEX
Rule 82    empty -> <empty>
Rule 83    prefixexp -> var
Rule 84    prefixexp -> LPAREN exp RPAREN
Rule 85    prefixexp -> functioncall
Rule 86    unop -> MINUS
Rule 87    unop -> not
Rule 88    unop -> HASH
Rule 89    tableconstructor -> LCURLY fieldlist RCURLY
Rule 90    tableconstructor -> LCURLY RCURLY
Rule 91    fieldlist -> field fieldseplist fieldsep
Rule 92    fieldlist -> field fieldseplist
Rule 93    fieldseplist -> fieldseplist fieldsep field
Rule 94    fieldseplist -> empty
Rule 95    field -> LSQUARE exp RSQUARE EQUALS exp
Rule 96    field -> names EQUALS exp
Rule 97    field -> exp
Rule 98    fieldsep -> COMMA
Rule 99    fieldsep -> SEMI
Rule 100   names -> ID
Rule 101   names -> RESID

Terminals, with rules where they appear

CHECKEQ              : 72
COLON                : 37
COMMA                : 16 17 17 33 41 43 52 98
DBLDOTS              : 76
DIVIDE               : 65
EQUALS               : 9 16 17 20 95 96
FLOAT                : 80
GE                   : 70
GT                   : 69
HASH                 : 88
HEX                  : 81
ID                   : 100
INTEGER              : 79
LCURLY               : 89 90
LE                   : 68
LPAREN               : 23 24 26 27 84
LSQUARE              : 49 95
LT                   : 67
MINUS                : 63 86
MODULO               : 75
NE                   : 71
NEWLINE              : 
PLUS                 : 62
POWER                : 66
RCURLY               : 89 90
RESID                : 101
RPAREN               : 23 24 26 27 84
RSQUARE              : 49 95
SDOT                 : 39 50
SEMI                 : 3 5 7 99
STRING               : 29 58
TDASH                : 
TIMES                : 64
TRPLDOTS             : 32 33 59
and                  : 73
break                : 36
do                   : 10 12 16 17 18
else                 : 14
elseif               : 45
end                  : 10 12 14 15 16 17 18 23 24
error                : 
false                : 55
for                  : 16 17 18
function             : 21 22 60
if                   : 14 15
in                   : 18
local                : 19 20 22
nil                  : 54
not                  : 87
or                   : 74
repeat               : 13
return               : 34 35
then                 : 14 15 45
true                 : 56
until                : 13
while                : 12

Nonterminals, with rules where they appear

Number               : 57
args                 : 25
block                : 10 12 13 14 14 15 16 17 18 23 24 45
chunk                : 1 2 3 4 5
comid                : 43 51
comtrp               : 31
comvar               : 41 47
dotid                : 37 39
empty                : 40 42 44 46 94
exp                  : 12 13 14 15 16 16 17 17 17 45 49 52 53 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 74 75 75 76 76 78 84 95 95 96 97
explist              : 9 18 20 27 34 52
field                : 91 92 93
fieldlist            : 89
fieldsep             : 91 93
fieldseplist         : 91 92 93
funcbody             : 21 22
funcname             : 21
functioncall         : 11 85
ifblock              : 14 15 45
laststat             : 2 3
namelist             : 18 19 20 30 31
names                : 16 17 22 37 38 39 43 48 50 51 96
parlist              : 24
prefixexp            : 25 49 50 61
sdash                : 8 0
stat                 : 4 5 6 7
tableconstructor     : 28 77
unop                 : 78
var                  : 41 47 83
varlist              : 9

Parsing method: LALR

state 0

    (0) S' -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    var                            shift and go to state 9
    sdash                          shift and go to state 18
    names                          shift and go to state 4

state 1

    (101) names -> RESID .

    COMMA           reduce using rule 101 (names -> RESID .)
    EQUALS          reduce using rule 101 (names -> RESID .)
    LSQUARE         reduce using rule 101 (names -> RESID .)
    SDOT            reduce using rule 101 (names -> RESID .)
    LPAREN          reduce using rule 101 (names -> RESID .)
    STRING          reduce using rule 101 (names -> RESID .)
    LCURLY          reduce using rule 101 (names -> RESID .)
    PLUS            reduce using rule 101 (names -> RESID .)
    MINUS           reduce using rule 101 (names -> RESID .)
    TIMES           reduce using rule 101 (names -> RESID .)
    DIVIDE          reduce using rule 101 (names -> RESID .)
    POWER           reduce using rule 101 (names -> RESID .)
    LT              reduce using rule 101 (names -> RESID .)
    LE              reduce using rule 101 (names -> RESID .)
    GT              reduce using rule 101 (names -> RESID .)
    GE              reduce using rule 101 (names -> RESID .)
    NE              reduce using rule 101 (names -> RESID .)
    CHECKEQ         reduce using rule 101 (names -> RESID .)
    and             reduce using rule 101 (names -> RESID .)
    or              reduce using rule 101 (names -> RESID .)
    MODULO          reduce using rule 101 (names -> RESID .)
    DBLDOTS         reduce using rule 101 (names -> RESID .)
    do              reduce using rule 101 (names -> RESID .)
    SEMI            reduce using rule 101 (names -> RESID .)
    return          reduce using rule 101 (names -> RESID .)
    break           reduce using rule 101 (names -> RESID .)
    while           reduce using rule 101 (names -> RESID .)
    repeat          reduce using rule 101 (names -> RESID .)
    if              reduce using rule 101 (names -> RESID .)
    for             reduce using rule 101 (names -> RESID .)
    local           reduce using rule 101 (names -> RESID .)
    function        reduce using rule 101 (names -> RESID .)
    ID              reduce using rule 101 (names -> RESID .)
    RESID           reduce using rule 101 (names -> RESID .)
    $end            reduce using rule 101 (names -> RESID .)
    end             reduce using rule 101 (names -> RESID .)
    until           reduce using rule 101 (names -> RESID .)
    else            reduce using rule 101 (names -> RESID .)
    elseif          reduce using rule 101 (names -> RESID .)
    RPAREN          reduce using rule 101 (names -> RESID .)
    then            reduce using rule 101 (names -> RESID .)
    RCURLY          reduce using rule 101 (names -> RESID .)
    RSQUARE         reduce using rule 101 (names -> RESID .)
    in              reduce using rule 101 (names -> RESID .)
    COLON           reduce using rule 101 (names -> RESID .)


state 2

    (84) prefixexp -> LPAREN . exp RPAREN
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 36
    var                            shift and go to state 26
    names                          shift and go to state 4

state 3

    (1) sdash -> chunk .
    (2) sdash -> chunk . laststat
    (3) sdash -> chunk . laststat SEMI
    (4) chunk -> chunk . stat
    (5) chunk -> chunk . stat SEMI
    (34) laststat -> . return explist
    (35) laststat -> . return
    (36) laststat -> . break
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    else            reduce using rule 1 (sdash -> chunk .)
    end             reduce using rule 1 (sdash -> chunk .)
    elseif          reduce using rule 1 (sdash -> chunk .)
    $end            reduce using rule 1 (sdash -> chunk .)
    until           reduce using rule 1 (sdash -> chunk .)
    return          shift and go to state 41
    break           shift and go to state 42
    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 40
    varlist                        shift and go to state 8
    laststat                       shift and go to state 39
    functioncall                   shift and go to state 17
    names                          shift and go to state 4
    var                            shift and go to state 9

state 4

    (48) var -> names .

    COMMA           reduce using rule 48 (var -> names .)
    EQUALS          reduce using rule 48 (var -> names .)
    LSQUARE         reduce using rule 48 (var -> names .)
    SDOT            reduce using rule 48 (var -> names .)
    LPAREN          reduce using rule 48 (var -> names .)
    STRING          reduce using rule 48 (var -> names .)
    LCURLY          reduce using rule 48 (var -> names .)
    then            reduce using rule 48 (var -> names .)
    PLUS            reduce using rule 48 (var -> names .)
    MINUS           reduce using rule 48 (var -> names .)
    TIMES           reduce using rule 48 (var -> names .)
    DIVIDE          reduce using rule 48 (var -> names .)
    POWER           reduce using rule 48 (var -> names .)
    LT              reduce using rule 48 (var -> names .)
    LE              reduce using rule 48 (var -> names .)
    GT              reduce using rule 48 (var -> names .)
    GE              reduce using rule 48 (var -> names .)
    NE              reduce using rule 48 (var -> names .)
    CHECKEQ         reduce using rule 48 (var -> names .)
    and             reduce using rule 48 (var -> names .)
    or              reduce using rule 48 (var -> names .)
    MODULO          reduce using rule 48 (var -> names .)
    DBLDOTS         reduce using rule 48 (var -> names .)
    do              reduce using rule 48 (var -> names .)
    SEMI            reduce using rule 48 (var -> names .)
    RCURLY          reduce using rule 48 (var -> names .)
    RPAREN          reduce using rule 48 (var -> names .)
    $end            reduce using rule 48 (var -> names .)
    end             reduce using rule 48 (var -> names .)
    until           reduce using rule 48 (var -> names .)
    else            reduce using rule 48 (var -> names .)
    elseif          reduce using rule 48 (var -> names .)
    RSQUARE         reduce using rule 48 (var -> names .)
    return          reduce using rule 48 (var -> names .)
    break           reduce using rule 48 (var -> names .)
    while           reduce using rule 48 (var -> names .)
    repeat          reduce using rule 48 (var -> names .)
    if              reduce using rule 48 (var -> names .)
    for             reduce using rule 48 (var -> names .)
    local           reduce using rule 48 (var -> names .)
    function        reduce using rule 48 (var -> names .)
    ID              reduce using rule 48 (var -> names .)
    RESID           reduce using rule 48 (var -> names .)


state 5

    (14) stat -> if . exp then block ifblock else block end
    (15) stat -> if . exp then block ifblock end
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 43
    var                            shift and go to state 26
    names                          shift and go to state 4

state 6

    (25) functioncall -> prefixexp . args
    (49) var -> prefixexp . LSQUARE exp RSQUARE
    (50) var -> prefixexp . SDOT names
    (26) args -> . LPAREN RPAREN
    (27) args -> . LPAREN explist RPAREN
    (28) args -> . tableconstructor
    (29) args -> . STRING
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY

    LSQUARE         shift and go to state 45
    SDOT            shift and go to state 48
    LPAREN          shift and go to state 47
    STRING          shift and go to state 49
    LCURLY          shift and go to state 21

    tableconstructor               shift and go to state 44
    args                           shift and go to state 46

state 7

    (16) stat -> for . names EQUALS exp COMMA exp do block end
    (17) stat -> for . names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> for . namelist in explist do block end
    (100) names -> . ID
    (101) names -> . RESID
    (51) namelist -> . names comid

    ID              shift and go to state 15
    RESID           shift and go to state 1

    namelist                       shift and go to state 50
    names                          shift and go to state 51

state 8

    (9) stat -> varlist . EQUALS explist

    EQUALS          shift and go to state 52


state 9

    (47) varlist -> var . comvar
    (83) prefixexp -> var .
    (41) comvar -> . COMMA var comvar
    (42) comvar -> . empty
    (82) empty -> .

    LSQUARE         reduce using rule 83 (prefixexp -> var .)
    SDOT            reduce using rule 83 (prefixexp -> var .)
    LPAREN          reduce using rule 83 (prefixexp -> var .)
    STRING          reduce using rule 83 (prefixexp -> var .)
    LCURLY          reduce using rule 83 (prefixexp -> var .)
    COMMA           shift and go to state 53
    EQUALS          reduce using rule 82 (empty -> .)

    comvar                         shift and go to state 54
    empty                          shift and go to state 55

state 10

    (19) stat -> local . namelist
    (20) stat -> local . namelist EQUALS explist
    (22) stat -> local . function names funcbody
    (51) namelist -> . names comid
    (100) names -> . ID
    (101) names -> . RESID

    function        shift and go to state 56
    ID              shift and go to state 15
    RESID           shift and go to state 1

    namelist                       shift and go to state 57
    names                          shift and go to state 58

state 11

    (21) stat -> function . funcname funcbody
    (37) funcname -> . names dotid COLON
    (38) funcname -> . names
    (100) names -> . ID
    (101) names -> . RESID

    ID              shift and go to state 15
    RESID           shift and go to state 1

    names                          shift and go to state 60
    funcname                       shift and go to state 59

state 12

    (10) stat -> do . block end
    (8) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    block                          shift and go to state 62
    var                            shift and go to state 9
    sdash                          shift and go to state 61
    names                          shift and go to state 4

state 13

    (6) chunk -> stat .
    (7) chunk -> stat . SEMI

    return          reduce using rule 6 (chunk -> stat .)
    break           reduce using rule 6 (chunk -> stat .)
    do              reduce using rule 6 (chunk -> stat .)
    while           reduce using rule 6 (chunk -> stat .)
    repeat          reduce using rule 6 (chunk -> stat .)
    if              reduce using rule 6 (chunk -> stat .)
    for             reduce using rule 6 (chunk -> stat .)
    local           reduce using rule 6 (chunk -> stat .)
    function        reduce using rule 6 (chunk -> stat .)
    LPAREN          reduce using rule 6 (chunk -> stat .)
    ID              reduce using rule 6 (chunk -> stat .)
    RESID           reduce using rule 6 (chunk -> stat .)
    end             reduce using rule 6 (chunk -> stat .)
    else            reduce using rule 6 (chunk -> stat .)
    elseif          reduce using rule 6 (chunk -> stat .)
    until           reduce using rule 6 (chunk -> stat .)
    $end            reduce using rule 6 (chunk -> stat .)
    SEMI            shift and go to state 63


state 14

    (13) stat -> repeat . block until exp
    (8) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    sdash                          shift and go to state 61
    var                            shift and go to state 9
    block                          shift and go to state 64
    names                          shift and go to state 4

state 15

    (100) names -> ID .

    COMMA           reduce using rule 100 (names -> ID .)
    EQUALS          reduce using rule 100 (names -> ID .)
    LSQUARE         reduce using rule 100 (names -> ID .)
    SDOT            reduce using rule 100 (names -> ID .)
    LPAREN          reduce using rule 100 (names -> ID .)
    STRING          reduce using rule 100 (names -> ID .)
    LCURLY          reduce using rule 100 (names -> ID .)
    PLUS            reduce using rule 100 (names -> ID .)
    MINUS           reduce using rule 100 (names -> ID .)
    TIMES           reduce using rule 100 (names -> ID .)
    DIVIDE          reduce using rule 100 (names -> ID .)
    POWER           reduce using rule 100 (names -> ID .)
    LT              reduce using rule 100 (names -> ID .)
    LE              reduce using rule 100 (names -> ID .)
    GT              reduce using rule 100 (names -> ID .)
    GE              reduce using rule 100 (names -> ID .)
    NE              reduce using rule 100 (names -> ID .)
    CHECKEQ         reduce using rule 100 (names -> ID .)
    and             reduce using rule 100 (names -> ID .)
    or              reduce using rule 100 (names -> ID .)
    MODULO          reduce using rule 100 (names -> ID .)
    DBLDOTS         reduce using rule 100 (names -> ID .)
    do              reduce using rule 100 (names -> ID .)
    SEMI            reduce using rule 100 (names -> ID .)
    return          reduce using rule 100 (names -> ID .)
    break           reduce using rule 100 (names -> ID .)
    while           reduce using rule 100 (names -> ID .)
    repeat          reduce using rule 100 (names -> ID .)
    if              reduce using rule 100 (names -> ID .)
    for             reduce using rule 100 (names -> ID .)
    local           reduce using rule 100 (names -> ID .)
    function        reduce using rule 100 (names -> ID .)
    ID              reduce using rule 100 (names -> ID .)
    RESID           reduce using rule 100 (names -> ID .)
    $end            reduce using rule 100 (names -> ID .)
    end             reduce using rule 100 (names -> ID .)
    until           reduce using rule 100 (names -> ID .)
    else            reduce using rule 100 (names -> ID .)
    elseif          reduce using rule 100 (names -> ID .)
    RPAREN          reduce using rule 100 (names -> ID .)
    then            reduce using rule 100 (names -> ID .)
    RCURLY          reduce using rule 100 (names -> ID .)
    RSQUARE         reduce using rule 100 (names -> ID .)
    in              reduce using rule 100 (names -> ID .)
    COLON           reduce using rule 100 (names -> ID .)


state 16

    (12) stat -> while . exp do block end
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 65
    var                            shift and go to state 26
    names                          shift and go to state 4

state 17

    (11) stat -> functioncall .
    (85) prefixexp -> functioncall .

  ! reduce/reduce conflict for LPAREN resolved using rule 11 (stat -> functioncall .)
    SEMI            reduce using rule 11 (stat -> functioncall .)
    return          reduce using rule 11 (stat -> functioncall .)
    break           reduce using rule 11 (stat -> functioncall .)
    do              reduce using rule 11 (stat -> functioncall .)
    while           reduce using rule 11 (stat -> functioncall .)
    repeat          reduce using rule 11 (stat -> functioncall .)
    if              reduce using rule 11 (stat -> functioncall .)
    for             reduce using rule 11 (stat -> functioncall .)
    local           reduce using rule 11 (stat -> functioncall .)
    function        reduce using rule 11 (stat -> functioncall .)
    LPAREN          reduce using rule 11 (stat -> functioncall .)
    ID              reduce using rule 11 (stat -> functioncall .)
    RESID           reduce using rule 11 (stat -> functioncall .)
    else            reduce using rule 11 (stat -> functioncall .)
    end             reduce using rule 11 (stat -> functioncall .)
    elseif          reduce using rule 11 (stat -> functioncall .)
    $end            reduce using rule 11 (stat -> functioncall .)
    until           reduce using rule 11 (stat -> functioncall .)
    LSQUARE         reduce using rule 85 (prefixexp -> functioncall .)
    SDOT            reduce using rule 85 (prefixexp -> functioncall .)
    STRING          reduce using rule 85 (prefixexp -> functioncall .)
    LCURLY          reduce using rule 85 (prefixexp -> functioncall .)

  ! LPAREN          [ reduce using rule 85 (prefixexp -> functioncall .) ]


state 18

    (0) S' -> sdash .



state 19

    (77) exp -> tableconstructor .

    PLUS            reduce using rule 77 (exp -> tableconstructor .)
    MINUS           reduce using rule 77 (exp -> tableconstructor .)
    TIMES           reduce using rule 77 (exp -> tableconstructor .)
    DIVIDE          reduce using rule 77 (exp -> tableconstructor .)
    POWER           reduce using rule 77 (exp -> tableconstructor .)
    LT              reduce using rule 77 (exp -> tableconstructor .)
    LE              reduce using rule 77 (exp -> tableconstructor .)
    GT              reduce using rule 77 (exp -> tableconstructor .)
    GE              reduce using rule 77 (exp -> tableconstructor .)
    NE              reduce using rule 77 (exp -> tableconstructor .)
    CHECKEQ         reduce using rule 77 (exp -> tableconstructor .)
    and             reduce using rule 77 (exp -> tableconstructor .)
    or              reduce using rule 77 (exp -> tableconstructor .)
    MODULO          reduce using rule 77 (exp -> tableconstructor .)
    DBLDOTS         reduce using rule 77 (exp -> tableconstructor .)
    RPAREN          reduce using rule 77 (exp -> tableconstructor .)
    then            reduce using rule 77 (exp -> tableconstructor .)
    do              reduce using rule 77 (exp -> tableconstructor .)
    COMMA           reduce using rule 77 (exp -> tableconstructor .)
    SEMI            reduce using rule 77 (exp -> tableconstructor .)
    RCURLY          reduce using rule 77 (exp -> tableconstructor .)
    $end            reduce using rule 77 (exp -> tableconstructor .)
    end             reduce using rule 77 (exp -> tableconstructor .)
    until           reduce using rule 77 (exp -> tableconstructor .)
    else            reduce using rule 77 (exp -> tableconstructor .)
    elseif          reduce using rule 77 (exp -> tableconstructor .)
    RSQUARE         reduce using rule 77 (exp -> tableconstructor .)
    return          reduce using rule 77 (exp -> tableconstructor .)
    break           reduce using rule 77 (exp -> tableconstructor .)
    while           reduce using rule 77 (exp -> tableconstructor .)
    repeat          reduce using rule 77 (exp -> tableconstructor .)
    if              reduce using rule 77 (exp -> tableconstructor .)
    for             reduce using rule 77 (exp -> tableconstructor .)
    local           reduce using rule 77 (exp -> tableconstructor .)
    function        reduce using rule 77 (exp -> tableconstructor .)
    LPAREN          reduce using rule 77 (exp -> tableconstructor .)
    ID              reduce using rule 77 (exp -> tableconstructor .)
    RESID           reduce using rule 77 (exp -> tableconstructor .)


state 20

    (55) exp -> false .

    PLUS            reduce using rule 55 (exp -> false .)
    MINUS           reduce using rule 55 (exp -> false .)
    TIMES           reduce using rule 55 (exp -> false .)
    DIVIDE          reduce using rule 55 (exp -> false .)
    POWER           reduce using rule 55 (exp -> false .)
    LT              reduce using rule 55 (exp -> false .)
    LE              reduce using rule 55 (exp -> false .)
    GT              reduce using rule 55 (exp -> false .)
    GE              reduce using rule 55 (exp -> false .)
    NE              reduce using rule 55 (exp -> false .)
    CHECKEQ         reduce using rule 55 (exp -> false .)
    and             reduce using rule 55 (exp -> false .)
    or              reduce using rule 55 (exp -> false .)
    MODULO          reduce using rule 55 (exp -> false .)
    DBLDOTS         reduce using rule 55 (exp -> false .)
    RPAREN          reduce using rule 55 (exp -> false .)
    then            reduce using rule 55 (exp -> false .)
    do              reduce using rule 55 (exp -> false .)
    COMMA           reduce using rule 55 (exp -> false .)
    SEMI            reduce using rule 55 (exp -> false .)
    RCURLY          reduce using rule 55 (exp -> false .)
    $end            reduce using rule 55 (exp -> false .)
    end             reduce using rule 55 (exp -> false .)
    until           reduce using rule 55 (exp -> false .)
    else            reduce using rule 55 (exp -> false .)
    elseif          reduce using rule 55 (exp -> false .)
    RSQUARE         reduce using rule 55 (exp -> false .)
    return          reduce using rule 55 (exp -> false .)
    break           reduce using rule 55 (exp -> false .)
    while           reduce using rule 55 (exp -> false .)
    repeat          reduce using rule 55 (exp -> false .)
    if              reduce using rule 55 (exp -> false .)
    for             reduce using rule 55 (exp -> false .)
    local           reduce using rule 55 (exp -> false .)
    function        reduce using rule 55 (exp -> false .)
    LPAREN          reduce using rule 55 (exp -> false .)
    ID              reduce using rule 55 (exp -> false .)
    RESID           reduce using rule 55 (exp -> false .)


state 21

    (89) tableconstructor -> LCURLY . fieldlist RCURLY
    (90) tableconstructor -> LCURLY . RCURLY
    (91) fieldlist -> . field fieldseplist fieldsep
    (92) fieldlist -> . field fieldseplist
    (95) field -> . LSQUARE exp RSQUARE EQUALS exp
    (96) field -> . names EQUALS exp
    (97) field -> . exp
    (100) names -> . ID
    (101) names -> . RESID
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args

    RCURLY          shift and go to state 67
    LSQUARE         shift and go to state 71
    ID              shift and go to state 15
    RESID           shift and go to state 1
    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    field                          shift and go to state 68
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    fieldlist                      shift and go to state 69
    exp                            shift and go to state 70
    var                            shift and go to state 26
    names                          shift and go to state 66

state 22

    (88) unop -> HASH .

    nil             reduce using rule 88 (unop -> HASH .)
    false           reduce using rule 88 (unop -> HASH .)
    true            reduce using rule 88 (unop -> HASH .)
    STRING          reduce using rule 88 (unop -> HASH .)
    TRPLDOTS        reduce using rule 88 (unop -> HASH .)
    function        reduce using rule 88 (unop -> HASH .)
    INTEGER         reduce using rule 88 (unop -> HASH .)
    FLOAT           reduce using rule 88 (unop -> HASH .)
    HEX             reduce using rule 88 (unop -> HASH .)
    LPAREN          reduce using rule 88 (unop -> HASH .)
    LCURLY          reduce using rule 88 (unop -> HASH .)
    MINUS           reduce using rule 88 (unop -> HASH .)
    not             reduce using rule 88 (unop -> HASH .)
    HASH            reduce using rule 88 (unop -> HASH .)
    ID              reduce using rule 88 (unop -> HASH .)
    RESID           reduce using rule 88 (unop -> HASH .)


state 23

    (86) unop -> MINUS .

    nil             reduce using rule 86 (unop -> MINUS .)
    false           reduce using rule 86 (unop -> MINUS .)
    true            reduce using rule 86 (unop -> MINUS .)
    STRING          reduce using rule 86 (unop -> MINUS .)
    TRPLDOTS        reduce using rule 86 (unop -> MINUS .)
    function        reduce using rule 86 (unop -> MINUS .)
    INTEGER         reduce using rule 86 (unop -> MINUS .)
    FLOAT           reduce using rule 86 (unop -> MINUS .)
    HEX             reduce using rule 86 (unop -> MINUS .)
    LPAREN          reduce using rule 86 (unop -> MINUS .)
    LCURLY          reduce using rule 86 (unop -> MINUS .)
    MINUS           reduce using rule 86 (unop -> MINUS .)
    not             reduce using rule 86 (unop -> MINUS .)
    HASH            reduce using rule 86 (unop -> MINUS .)
    ID              reduce using rule 86 (unop -> MINUS .)
    RESID           reduce using rule 86 (unop -> MINUS .)


state 24

    (58) exp -> STRING .

    PLUS            reduce using rule 58 (exp -> STRING .)
    MINUS           reduce using rule 58 (exp -> STRING .)
    TIMES           reduce using rule 58 (exp -> STRING .)
    DIVIDE          reduce using rule 58 (exp -> STRING .)
    POWER           reduce using rule 58 (exp -> STRING .)
    LT              reduce using rule 58 (exp -> STRING .)
    LE              reduce using rule 58 (exp -> STRING .)
    GT              reduce using rule 58 (exp -> STRING .)
    GE              reduce using rule 58 (exp -> STRING .)
    NE              reduce using rule 58 (exp -> STRING .)
    CHECKEQ         reduce using rule 58 (exp -> STRING .)
    and             reduce using rule 58 (exp -> STRING .)
    or              reduce using rule 58 (exp -> STRING .)
    MODULO          reduce using rule 58 (exp -> STRING .)
    DBLDOTS         reduce using rule 58 (exp -> STRING .)
    RPAREN          reduce using rule 58 (exp -> STRING .)
    then            reduce using rule 58 (exp -> STRING .)
    do              reduce using rule 58 (exp -> STRING .)
    COMMA           reduce using rule 58 (exp -> STRING .)
    SEMI            reduce using rule 58 (exp -> STRING .)
    RCURLY          reduce using rule 58 (exp -> STRING .)
    $end            reduce using rule 58 (exp -> STRING .)
    end             reduce using rule 58 (exp -> STRING .)
    until           reduce using rule 58 (exp -> STRING .)
    else            reduce using rule 58 (exp -> STRING .)
    elseif          reduce using rule 58 (exp -> STRING .)
    RSQUARE         reduce using rule 58 (exp -> STRING .)
    return          reduce using rule 58 (exp -> STRING .)
    break           reduce using rule 58 (exp -> STRING .)
    while           reduce using rule 58 (exp -> STRING .)
    repeat          reduce using rule 58 (exp -> STRING .)
    if              reduce using rule 58 (exp -> STRING .)
    for             reduce using rule 58 (exp -> STRING .)
    local           reduce using rule 58 (exp -> STRING .)
    function        reduce using rule 58 (exp -> STRING .)
    LPAREN          reduce using rule 58 (exp -> STRING .)
    ID              reduce using rule 58 (exp -> STRING .)
    RESID           reduce using rule 58 (exp -> STRING .)


state 25

    (61) exp -> prefixexp .
    (49) var -> prefixexp . LSQUARE exp RSQUARE
    (50) var -> prefixexp . SDOT names
    (25) functioncall -> prefixexp . args
    (26) args -> . LPAREN RPAREN
    (27) args -> . LPAREN explist RPAREN
    (28) args -> . tableconstructor
    (29) args -> . STRING
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY

  ! shift/reduce conflict for LPAREN resolved as shift
    PLUS            reduce using rule 61 (exp -> prefixexp .)
    MINUS           reduce using rule 61 (exp -> prefixexp .)
    TIMES           reduce using rule 61 (exp -> prefixexp .)
    DIVIDE          reduce using rule 61 (exp -> prefixexp .)
    POWER           reduce using rule 61 (exp -> prefixexp .)
    LT              reduce using rule 61 (exp -> prefixexp .)
    LE              reduce using rule 61 (exp -> prefixexp .)
    GT              reduce using rule 61 (exp -> prefixexp .)
    GE              reduce using rule 61 (exp -> prefixexp .)
    NE              reduce using rule 61 (exp -> prefixexp .)
    CHECKEQ         reduce using rule 61 (exp -> prefixexp .)
    and             reduce using rule 61 (exp -> prefixexp .)
    or              reduce using rule 61 (exp -> prefixexp .)
    MODULO          reduce using rule 61 (exp -> prefixexp .)
    DBLDOTS         reduce using rule 61 (exp -> prefixexp .)
    RPAREN          reduce using rule 61 (exp -> prefixexp .)
    then            reduce using rule 61 (exp -> prefixexp .)
    do              reduce using rule 61 (exp -> prefixexp .)
    COMMA           reduce using rule 61 (exp -> prefixexp .)
    SEMI            reduce using rule 61 (exp -> prefixexp .)
    RCURLY          reduce using rule 61 (exp -> prefixexp .)
    $end            reduce using rule 61 (exp -> prefixexp .)
    end             reduce using rule 61 (exp -> prefixexp .)
    until           reduce using rule 61 (exp -> prefixexp .)
    else            reduce using rule 61 (exp -> prefixexp .)
    elseif          reduce using rule 61 (exp -> prefixexp .)
    RSQUARE         reduce using rule 61 (exp -> prefixexp .)
    return          reduce using rule 61 (exp -> prefixexp .)
    break           reduce using rule 61 (exp -> prefixexp .)
    while           reduce using rule 61 (exp -> prefixexp .)
    repeat          reduce using rule 61 (exp -> prefixexp .)
    if              reduce using rule 61 (exp -> prefixexp .)
    for             reduce using rule 61 (exp -> prefixexp .)
    local           reduce using rule 61 (exp -> prefixexp .)
    function        reduce using rule 61 (exp -> prefixexp .)
    ID              reduce using rule 61 (exp -> prefixexp .)
    RESID           reduce using rule 61 (exp -> prefixexp .)
    LSQUARE         shift and go to state 45
    SDOT            shift and go to state 48
    LPAREN          shift and go to state 47
    STRING          shift and go to state 49
    LCURLY          shift and go to state 21

  ! LPAREN          [ reduce using rule 61 (exp -> prefixexp .) ]

    tableconstructor               shift and go to state 44
    args                           shift and go to state 46

state 26

    (83) prefixexp -> var .

    LSQUARE         reduce using rule 83 (prefixexp -> var .)
    SDOT            reduce using rule 83 (prefixexp -> var .)
    LPAREN          reduce using rule 83 (prefixexp -> var .)
    STRING          reduce using rule 83 (prefixexp -> var .)
    LCURLY          reduce using rule 83 (prefixexp -> var .)
    do              reduce using rule 83 (prefixexp -> var .)
    COMMA           reduce using rule 83 (prefixexp -> var .)
    PLUS            reduce using rule 83 (prefixexp -> var .)
    MINUS           reduce using rule 83 (prefixexp -> var .)
    TIMES           reduce using rule 83 (prefixexp -> var .)
    DIVIDE          reduce using rule 83 (prefixexp -> var .)
    POWER           reduce using rule 83 (prefixexp -> var .)
    LT              reduce using rule 83 (prefixexp -> var .)
    LE              reduce using rule 83 (prefixexp -> var .)
    GT              reduce using rule 83 (prefixexp -> var .)
    GE              reduce using rule 83 (prefixexp -> var .)
    NE              reduce using rule 83 (prefixexp -> var .)
    CHECKEQ         reduce using rule 83 (prefixexp -> var .)
    and             reduce using rule 83 (prefixexp -> var .)
    or              reduce using rule 83 (prefixexp -> var .)
    MODULO          reduce using rule 83 (prefixexp -> var .)
    DBLDOTS         reduce using rule 83 (prefixexp -> var .)
    SEMI            reduce using rule 83 (prefixexp -> var .)
    return          reduce using rule 83 (prefixexp -> var .)
    break           reduce using rule 83 (prefixexp -> var .)
    while           reduce using rule 83 (prefixexp -> var .)
    repeat          reduce using rule 83 (prefixexp -> var .)
    if              reduce using rule 83 (prefixexp -> var .)
    for             reduce using rule 83 (prefixexp -> var .)
    local           reduce using rule 83 (prefixexp -> var .)
    function        reduce using rule 83 (prefixexp -> var .)
    ID              reduce using rule 83 (prefixexp -> var .)
    RESID           reduce using rule 83 (prefixexp -> var .)
    $end            reduce using rule 83 (prefixexp -> var .)
    end             reduce using rule 83 (prefixexp -> var .)
    until           reduce using rule 83 (prefixexp -> var .)
    else            reduce using rule 83 (prefixexp -> var .)
    elseif          reduce using rule 83 (prefixexp -> var .)
    then            reduce using rule 83 (prefixexp -> var .)
    RCURLY          reduce using rule 83 (prefixexp -> var .)
    RSQUARE         reduce using rule 83 (prefixexp -> var .)
    RPAREN          reduce using rule 83 (prefixexp -> var .)


state 27

    (79) Number -> INTEGER .

    PLUS            reduce using rule 79 (Number -> INTEGER .)
    MINUS           reduce using rule 79 (Number -> INTEGER .)
    TIMES           reduce using rule 79 (Number -> INTEGER .)
    DIVIDE          reduce using rule 79 (Number -> INTEGER .)
    POWER           reduce using rule 79 (Number -> INTEGER .)
    LT              reduce using rule 79 (Number -> INTEGER .)
    LE              reduce using rule 79 (Number -> INTEGER .)
    GT              reduce using rule 79 (Number -> INTEGER .)
    GE              reduce using rule 79 (Number -> INTEGER .)
    NE              reduce using rule 79 (Number -> INTEGER .)
    CHECKEQ         reduce using rule 79 (Number -> INTEGER .)
    and             reduce using rule 79 (Number -> INTEGER .)
    or              reduce using rule 79 (Number -> INTEGER .)
    MODULO          reduce using rule 79 (Number -> INTEGER .)
    DBLDOTS         reduce using rule 79 (Number -> INTEGER .)
    RPAREN          reduce using rule 79 (Number -> INTEGER .)
    then            reduce using rule 79 (Number -> INTEGER .)
    do              reduce using rule 79 (Number -> INTEGER .)
    COMMA           reduce using rule 79 (Number -> INTEGER .)
    SEMI            reduce using rule 79 (Number -> INTEGER .)
    RCURLY          reduce using rule 79 (Number -> INTEGER .)
    $end            reduce using rule 79 (Number -> INTEGER .)
    end             reduce using rule 79 (Number -> INTEGER .)
    until           reduce using rule 79 (Number -> INTEGER .)
    else            reduce using rule 79 (Number -> INTEGER .)
    elseif          reduce using rule 79 (Number -> INTEGER .)
    RSQUARE         reduce using rule 79 (Number -> INTEGER .)
    return          reduce using rule 79 (Number -> INTEGER .)
    break           reduce using rule 79 (Number -> INTEGER .)
    while           reduce using rule 79 (Number -> INTEGER .)
    repeat          reduce using rule 79 (Number -> INTEGER .)
    if              reduce using rule 79 (Number -> INTEGER .)
    for             reduce using rule 79 (Number -> INTEGER .)
    local           reduce using rule 79 (Number -> INTEGER .)
    function        reduce using rule 79 (Number -> INTEGER .)
    LPAREN          reduce using rule 79 (Number -> INTEGER .)
    ID              reduce using rule 79 (Number -> INTEGER .)
    RESID           reduce using rule 79 (Number -> INTEGER .)


state 28

    (60) exp -> function .

    PLUS            reduce using rule 60 (exp -> function .)
    MINUS           reduce using rule 60 (exp -> function .)
    TIMES           reduce using rule 60 (exp -> function .)
    DIVIDE          reduce using rule 60 (exp -> function .)
    POWER           reduce using rule 60 (exp -> function .)
    LT              reduce using rule 60 (exp -> function .)
    LE              reduce using rule 60 (exp -> function .)
    GT              reduce using rule 60 (exp -> function .)
    GE              reduce using rule 60 (exp -> function .)
    NE              reduce using rule 60 (exp -> function .)
    CHECKEQ         reduce using rule 60 (exp -> function .)
    and             reduce using rule 60 (exp -> function .)
    or              reduce using rule 60 (exp -> function .)
    MODULO          reduce using rule 60 (exp -> function .)
    DBLDOTS         reduce using rule 60 (exp -> function .)
    RPAREN          reduce using rule 60 (exp -> function .)
    then            reduce using rule 60 (exp -> function .)
    do              reduce using rule 60 (exp -> function .)
    COMMA           reduce using rule 60 (exp -> function .)
    SEMI            reduce using rule 60 (exp -> function .)
    RCURLY          reduce using rule 60 (exp -> function .)
    $end            reduce using rule 60 (exp -> function .)
    end             reduce using rule 60 (exp -> function .)
    until           reduce using rule 60 (exp -> function .)
    else            reduce using rule 60 (exp -> function .)
    elseif          reduce using rule 60 (exp -> function .)
    RSQUARE         reduce using rule 60 (exp -> function .)
    return          reduce using rule 60 (exp -> function .)
    break           reduce using rule 60 (exp -> function .)
    while           reduce using rule 60 (exp -> function .)
    repeat          reduce using rule 60 (exp -> function .)
    if              reduce using rule 60 (exp -> function .)
    for             reduce using rule 60 (exp -> function .)
    local           reduce using rule 60 (exp -> function .)
    function        reduce using rule 60 (exp -> function .)
    LPAREN          reduce using rule 60 (exp -> function .)
    ID              reduce using rule 60 (exp -> function .)
    RESID           reduce using rule 60 (exp -> function .)


state 29

    (54) exp -> nil .

    PLUS            reduce using rule 54 (exp -> nil .)
    MINUS           reduce using rule 54 (exp -> nil .)
    TIMES           reduce using rule 54 (exp -> nil .)
    DIVIDE          reduce using rule 54 (exp -> nil .)
    POWER           reduce using rule 54 (exp -> nil .)
    LT              reduce using rule 54 (exp -> nil .)
    LE              reduce using rule 54 (exp -> nil .)
    GT              reduce using rule 54 (exp -> nil .)
    GE              reduce using rule 54 (exp -> nil .)
    NE              reduce using rule 54 (exp -> nil .)
    CHECKEQ         reduce using rule 54 (exp -> nil .)
    and             reduce using rule 54 (exp -> nil .)
    or              reduce using rule 54 (exp -> nil .)
    MODULO          reduce using rule 54 (exp -> nil .)
    DBLDOTS         reduce using rule 54 (exp -> nil .)
    RPAREN          reduce using rule 54 (exp -> nil .)
    then            reduce using rule 54 (exp -> nil .)
    do              reduce using rule 54 (exp -> nil .)
    COMMA           reduce using rule 54 (exp -> nil .)
    SEMI            reduce using rule 54 (exp -> nil .)
    RCURLY          reduce using rule 54 (exp -> nil .)
    $end            reduce using rule 54 (exp -> nil .)
    end             reduce using rule 54 (exp -> nil .)
    until           reduce using rule 54 (exp -> nil .)
    else            reduce using rule 54 (exp -> nil .)
    elseif          reduce using rule 54 (exp -> nil .)
    RSQUARE         reduce using rule 54 (exp -> nil .)
    return          reduce using rule 54 (exp -> nil .)
    break           reduce using rule 54 (exp -> nil .)
    while           reduce using rule 54 (exp -> nil .)
    repeat          reduce using rule 54 (exp -> nil .)
    if              reduce using rule 54 (exp -> nil .)
    for             reduce using rule 54 (exp -> nil .)
    local           reduce using rule 54 (exp -> nil .)
    function        reduce using rule 54 (exp -> nil .)
    LPAREN          reduce using rule 54 (exp -> nil .)
    ID              reduce using rule 54 (exp -> nil .)
    RESID           reduce using rule 54 (exp -> nil .)


state 30

    (81) Number -> HEX .

    PLUS            reduce using rule 81 (Number -> HEX .)
    MINUS           reduce using rule 81 (Number -> HEX .)
    TIMES           reduce using rule 81 (Number -> HEX .)
    DIVIDE          reduce using rule 81 (Number -> HEX .)
    POWER           reduce using rule 81 (Number -> HEX .)
    LT              reduce using rule 81 (Number -> HEX .)
    LE              reduce using rule 81 (Number -> HEX .)
    GT              reduce using rule 81 (Number -> HEX .)
    GE              reduce using rule 81 (Number -> HEX .)
    NE              reduce using rule 81 (Number -> HEX .)
    CHECKEQ         reduce using rule 81 (Number -> HEX .)
    and             reduce using rule 81 (Number -> HEX .)
    or              reduce using rule 81 (Number -> HEX .)
    MODULO          reduce using rule 81 (Number -> HEX .)
    DBLDOTS         reduce using rule 81 (Number -> HEX .)
    RPAREN          reduce using rule 81 (Number -> HEX .)
    then            reduce using rule 81 (Number -> HEX .)
    do              reduce using rule 81 (Number -> HEX .)
    COMMA           reduce using rule 81 (Number -> HEX .)
    SEMI            reduce using rule 81 (Number -> HEX .)
    RCURLY          reduce using rule 81 (Number -> HEX .)
    $end            reduce using rule 81 (Number -> HEX .)
    end             reduce using rule 81 (Number -> HEX .)
    until           reduce using rule 81 (Number -> HEX .)
    else            reduce using rule 81 (Number -> HEX .)
    elseif          reduce using rule 81 (Number -> HEX .)
    RSQUARE         reduce using rule 81 (Number -> HEX .)
    return          reduce using rule 81 (Number -> HEX .)
    break           reduce using rule 81 (Number -> HEX .)
    while           reduce using rule 81 (Number -> HEX .)
    repeat          reduce using rule 81 (Number -> HEX .)
    if              reduce using rule 81 (Number -> HEX .)
    for             reduce using rule 81 (Number -> HEX .)
    local           reduce using rule 81 (Number -> HEX .)
    function        reduce using rule 81 (Number -> HEX .)
    LPAREN          reduce using rule 81 (Number -> HEX .)
    ID              reduce using rule 81 (Number -> HEX .)
    RESID           reduce using rule 81 (Number -> HEX .)


state 31

    (87) unop -> not .

    nil             reduce using rule 87 (unop -> not .)
    false           reduce using rule 87 (unop -> not .)
    true            reduce using rule 87 (unop -> not .)
    STRING          reduce using rule 87 (unop -> not .)
    TRPLDOTS        reduce using rule 87 (unop -> not .)
    function        reduce using rule 87 (unop -> not .)
    INTEGER         reduce using rule 87 (unop -> not .)
    FLOAT           reduce using rule 87 (unop -> not .)
    HEX             reduce using rule 87 (unop -> not .)
    LPAREN          reduce using rule 87 (unop -> not .)
    LCURLY          reduce using rule 87 (unop -> not .)
    MINUS           reduce using rule 87 (unop -> not .)
    not             reduce using rule 87 (unop -> not .)
    HASH            reduce using rule 87 (unop -> not .)
    ID              reduce using rule 87 (unop -> not .)
    RESID           reduce using rule 87 (unop -> not .)


state 32

    (56) exp -> true .

    PLUS            reduce using rule 56 (exp -> true .)
    MINUS           reduce using rule 56 (exp -> true .)
    TIMES           reduce using rule 56 (exp -> true .)
    DIVIDE          reduce using rule 56 (exp -> true .)
    POWER           reduce using rule 56 (exp -> true .)
    LT              reduce using rule 56 (exp -> true .)
    LE              reduce using rule 56 (exp -> true .)
    GT              reduce using rule 56 (exp -> true .)
    GE              reduce using rule 56 (exp -> true .)
    NE              reduce using rule 56 (exp -> true .)
    CHECKEQ         reduce using rule 56 (exp -> true .)
    and             reduce using rule 56 (exp -> true .)
    or              reduce using rule 56 (exp -> true .)
    MODULO          reduce using rule 56 (exp -> true .)
    DBLDOTS         reduce using rule 56 (exp -> true .)
    RPAREN          reduce using rule 56 (exp -> true .)
    then            reduce using rule 56 (exp -> true .)
    do              reduce using rule 56 (exp -> true .)
    COMMA           reduce using rule 56 (exp -> true .)
    SEMI            reduce using rule 56 (exp -> true .)
    RCURLY          reduce using rule 56 (exp -> true .)
    $end            reduce using rule 56 (exp -> true .)
    end             reduce using rule 56 (exp -> true .)
    until           reduce using rule 56 (exp -> true .)
    else            reduce using rule 56 (exp -> true .)
    elseif          reduce using rule 56 (exp -> true .)
    RSQUARE         reduce using rule 56 (exp -> true .)
    return          reduce using rule 56 (exp -> true .)
    break           reduce using rule 56 (exp -> true .)
    while           reduce using rule 56 (exp -> true .)
    repeat          reduce using rule 56 (exp -> true .)
    if              reduce using rule 56 (exp -> true .)
    for             reduce using rule 56 (exp -> true .)
    local           reduce using rule 56 (exp -> true .)
    function        reduce using rule 56 (exp -> true .)
    LPAREN          reduce using rule 56 (exp -> true .)
    ID              reduce using rule 56 (exp -> true .)
    RESID           reduce using rule 56 (exp -> true .)


state 33

    (80) Number -> FLOAT .

    PLUS            reduce using rule 80 (Number -> FLOAT .)
    MINUS           reduce using rule 80 (Number -> FLOAT .)
    TIMES           reduce using rule 80 (Number -> FLOAT .)
    DIVIDE          reduce using rule 80 (Number -> FLOAT .)
    POWER           reduce using rule 80 (Number -> FLOAT .)
    LT              reduce using rule 80 (Number -> FLOAT .)
    LE              reduce using rule 80 (Number -> FLOAT .)
    GT              reduce using rule 80 (Number -> FLOAT .)
    GE              reduce using rule 80 (Number -> FLOAT .)
    NE              reduce using rule 80 (Number -> FLOAT .)
    CHECKEQ         reduce using rule 80 (Number -> FLOAT .)
    and             reduce using rule 80 (Number -> FLOAT .)
    or              reduce using rule 80 (Number -> FLOAT .)
    MODULO          reduce using rule 80 (Number -> FLOAT .)
    DBLDOTS         reduce using rule 80 (Number -> FLOAT .)
    RPAREN          reduce using rule 80 (Number -> FLOAT .)
    then            reduce using rule 80 (Number -> FLOAT .)
    do              reduce using rule 80 (Number -> FLOAT .)
    COMMA           reduce using rule 80 (Number -> FLOAT .)
    SEMI            reduce using rule 80 (Number -> FLOAT .)
    RCURLY          reduce using rule 80 (Number -> FLOAT .)
    $end            reduce using rule 80 (Number -> FLOAT .)
    end             reduce using rule 80 (Number -> FLOAT .)
    until           reduce using rule 80 (Number -> FLOAT .)
    else            reduce using rule 80 (Number -> FLOAT .)
    elseif          reduce using rule 80 (Number -> FLOAT .)
    RSQUARE         reduce using rule 80 (Number -> FLOAT .)
    return          reduce using rule 80 (Number -> FLOAT .)
    break           reduce using rule 80 (Number -> FLOAT .)
    while           reduce using rule 80 (Number -> FLOAT .)
    repeat          reduce using rule 80 (Number -> FLOAT .)
    if              reduce using rule 80 (Number -> FLOAT .)
    for             reduce using rule 80 (Number -> FLOAT .)
    local           reduce using rule 80 (Number -> FLOAT .)
    function        reduce using rule 80 (Number -> FLOAT .)
    LPAREN          reduce using rule 80 (Number -> FLOAT .)
    ID              reduce using rule 80 (Number -> FLOAT .)
    RESID           reduce using rule 80 (Number -> FLOAT .)


state 34

    (57) exp -> Number .

    PLUS            reduce using rule 57 (exp -> Number .)
    MINUS           reduce using rule 57 (exp -> Number .)
    TIMES           reduce using rule 57 (exp -> Number .)
    DIVIDE          reduce using rule 57 (exp -> Number .)
    POWER           reduce using rule 57 (exp -> Number .)
    LT              reduce using rule 57 (exp -> Number .)
    LE              reduce using rule 57 (exp -> Number .)
    GT              reduce using rule 57 (exp -> Number .)
    GE              reduce using rule 57 (exp -> Number .)
    NE              reduce using rule 57 (exp -> Number .)
    CHECKEQ         reduce using rule 57 (exp -> Number .)
    and             reduce using rule 57 (exp -> Number .)
    or              reduce using rule 57 (exp -> Number .)
    MODULO          reduce using rule 57 (exp -> Number .)
    DBLDOTS         reduce using rule 57 (exp -> Number .)
    RPAREN          reduce using rule 57 (exp -> Number .)
    then            reduce using rule 57 (exp -> Number .)
    do              reduce using rule 57 (exp -> Number .)
    COMMA           reduce using rule 57 (exp -> Number .)
    SEMI            reduce using rule 57 (exp -> Number .)
    RCURLY          reduce using rule 57 (exp -> Number .)
    $end            reduce using rule 57 (exp -> Number .)
    end             reduce using rule 57 (exp -> Number .)
    until           reduce using rule 57 (exp -> Number .)
    else            reduce using rule 57 (exp -> Number .)
    elseif          reduce using rule 57 (exp -> Number .)
    RSQUARE         reduce using rule 57 (exp -> Number .)
    return          reduce using rule 57 (exp -> Number .)
    break           reduce using rule 57 (exp -> Number .)
    while           reduce using rule 57 (exp -> Number .)
    repeat          reduce using rule 57 (exp -> Number .)
    if              reduce using rule 57 (exp -> Number .)
    for             reduce using rule 57 (exp -> Number .)
    local           reduce using rule 57 (exp -> Number .)
    function        reduce using rule 57 (exp -> Number .)
    LPAREN          reduce using rule 57 (exp -> Number .)
    ID              reduce using rule 57 (exp -> Number .)
    RESID           reduce using rule 57 (exp -> Number .)


state 35

    (85) prefixexp -> functioncall .

    LSQUARE         reduce using rule 85 (prefixexp -> functioncall .)
    SDOT            reduce using rule 85 (prefixexp -> functioncall .)
    LPAREN          reduce using rule 85 (prefixexp -> functioncall .)
    STRING          reduce using rule 85 (prefixexp -> functioncall .)
    LCURLY          reduce using rule 85 (prefixexp -> functioncall .)
    do              reduce using rule 85 (prefixexp -> functioncall .)
    COMMA           reduce using rule 85 (prefixexp -> functioncall .)
    PLUS            reduce using rule 85 (prefixexp -> functioncall .)
    MINUS           reduce using rule 85 (prefixexp -> functioncall .)
    TIMES           reduce using rule 85 (prefixexp -> functioncall .)
    DIVIDE          reduce using rule 85 (prefixexp -> functioncall .)
    POWER           reduce using rule 85 (prefixexp -> functioncall .)
    LT              reduce using rule 85 (prefixexp -> functioncall .)
    LE              reduce using rule 85 (prefixexp -> functioncall .)
    GT              reduce using rule 85 (prefixexp -> functioncall .)
    GE              reduce using rule 85 (prefixexp -> functioncall .)
    NE              reduce using rule 85 (prefixexp -> functioncall .)
    CHECKEQ         reduce using rule 85 (prefixexp -> functioncall .)
    and             reduce using rule 85 (prefixexp -> functioncall .)
    or              reduce using rule 85 (prefixexp -> functioncall .)
    MODULO          reduce using rule 85 (prefixexp -> functioncall .)
    DBLDOTS         reduce using rule 85 (prefixexp -> functioncall .)
    SEMI            reduce using rule 85 (prefixexp -> functioncall .)
    return          reduce using rule 85 (prefixexp -> functioncall .)
    break           reduce using rule 85 (prefixexp -> functioncall .)
    while           reduce using rule 85 (prefixexp -> functioncall .)
    repeat          reduce using rule 85 (prefixexp -> functioncall .)
    if              reduce using rule 85 (prefixexp -> functioncall .)
    for             reduce using rule 85 (prefixexp -> functioncall .)
    local           reduce using rule 85 (prefixexp -> functioncall .)
    function        reduce using rule 85 (prefixexp -> functioncall .)
    ID              reduce using rule 85 (prefixexp -> functioncall .)
    RESID           reduce using rule 85 (prefixexp -> functioncall .)
    $end            reduce using rule 85 (prefixexp -> functioncall .)
    end             reduce using rule 85 (prefixexp -> functioncall .)
    until           reduce using rule 85 (prefixexp -> functioncall .)
    else            reduce using rule 85 (prefixexp -> functioncall .)
    elseif          reduce using rule 85 (prefixexp -> functioncall .)
    then            reduce using rule 85 (prefixexp -> functioncall .)
    RCURLY          reduce using rule 85 (prefixexp -> functioncall .)
    RSQUARE         reduce using rule 85 (prefixexp -> functioncall .)
    RPAREN          reduce using rule 85 (prefixexp -> functioncall .)


state 36

    (84) prefixexp -> LPAREN exp . RPAREN
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    RPAREN          shift and go to state 74
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 37

    (78) exp -> unop . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    unop                           shift and go to state 37
    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    functioncall                   shift and go to state 35
    exp                            shift and go to state 88
    var                            shift and go to state 26
    names                          shift and go to state 4

state 38

    (59) exp -> TRPLDOTS .

    PLUS            reduce using rule 59 (exp -> TRPLDOTS .)
    MINUS           reduce using rule 59 (exp -> TRPLDOTS .)
    TIMES           reduce using rule 59 (exp -> TRPLDOTS .)
    DIVIDE          reduce using rule 59 (exp -> TRPLDOTS .)
    POWER           reduce using rule 59 (exp -> TRPLDOTS .)
    LT              reduce using rule 59 (exp -> TRPLDOTS .)
    LE              reduce using rule 59 (exp -> TRPLDOTS .)
    GT              reduce using rule 59 (exp -> TRPLDOTS .)
    GE              reduce using rule 59 (exp -> TRPLDOTS .)
    NE              reduce using rule 59 (exp -> TRPLDOTS .)
    CHECKEQ         reduce using rule 59 (exp -> TRPLDOTS .)
    and             reduce using rule 59 (exp -> TRPLDOTS .)
    or              reduce using rule 59 (exp -> TRPLDOTS .)
    MODULO          reduce using rule 59 (exp -> TRPLDOTS .)
    DBLDOTS         reduce using rule 59 (exp -> TRPLDOTS .)
    RPAREN          reduce using rule 59 (exp -> TRPLDOTS .)
    then            reduce using rule 59 (exp -> TRPLDOTS .)
    do              reduce using rule 59 (exp -> TRPLDOTS .)
    COMMA           reduce using rule 59 (exp -> TRPLDOTS .)
    SEMI            reduce using rule 59 (exp -> TRPLDOTS .)
    RCURLY          reduce using rule 59 (exp -> TRPLDOTS .)
    $end            reduce using rule 59 (exp -> TRPLDOTS .)
    end             reduce using rule 59 (exp -> TRPLDOTS .)
    until           reduce using rule 59 (exp -> TRPLDOTS .)
    else            reduce using rule 59 (exp -> TRPLDOTS .)
    elseif          reduce using rule 59 (exp -> TRPLDOTS .)
    RSQUARE         reduce using rule 59 (exp -> TRPLDOTS .)
    return          reduce using rule 59 (exp -> TRPLDOTS .)
    break           reduce using rule 59 (exp -> TRPLDOTS .)
    while           reduce using rule 59 (exp -> TRPLDOTS .)
    repeat          reduce using rule 59 (exp -> TRPLDOTS .)
    if              reduce using rule 59 (exp -> TRPLDOTS .)
    for             reduce using rule 59 (exp -> TRPLDOTS .)
    local           reduce using rule 59 (exp -> TRPLDOTS .)
    function        reduce using rule 59 (exp -> TRPLDOTS .)
    LPAREN          reduce using rule 59 (exp -> TRPLDOTS .)
    ID              reduce using rule 59 (exp -> TRPLDOTS .)
    RESID           reduce using rule 59 (exp -> TRPLDOTS .)


state 39

    (2) sdash -> chunk laststat .
    (3) sdash -> chunk laststat . SEMI

    else            reduce using rule 2 (sdash -> chunk laststat .)
    end             reduce using rule 2 (sdash -> chunk laststat .)
    elseif          reduce using rule 2 (sdash -> chunk laststat .)
    $end            reduce using rule 2 (sdash -> chunk laststat .)
    until           reduce using rule 2 (sdash -> chunk laststat .)
    SEMI            shift and go to state 89


state 40

    (4) chunk -> chunk stat .
    (5) chunk -> chunk stat . SEMI

    return          reduce using rule 4 (chunk -> chunk stat .)
    break           reduce using rule 4 (chunk -> chunk stat .)
    do              reduce using rule 4 (chunk -> chunk stat .)
    while           reduce using rule 4 (chunk -> chunk stat .)
    repeat          reduce using rule 4 (chunk -> chunk stat .)
    if              reduce using rule 4 (chunk -> chunk stat .)
    for             reduce using rule 4 (chunk -> chunk stat .)
    local           reduce using rule 4 (chunk -> chunk stat .)
    function        reduce using rule 4 (chunk -> chunk stat .)
    LPAREN          reduce using rule 4 (chunk -> chunk stat .)
    ID              reduce using rule 4 (chunk -> chunk stat .)
    RESID           reduce using rule 4 (chunk -> chunk stat .)
    end             reduce using rule 4 (chunk -> chunk stat .)
    else            reduce using rule 4 (chunk -> chunk stat .)
    elseif          reduce using rule 4 (chunk -> chunk stat .)
    until           reduce using rule 4 (chunk -> chunk stat .)
    $end            reduce using rule 4 (chunk -> chunk stat .)
    SEMI            shift and go to state 90


state 41

    (34) laststat -> return . explist
    (35) laststat -> return .
    (52) explist -> . explist COMMA exp
    (53) explist -> . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    SEMI            reduce using rule 35 (laststat -> return .)
    $end            reduce using rule 35 (laststat -> return .)
    end             reduce using rule 35 (laststat -> return .)
    until           reduce using rule 35 (laststat -> return .)
    else            reduce using rule 35 (laststat -> return .)
    elseif          reduce using rule 35 (laststat -> return .)
    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 92
    var                            shift and go to state 26
    explist                        shift and go to state 91
    names                          shift and go to state 4

state 42

    (36) laststat -> break .

    SEMI            reduce using rule 36 (laststat -> break .)
    $end            reduce using rule 36 (laststat -> break .)
    end             reduce using rule 36 (laststat -> break .)
    until           reduce using rule 36 (laststat -> break .)
    else            reduce using rule 36 (laststat -> break .)
    elseif          reduce using rule 36 (laststat -> break .)


state 43

    (14) stat -> if exp . then block ifblock else block end
    (15) stat -> if exp . then block ifblock end
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    then            shift and go to state 93
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 44

    (28) args -> tableconstructor .

    SEMI            reduce using rule 28 (args -> tableconstructor .)
    return          reduce using rule 28 (args -> tableconstructor .)
    break           reduce using rule 28 (args -> tableconstructor .)
    do              reduce using rule 28 (args -> tableconstructor .)
    while           reduce using rule 28 (args -> tableconstructor .)
    repeat          reduce using rule 28 (args -> tableconstructor .)
    if              reduce using rule 28 (args -> tableconstructor .)
    for             reduce using rule 28 (args -> tableconstructor .)
    local           reduce using rule 28 (args -> tableconstructor .)
    function        reduce using rule 28 (args -> tableconstructor .)
    LPAREN          reduce using rule 28 (args -> tableconstructor .)
    ID              reduce using rule 28 (args -> tableconstructor .)
    RESID           reduce using rule 28 (args -> tableconstructor .)
    $end            reduce using rule 28 (args -> tableconstructor .)
    LSQUARE         reduce using rule 28 (args -> tableconstructor .)
    SDOT            reduce using rule 28 (args -> tableconstructor .)
    STRING          reduce using rule 28 (args -> tableconstructor .)
    LCURLY          reduce using rule 28 (args -> tableconstructor .)
    end             reduce using rule 28 (args -> tableconstructor .)
    until           reduce using rule 28 (args -> tableconstructor .)
    else            reduce using rule 28 (args -> tableconstructor .)
    elseif          reduce using rule 28 (args -> tableconstructor .)
    RPAREN          reduce using rule 28 (args -> tableconstructor .)
    PLUS            reduce using rule 28 (args -> tableconstructor .)
    MINUS           reduce using rule 28 (args -> tableconstructor .)
    TIMES           reduce using rule 28 (args -> tableconstructor .)
    DIVIDE          reduce using rule 28 (args -> tableconstructor .)
    POWER           reduce using rule 28 (args -> tableconstructor .)
    LT              reduce using rule 28 (args -> tableconstructor .)
    LE              reduce using rule 28 (args -> tableconstructor .)
    GT              reduce using rule 28 (args -> tableconstructor .)
    GE              reduce using rule 28 (args -> tableconstructor .)
    NE              reduce using rule 28 (args -> tableconstructor .)
    CHECKEQ         reduce using rule 28 (args -> tableconstructor .)
    and             reduce using rule 28 (args -> tableconstructor .)
    or              reduce using rule 28 (args -> tableconstructor .)
    MODULO          reduce using rule 28 (args -> tableconstructor .)
    DBLDOTS         reduce using rule 28 (args -> tableconstructor .)
    then            reduce using rule 28 (args -> tableconstructor .)
    COMMA           reduce using rule 28 (args -> tableconstructor .)
    RCURLY          reduce using rule 28 (args -> tableconstructor .)
    RSQUARE         reduce using rule 28 (args -> tableconstructor .)


state 45

    (49) var -> prefixexp LSQUARE . exp RSQUARE
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 94
    var                            shift and go to state 26
    names                          shift and go to state 4

state 46

    (25) functioncall -> prefixexp args .

    LSQUARE         reduce using rule 25 (functioncall -> prefixexp args .)
    SDOT            reduce using rule 25 (functioncall -> prefixexp args .)
    LPAREN          reduce using rule 25 (functioncall -> prefixexp args .)
    STRING          reduce using rule 25 (functioncall -> prefixexp args .)
    LCURLY          reduce using rule 25 (functioncall -> prefixexp args .)
    PLUS            reduce using rule 25 (functioncall -> prefixexp args .)
    MINUS           reduce using rule 25 (functioncall -> prefixexp args .)
    TIMES           reduce using rule 25 (functioncall -> prefixexp args .)
    DIVIDE          reduce using rule 25 (functioncall -> prefixexp args .)
    POWER           reduce using rule 25 (functioncall -> prefixexp args .)
    LT              reduce using rule 25 (functioncall -> prefixexp args .)
    LE              reduce using rule 25 (functioncall -> prefixexp args .)
    GT              reduce using rule 25 (functioncall -> prefixexp args .)
    GE              reduce using rule 25 (functioncall -> prefixexp args .)
    NE              reduce using rule 25 (functioncall -> prefixexp args .)
    CHECKEQ         reduce using rule 25 (functioncall -> prefixexp args .)
    and             reduce using rule 25 (functioncall -> prefixexp args .)
    or              reduce using rule 25 (functioncall -> prefixexp args .)
    MODULO          reduce using rule 25 (functioncall -> prefixexp args .)
    DBLDOTS         reduce using rule 25 (functioncall -> prefixexp args .)
    RPAREN          reduce using rule 25 (functioncall -> prefixexp args .)
    COMMA           reduce using rule 25 (functioncall -> prefixexp args .)
    do              reduce using rule 25 (functioncall -> prefixexp args .)
    SEMI            reduce using rule 25 (functioncall -> prefixexp args .)
    return          reduce using rule 25 (functioncall -> prefixexp args .)
    break           reduce using rule 25 (functioncall -> prefixexp args .)
    while           reduce using rule 25 (functioncall -> prefixexp args .)
    repeat          reduce using rule 25 (functioncall -> prefixexp args .)
    if              reduce using rule 25 (functioncall -> prefixexp args .)
    for             reduce using rule 25 (functioncall -> prefixexp args .)
    local           reduce using rule 25 (functioncall -> prefixexp args .)
    function        reduce using rule 25 (functioncall -> prefixexp args .)
    ID              reduce using rule 25 (functioncall -> prefixexp args .)
    RESID           reduce using rule 25 (functioncall -> prefixexp args .)
    else            reduce using rule 25 (functioncall -> prefixexp args .)
    end             reduce using rule 25 (functioncall -> prefixexp args .)
    elseif          reduce using rule 25 (functioncall -> prefixexp args .)
    then            reduce using rule 25 (functioncall -> prefixexp args .)
    RCURLY          reduce using rule 25 (functioncall -> prefixexp args .)
    $end            reduce using rule 25 (functioncall -> prefixexp args .)
    until           reduce using rule 25 (functioncall -> prefixexp args .)
    RSQUARE         reduce using rule 25 (functioncall -> prefixexp args .)


state 47

    (26) args -> LPAREN . RPAREN
    (27) args -> LPAREN . explist RPAREN
    (52) explist -> . explist COMMA exp
    (53) explist -> . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    RPAREN          shift and go to state 95
    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 92
    var                            shift and go to state 26
    explist                        shift and go to state 96
    names                          shift and go to state 4

state 48

    (50) var -> prefixexp SDOT . names
    (100) names -> . ID
    (101) names -> . RESID

    ID              shift and go to state 15
    RESID           shift and go to state 1

    names                          shift and go to state 97

state 49

    (29) args -> STRING .

    SEMI            reduce using rule 29 (args -> STRING .)
    return          reduce using rule 29 (args -> STRING .)
    break           reduce using rule 29 (args -> STRING .)
    do              reduce using rule 29 (args -> STRING .)
    while           reduce using rule 29 (args -> STRING .)
    repeat          reduce using rule 29 (args -> STRING .)
    if              reduce using rule 29 (args -> STRING .)
    for             reduce using rule 29 (args -> STRING .)
    local           reduce using rule 29 (args -> STRING .)
    function        reduce using rule 29 (args -> STRING .)
    LPAREN          reduce using rule 29 (args -> STRING .)
    ID              reduce using rule 29 (args -> STRING .)
    RESID           reduce using rule 29 (args -> STRING .)
    $end            reduce using rule 29 (args -> STRING .)
    LSQUARE         reduce using rule 29 (args -> STRING .)
    SDOT            reduce using rule 29 (args -> STRING .)
    STRING          reduce using rule 29 (args -> STRING .)
    LCURLY          reduce using rule 29 (args -> STRING .)
    end             reduce using rule 29 (args -> STRING .)
    until           reduce using rule 29 (args -> STRING .)
    else            reduce using rule 29 (args -> STRING .)
    elseif          reduce using rule 29 (args -> STRING .)
    RPAREN          reduce using rule 29 (args -> STRING .)
    PLUS            reduce using rule 29 (args -> STRING .)
    MINUS           reduce using rule 29 (args -> STRING .)
    TIMES           reduce using rule 29 (args -> STRING .)
    DIVIDE          reduce using rule 29 (args -> STRING .)
    POWER           reduce using rule 29 (args -> STRING .)
    LT              reduce using rule 29 (args -> STRING .)
    LE              reduce using rule 29 (args -> STRING .)
    GT              reduce using rule 29 (args -> STRING .)
    GE              reduce using rule 29 (args -> STRING .)
    NE              reduce using rule 29 (args -> STRING .)
    CHECKEQ         reduce using rule 29 (args -> STRING .)
    and             reduce using rule 29 (args -> STRING .)
    or              reduce using rule 29 (args -> STRING .)
    MODULO          reduce using rule 29 (args -> STRING .)
    DBLDOTS         reduce using rule 29 (args -> STRING .)
    then            reduce using rule 29 (args -> STRING .)
    COMMA           reduce using rule 29 (args -> STRING .)
    RCURLY          reduce using rule 29 (args -> STRING .)
    RSQUARE         reduce using rule 29 (args -> STRING .)


state 50

    (18) stat -> for namelist . in explist do block end

    in              shift and go to state 98


state 51

    (16) stat -> for names . EQUALS exp COMMA exp do block end
    (17) stat -> for names . EQUALS exp COMMA exp COMMA exp do block end
    (51) namelist -> names . comid
    (43) comid -> . COMMA names comid
    (44) comid -> . empty
    (82) empty -> .

    EQUALS          shift and go to state 99
    COMMA           shift and go to state 101
    in              reduce using rule 82 (empty -> .)

    empty                          shift and go to state 100
    comid                          shift and go to state 102

state 52

    (9) stat -> varlist EQUALS . explist
    (52) explist -> . explist COMMA exp
    (53) explist -> . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 92
    var                            shift and go to state 26
    explist                        shift and go to state 103
    names                          shift and go to state 4

state 53

    (41) comvar -> COMMA . var comvar
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (100) names -> . ID
    (101) names -> . RESID
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (25) functioncall -> . prefixexp args

    ID              shift and go to state 15
    RESID           shift and go to state 1
    LPAREN          shift and go to state 2

    prefixexp                      shift and go to state 104
    functioncall                   shift and go to state 35
    names                          shift and go to state 4
    var                            shift and go to state 105

state 54

    (47) varlist -> var comvar .

    EQUALS          reduce using rule 47 (varlist -> var comvar .)


state 55

    (42) comvar -> empty .

    EQUALS          reduce using rule 42 (comvar -> empty .)


state 56

    (22) stat -> local function . names funcbody
    (100) names -> . ID
    (101) names -> . RESID

    ID              shift and go to state 15
    RESID           shift and go to state 1

    names                          shift and go to state 106

state 57

    (19) stat -> local namelist .
    (20) stat -> local namelist . EQUALS explist

    SEMI            reduce using rule 19 (stat -> local namelist .)
    return          reduce using rule 19 (stat -> local namelist .)
    break           reduce using rule 19 (stat -> local namelist .)
    do              reduce using rule 19 (stat -> local namelist .)
    while           reduce using rule 19 (stat -> local namelist .)
    repeat          reduce using rule 19 (stat -> local namelist .)
    if              reduce using rule 19 (stat -> local namelist .)
    for             reduce using rule 19 (stat -> local namelist .)
    local           reduce using rule 19 (stat -> local namelist .)
    function        reduce using rule 19 (stat -> local namelist .)
    LPAREN          reduce using rule 19 (stat -> local namelist .)
    ID              reduce using rule 19 (stat -> local namelist .)
    RESID           reduce using rule 19 (stat -> local namelist .)
    else            reduce using rule 19 (stat -> local namelist .)
    end             reduce using rule 19 (stat -> local namelist .)
    elseif          reduce using rule 19 (stat -> local namelist .)
    $end            reduce using rule 19 (stat -> local namelist .)
    until           reduce using rule 19 (stat -> local namelist .)
    EQUALS          shift and go to state 107


state 58

    (51) namelist -> names . comid
    (43) comid -> . COMMA names comid
    (44) comid -> . empty
    (82) empty -> .

    COMMA           shift and go to state 101
    EQUALS          reduce using rule 82 (empty -> .)
    SEMI            reduce using rule 82 (empty -> .)
    return          reduce using rule 82 (empty -> .)
    break           reduce using rule 82 (empty -> .)
    do              reduce using rule 82 (empty -> .)
    while           reduce using rule 82 (empty -> .)
    repeat          reduce using rule 82 (empty -> .)
    if              reduce using rule 82 (empty -> .)
    for             reduce using rule 82 (empty -> .)
    local           reduce using rule 82 (empty -> .)
    function        reduce using rule 82 (empty -> .)
    LPAREN          reduce using rule 82 (empty -> .)
    ID              reduce using rule 82 (empty -> .)
    RESID           reduce using rule 82 (empty -> .)
    $end            reduce using rule 82 (empty -> .)
    end             reduce using rule 82 (empty -> .)
    until           reduce using rule 82 (empty -> .)
    else            reduce using rule 82 (empty -> .)
    elseif          reduce using rule 82 (empty -> .)
    RPAREN          reduce using rule 82 (empty -> .)

  ! COMMA           [ reduce using rule 82 (empty -> .) ]

    empty                          shift and go to state 100
    comid                          shift and go to state 102

state 59

    (21) stat -> function funcname . funcbody
    (23) funcbody -> . LPAREN RPAREN block end
    (24) funcbody -> . LPAREN parlist RPAREN block end

    LPAREN          shift and go to state 109

    funcbody                       shift and go to state 108

state 60

    (37) funcname -> names . dotid COLON
    (38) funcname -> names .
    (39) dotid -> . SDOT names dotid
    (40) dotid -> . empty
    (82) empty -> .

    LPAREN          reduce using rule 38 (funcname -> names .)
    SDOT            shift and go to state 110
    COLON           reduce using rule 82 (empty -> .)

    dotid                          shift and go to state 111
    empty                          shift and go to state 112

state 61

    (8) block -> sdash .

    until           reduce using rule 8 (block -> sdash .)
    end             reduce using rule 8 (block -> sdash .)
    else            reduce using rule 8 (block -> sdash .)
    elseif          reduce using rule 8 (block -> sdash .)


state 62

    (10) stat -> do block . end

    end             shift and go to state 113


state 63

    (7) chunk -> stat SEMI .

    return          reduce using rule 7 (chunk -> stat SEMI .)
    break           reduce using rule 7 (chunk -> stat SEMI .)
    do              reduce using rule 7 (chunk -> stat SEMI .)
    while           reduce using rule 7 (chunk -> stat SEMI .)
    repeat          reduce using rule 7 (chunk -> stat SEMI .)
    if              reduce using rule 7 (chunk -> stat SEMI .)
    for             reduce using rule 7 (chunk -> stat SEMI .)
    local           reduce using rule 7 (chunk -> stat SEMI .)
    function        reduce using rule 7 (chunk -> stat SEMI .)
    LPAREN          reduce using rule 7 (chunk -> stat SEMI .)
    ID              reduce using rule 7 (chunk -> stat SEMI .)
    RESID           reduce using rule 7 (chunk -> stat SEMI .)
    end             reduce using rule 7 (chunk -> stat SEMI .)
    else            reduce using rule 7 (chunk -> stat SEMI .)
    elseif          reduce using rule 7 (chunk -> stat SEMI .)
    until           reduce using rule 7 (chunk -> stat SEMI .)
    $end            reduce using rule 7 (chunk -> stat SEMI .)


state 64

    (13) stat -> repeat block . until exp

    until           shift and go to state 114


state 65

    (12) stat -> while exp . do block end
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    do              shift and go to state 115
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 66

    (96) field -> names . EQUALS exp
    (48) var -> names .

    EQUALS          shift and go to state 116
    LSQUARE         reduce using rule 48 (var -> names .)
    SDOT            reduce using rule 48 (var -> names .)
    LPAREN          reduce using rule 48 (var -> names .)
    STRING          reduce using rule 48 (var -> names .)
    LCURLY          reduce using rule 48 (var -> names .)
    PLUS            reduce using rule 48 (var -> names .)
    MINUS           reduce using rule 48 (var -> names .)
    TIMES           reduce using rule 48 (var -> names .)
    DIVIDE          reduce using rule 48 (var -> names .)
    POWER           reduce using rule 48 (var -> names .)
    LT              reduce using rule 48 (var -> names .)
    LE              reduce using rule 48 (var -> names .)
    GT              reduce using rule 48 (var -> names .)
    GE              reduce using rule 48 (var -> names .)
    NE              reduce using rule 48 (var -> names .)
    CHECKEQ         reduce using rule 48 (var -> names .)
    and             reduce using rule 48 (var -> names .)
    or              reduce using rule 48 (var -> names .)
    MODULO          reduce using rule 48 (var -> names .)
    DBLDOTS         reduce using rule 48 (var -> names .)
    COMMA           reduce using rule 48 (var -> names .)
    SEMI            reduce using rule 48 (var -> names .)
    RCURLY          reduce using rule 48 (var -> names .)


state 67

    (90) tableconstructor -> LCURLY RCURLY .

    PLUS            reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    MINUS           reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    TIMES           reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    DIVIDE          reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    POWER           reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    LT              reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    LE              reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    GT              reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    GE              reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    NE              reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    CHECKEQ         reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    and             reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    or              reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    MODULO          reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    DBLDOTS         reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    RPAREN          reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    then            reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    do              reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    COMMA           reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    SEMI            reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    RCURLY          reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    $end            reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    end             reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    until           reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    else            reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    elseif          reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    RSQUARE         reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    return          reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    break           reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    while           reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    repeat          reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    if              reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    for             reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    local           reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    function        reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    LPAREN          reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    ID              reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    RESID           reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    LSQUARE         reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    SDOT            reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    STRING          reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)
    LCURLY          reduce using rule 90 (tableconstructor -> LCURLY RCURLY .)


state 68

    (91) fieldlist -> field . fieldseplist fieldsep
    (92) fieldlist -> field . fieldseplist
    (93) fieldseplist -> . fieldseplist fieldsep field
    (94) fieldseplist -> . empty
    (82) empty -> .

    COMMA           reduce using rule 82 (empty -> .)
    SEMI            reduce using rule 82 (empty -> .)
    RCURLY          reduce using rule 82 (empty -> .)

    fieldseplist                   shift and go to state 117
    empty                          shift and go to state 118

state 69

    (89) tableconstructor -> LCURLY fieldlist . RCURLY

    RCURLY          shift and go to state 119


state 70

    (97) field -> exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 97 (field -> exp .)
    SEMI            reduce using rule 97 (field -> exp .)
    RCURLY          reduce using rule 97 (field -> exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 71

    (95) field -> LSQUARE . exp RSQUARE EQUALS exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 120
    var                            shift and go to state 26
    names                          shift and go to state 4

state 72

    (73) exp -> exp and . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 121
    var                            shift and go to state 26
    names                          shift and go to state 4

state 73

    (68) exp -> exp LE . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 122
    var                            shift and go to state 26
    names                          shift and go to state 4

state 74

    (84) prefixexp -> LPAREN exp RPAREN .

    LSQUARE         reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    SDOT            reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    STRING          reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    LCURLY          reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    do              reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    POWER           reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    LE              reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    GE              reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    CHECKEQ         reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    and             reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    or              reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    MODULO          reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    DBLDOTS         reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    SEMI            reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    return          reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    break           reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    while           reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    repeat          reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    if              reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    for             reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    local           reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    function        reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    RESID           reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    $end            reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    end             reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    until           reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    else            reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    elseif          reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    then            reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    RCURLY          reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    RSQUARE         reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 84 (prefixexp -> LPAREN exp RPAREN .)


state 75

    (66) exp -> exp POWER . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 123
    var                            shift and go to state 26
    names                          shift and go to state 4

state 76

    (74) exp -> exp or . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 124
    var                            shift and go to state 26
    names                          shift and go to state 4

state 77

    (70) exp -> exp GE . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 125
    var                            shift and go to state 26
    names                          shift and go to state 4

state 78

    (64) exp -> exp TIMES . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 126
    var                            shift and go to state 26
    names                          shift and go to state 4

state 79

    (72) exp -> exp CHECKEQ . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 127
    var                            shift and go to state 26
    names                          shift and go to state 4

state 80

    (67) exp -> exp LT . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 128
    var                            shift and go to state 26
    names                          shift and go to state 4

state 81

    (69) exp -> exp GT . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 129
    var                            shift and go to state 26
    names                          shift and go to state 4

state 82

    (62) exp -> exp PLUS . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 130
    var                            shift and go to state 26
    names                          shift and go to state 4

state 83

    (75) exp -> exp MODULO . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 131
    var                            shift and go to state 26
    names                          shift and go to state 4

state 84

    (76) exp -> exp DBLDOTS . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 132
    var                            shift and go to state 26
    names                          shift and go to state 4

state 85

    (63) exp -> exp MINUS . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 133
    var                            shift and go to state 26
    names                          shift and go to state 4

state 86

    (71) exp -> exp NE . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 134
    var                            shift and go to state 26
    names                          shift and go to state 4

state 87

    (65) exp -> exp DIVIDE . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 135
    var                            shift and go to state 26
    names                          shift and go to state 4

state 88

    (78) exp -> unop exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 78 (exp -> unop exp .)
    MINUS           reduce using rule 78 (exp -> unop exp .)
    TIMES           reduce using rule 78 (exp -> unop exp .)
    DIVIDE          reduce using rule 78 (exp -> unop exp .)
    LT              reduce using rule 78 (exp -> unop exp .)
    LE              reduce using rule 78 (exp -> unop exp .)
    GT              reduce using rule 78 (exp -> unop exp .)
    GE              reduce using rule 78 (exp -> unop exp .)
    NE              reduce using rule 78 (exp -> unop exp .)
    CHECKEQ         reduce using rule 78 (exp -> unop exp .)
    and             reduce using rule 78 (exp -> unop exp .)
    or              reduce using rule 78 (exp -> unop exp .)
    MODULO          reduce using rule 78 (exp -> unop exp .)
    DBLDOTS         reduce using rule 78 (exp -> unop exp .)
    RPAREN          reduce using rule 78 (exp -> unop exp .)
    then            reduce using rule 78 (exp -> unop exp .)
    do              reduce using rule 78 (exp -> unop exp .)
    COMMA           reduce using rule 78 (exp -> unop exp .)
    SEMI            reduce using rule 78 (exp -> unop exp .)
    RCURLY          reduce using rule 78 (exp -> unop exp .)
    $end            reduce using rule 78 (exp -> unop exp .)
    end             reduce using rule 78 (exp -> unop exp .)
    until           reduce using rule 78 (exp -> unop exp .)
    else            reduce using rule 78 (exp -> unop exp .)
    elseif          reduce using rule 78 (exp -> unop exp .)
    RSQUARE         reduce using rule 78 (exp -> unop exp .)
    return          reduce using rule 78 (exp -> unop exp .)
    break           reduce using rule 78 (exp -> unop exp .)
    while           reduce using rule 78 (exp -> unop exp .)
    repeat          reduce using rule 78 (exp -> unop exp .)
    if              reduce using rule 78 (exp -> unop exp .)
    for             reduce using rule 78 (exp -> unop exp .)
    local           reduce using rule 78 (exp -> unop exp .)
    function        reduce using rule 78 (exp -> unop exp .)
    LPAREN          reduce using rule 78 (exp -> unop exp .)
    ID              reduce using rule 78 (exp -> unop exp .)
    RESID           reduce using rule 78 (exp -> unop exp .)
    POWER           shift and go to state 75

  ! POWER           [ reduce using rule 78 (exp -> unop exp .) ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 85 ]
  ! TIMES           [ shift and go to state 78 ]
  ! DIVIDE          [ shift and go to state 87 ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]
  ! MODULO          [ shift and go to state 83 ]
  ! DBLDOTS         [ shift and go to state 84 ]


state 89

    (3) sdash -> chunk laststat SEMI .

    else            reduce using rule 3 (sdash -> chunk laststat SEMI .)
    end             reduce using rule 3 (sdash -> chunk laststat SEMI .)
    elseif          reduce using rule 3 (sdash -> chunk laststat SEMI .)
    $end            reduce using rule 3 (sdash -> chunk laststat SEMI .)
    until           reduce using rule 3 (sdash -> chunk laststat SEMI .)


state 90

    (5) chunk -> chunk stat SEMI .

    return          reduce using rule 5 (chunk -> chunk stat SEMI .)
    break           reduce using rule 5 (chunk -> chunk stat SEMI .)
    do              reduce using rule 5 (chunk -> chunk stat SEMI .)
    while           reduce using rule 5 (chunk -> chunk stat SEMI .)
    repeat          reduce using rule 5 (chunk -> chunk stat SEMI .)
    if              reduce using rule 5 (chunk -> chunk stat SEMI .)
    for             reduce using rule 5 (chunk -> chunk stat SEMI .)
    local           reduce using rule 5 (chunk -> chunk stat SEMI .)
    function        reduce using rule 5 (chunk -> chunk stat SEMI .)
    LPAREN          reduce using rule 5 (chunk -> chunk stat SEMI .)
    ID              reduce using rule 5 (chunk -> chunk stat SEMI .)
    RESID           reduce using rule 5 (chunk -> chunk stat SEMI .)
    end             reduce using rule 5 (chunk -> chunk stat SEMI .)
    else            reduce using rule 5 (chunk -> chunk stat SEMI .)
    elseif          reduce using rule 5 (chunk -> chunk stat SEMI .)
    until           reduce using rule 5 (chunk -> chunk stat SEMI .)
    $end            reduce using rule 5 (chunk -> chunk stat SEMI .)


state 91

    (34) laststat -> return explist .
    (52) explist -> explist . COMMA exp

    SEMI            reduce using rule 34 (laststat -> return explist .)
    $end            reduce using rule 34 (laststat -> return explist .)
    end             reduce using rule 34 (laststat -> return explist .)
    until           reduce using rule 34 (laststat -> return explist .)
    else            reduce using rule 34 (laststat -> return explist .)
    elseif          reduce using rule 34 (laststat -> return explist .)
    COMMA           shift and go to state 136


state 92

    (53) explist -> exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    do              reduce using rule 53 (explist -> exp .)
    COMMA           reduce using rule 53 (explist -> exp .)
    SEMI            reduce using rule 53 (explist -> exp .)
    $end            reduce using rule 53 (explist -> exp .)
    end             reduce using rule 53 (explist -> exp .)
    until           reduce using rule 53 (explist -> exp .)
    else            reduce using rule 53 (explist -> exp .)
    elseif          reduce using rule 53 (explist -> exp .)
    RPAREN          reduce using rule 53 (explist -> exp .)
    return          reduce using rule 53 (explist -> exp .)
    break           reduce using rule 53 (explist -> exp .)
    while           reduce using rule 53 (explist -> exp .)
    repeat          reduce using rule 53 (explist -> exp .)
    if              reduce using rule 53 (explist -> exp .)
    for             reduce using rule 53 (explist -> exp .)
    local           reduce using rule 53 (explist -> exp .)
    function        reduce using rule 53 (explist -> exp .)
    LPAREN          reduce using rule 53 (explist -> exp .)
    ID              reduce using rule 53 (explist -> exp .)
    RESID           reduce using rule 53 (explist -> exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 93

    (14) stat -> if exp then . block ifblock else block end
    (15) stat -> if exp then . block ifblock end
    (8) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    block                          shift and go to state 137
    var                            shift and go to state 9
    sdash                          shift and go to state 61
    names                          shift and go to state 4

state 94

    (49) var -> prefixexp LSQUARE exp . RSQUARE
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    RSQUARE         shift and go to state 138
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 95

    (26) args -> LPAREN RPAREN .

    SEMI            reduce using rule 26 (args -> LPAREN RPAREN .)
    return          reduce using rule 26 (args -> LPAREN RPAREN .)
    break           reduce using rule 26 (args -> LPAREN RPAREN .)
    do              reduce using rule 26 (args -> LPAREN RPAREN .)
    while           reduce using rule 26 (args -> LPAREN RPAREN .)
    repeat          reduce using rule 26 (args -> LPAREN RPAREN .)
    if              reduce using rule 26 (args -> LPAREN RPAREN .)
    for             reduce using rule 26 (args -> LPAREN RPAREN .)
    local           reduce using rule 26 (args -> LPAREN RPAREN .)
    function        reduce using rule 26 (args -> LPAREN RPAREN .)
    LPAREN          reduce using rule 26 (args -> LPAREN RPAREN .)
    ID              reduce using rule 26 (args -> LPAREN RPAREN .)
    RESID           reduce using rule 26 (args -> LPAREN RPAREN .)
    $end            reduce using rule 26 (args -> LPAREN RPAREN .)
    LSQUARE         reduce using rule 26 (args -> LPAREN RPAREN .)
    SDOT            reduce using rule 26 (args -> LPAREN RPAREN .)
    STRING          reduce using rule 26 (args -> LPAREN RPAREN .)
    LCURLY          reduce using rule 26 (args -> LPAREN RPAREN .)
    end             reduce using rule 26 (args -> LPAREN RPAREN .)
    until           reduce using rule 26 (args -> LPAREN RPAREN .)
    else            reduce using rule 26 (args -> LPAREN RPAREN .)
    elseif          reduce using rule 26 (args -> LPAREN RPAREN .)
    RPAREN          reduce using rule 26 (args -> LPAREN RPAREN .)
    PLUS            reduce using rule 26 (args -> LPAREN RPAREN .)
    MINUS           reduce using rule 26 (args -> LPAREN RPAREN .)
    TIMES           reduce using rule 26 (args -> LPAREN RPAREN .)
    DIVIDE          reduce using rule 26 (args -> LPAREN RPAREN .)
    POWER           reduce using rule 26 (args -> LPAREN RPAREN .)
    LT              reduce using rule 26 (args -> LPAREN RPAREN .)
    LE              reduce using rule 26 (args -> LPAREN RPAREN .)
    GT              reduce using rule 26 (args -> LPAREN RPAREN .)
    GE              reduce using rule 26 (args -> LPAREN RPAREN .)
    NE              reduce using rule 26 (args -> LPAREN RPAREN .)
    CHECKEQ         reduce using rule 26 (args -> LPAREN RPAREN .)
    and             reduce using rule 26 (args -> LPAREN RPAREN .)
    or              reduce using rule 26 (args -> LPAREN RPAREN .)
    MODULO          reduce using rule 26 (args -> LPAREN RPAREN .)
    DBLDOTS         reduce using rule 26 (args -> LPAREN RPAREN .)
    then            reduce using rule 26 (args -> LPAREN RPAREN .)
    COMMA           reduce using rule 26 (args -> LPAREN RPAREN .)
    RCURLY          reduce using rule 26 (args -> LPAREN RPAREN .)
    RSQUARE         reduce using rule 26 (args -> LPAREN RPAREN .)


state 96

    (27) args -> LPAREN explist . RPAREN
    (52) explist -> explist . COMMA exp

    RPAREN          shift and go to state 139
    COMMA           shift and go to state 136


state 97

    (50) var -> prefixexp SDOT names .

    COMMA           reduce using rule 50 (var -> prefixexp SDOT names .)
    EQUALS          reduce using rule 50 (var -> prefixexp SDOT names .)
    LSQUARE         reduce using rule 50 (var -> prefixexp SDOT names .)
    SDOT            reduce using rule 50 (var -> prefixexp SDOT names .)
    LPAREN          reduce using rule 50 (var -> prefixexp SDOT names .)
    STRING          reduce using rule 50 (var -> prefixexp SDOT names .)
    LCURLY          reduce using rule 50 (var -> prefixexp SDOT names .)
    then            reduce using rule 50 (var -> prefixexp SDOT names .)
    PLUS            reduce using rule 50 (var -> prefixexp SDOT names .)
    MINUS           reduce using rule 50 (var -> prefixexp SDOT names .)
    TIMES           reduce using rule 50 (var -> prefixexp SDOT names .)
    DIVIDE          reduce using rule 50 (var -> prefixexp SDOT names .)
    POWER           reduce using rule 50 (var -> prefixexp SDOT names .)
    LT              reduce using rule 50 (var -> prefixexp SDOT names .)
    LE              reduce using rule 50 (var -> prefixexp SDOT names .)
    GT              reduce using rule 50 (var -> prefixexp SDOT names .)
    GE              reduce using rule 50 (var -> prefixexp SDOT names .)
    NE              reduce using rule 50 (var -> prefixexp SDOT names .)
    CHECKEQ         reduce using rule 50 (var -> prefixexp SDOT names .)
    and             reduce using rule 50 (var -> prefixexp SDOT names .)
    or              reduce using rule 50 (var -> prefixexp SDOT names .)
    MODULO          reduce using rule 50 (var -> prefixexp SDOT names .)
    DBLDOTS         reduce using rule 50 (var -> prefixexp SDOT names .)
    do              reduce using rule 50 (var -> prefixexp SDOT names .)
    SEMI            reduce using rule 50 (var -> prefixexp SDOT names .)
    RCURLY          reduce using rule 50 (var -> prefixexp SDOT names .)
    RPAREN          reduce using rule 50 (var -> prefixexp SDOT names .)
    $end            reduce using rule 50 (var -> prefixexp SDOT names .)
    end             reduce using rule 50 (var -> prefixexp SDOT names .)
    until           reduce using rule 50 (var -> prefixexp SDOT names .)
    else            reduce using rule 50 (var -> prefixexp SDOT names .)
    elseif          reduce using rule 50 (var -> prefixexp SDOT names .)
    RSQUARE         reduce using rule 50 (var -> prefixexp SDOT names .)
    return          reduce using rule 50 (var -> prefixexp SDOT names .)
    break           reduce using rule 50 (var -> prefixexp SDOT names .)
    while           reduce using rule 50 (var -> prefixexp SDOT names .)
    repeat          reduce using rule 50 (var -> prefixexp SDOT names .)
    if              reduce using rule 50 (var -> prefixexp SDOT names .)
    for             reduce using rule 50 (var -> prefixexp SDOT names .)
    local           reduce using rule 50 (var -> prefixexp SDOT names .)
    function        reduce using rule 50 (var -> prefixexp SDOT names .)
    ID              reduce using rule 50 (var -> prefixexp SDOT names .)
    RESID           reduce using rule 50 (var -> prefixexp SDOT names .)


state 98

    (18) stat -> for namelist in . explist do block end
    (52) explist -> . explist COMMA exp
    (53) explist -> . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 92
    var                            shift and go to state 26
    explist                        shift and go to state 140
    names                          shift and go to state 4

state 99

    (16) stat -> for names EQUALS . exp COMMA exp do block end
    (17) stat -> for names EQUALS . exp COMMA exp COMMA exp do block end
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    names                          shift and go to state 4
    exp                            shift and go to state 141
    var                            shift and go to state 26

state 100

    (44) comid -> empty .

    in              reduce using rule 44 (comid -> empty .)
    EQUALS          reduce using rule 44 (comid -> empty .)
    SEMI            reduce using rule 44 (comid -> empty .)
    return          reduce using rule 44 (comid -> empty .)
    break           reduce using rule 44 (comid -> empty .)
    do              reduce using rule 44 (comid -> empty .)
    while           reduce using rule 44 (comid -> empty .)
    repeat          reduce using rule 44 (comid -> empty .)
    if              reduce using rule 44 (comid -> empty .)
    for             reduce using rule 44 (comid -> empty .)
    local           reduce using rule 44 (comid -> empty .)
    function        reduce using rule 44 (comid -> empty .)
    LPAREN          reduce using rule 44 (comid -> empty .)
    ID              reduce using rule 44 (comid -> empty .)
    RESID           reduce using rule 44 (comid -> empty .)
    $end            reduce using rule 44 (comid -> empty .)
    end             reduce using rule 44 (comid -> empty .)
    until           reduce using rule 44 (comid -> empty .)
    else            reduce using rule 44 (comid -> empty .)
    elseif          reduce using rule 44 (comid -> empty .)
    COMMA           reduce using rule 44 (comid -> empty .)
    RPAREN          reduce using rule 44 (comid -> empty .)


state 101

    (43) comid -> COMMA . names comid
    (100) names -> . ID
    (101) names -> . RESID

    ID              shift and go to state 15
    RESID           shift and go to state 1

    names                          shift and go to state 142

state 102

    (51) namelist -> names comid .

    COMMA           reduce using rule 51 (namelist -> names comid .)
    RPAREN          reduce using rule 51 (namelist -> names comid .)
    EQUALS          reduce using rule 51 (namelist -> names comid .)
    SEMI            reduce using rule 51 (namelist -> names comid .)
    return          reduce using rule 51 (namelist -> names comid .)
    break           reduce using rule 51 (namelist -> names comid .)
    do              reduce using rule 51 (namelist -> names comid .)
    while           reduce using rule 51 (namelist -> names comid .)
    repeat          reduce using rule 51 (namelist -> names comid .)
    if              reduce using rule 51 (namelist -> names comid .)
    for             reduce using rule 51 (namelist -> names comid .)
    local           reduce using rule 51 (namelist -> names comid .)
    function        reduce using rule 51 (namelist -> names comid .)
    LPAREN          reduce using rule 51 (namelist -> names comid .)
    ID              reduce using rule 51 (namelist -> names comid .)
    RESID           reduce using rule 51 (namelist -> names comid .)
    $end            reduce using rule 51 (namelist -> names comid .)
    end             reduce using rule 51 (namelist -> names comid .)
    until           reduce using rule 51 (namelist -> names comid .)
    else            reduce using rule 51 (namelist -> names comid .)
    elseif          reduce using rule 51 (namelist -> names comid .)
    in              reduce using rule 51 (namelist -> names comid .)


state 103

    (9) stat -> varlist EQUALS explist .
    (52) explist -> explist . COMMA exp

    SEMI            reduce using rule 9 (stat -> varlist EQUALS explist .)
    return          reduce using rule 9 (stat -> varlist EQUALS explist .)
    break           reduce using rule 9 (stat -> varlist EQUALS explist .)
    do              reduce using rule 9 (stat -> varlist EQUALS explist .)
    while           reduce using rule 9 (stat -> varlist EQUALS explist .)
    repeat          reduce using rule 9 (stat -> varlist EQUALS explist .)
    if              reduce using rule 9 (stat -> varlist EQUALS explist .)
    for             reduce using rule 9 (stat -> varlist EQUALS explist .)
    local           reduce using rule 9 (stat -> varlist EQUALS explist .)
    function        reduce using rule 9 (stat -> varlist EQUALS explist .)
    LPAREN          reduce using rule 9 (stat -> varlist EQUALS explist .)
    ID              reduce using rule 9 (stat -> varlist EQUALS explist .)
    RESID           reduce using rule 9 (stat -> varlist EQUALS explist .)
    else            reduce using rule 9 (stat -> varlist EQUALS explist .)
    end             reduce using rule 9 (stat -> varlist EQUALS explist .)
    elseif          reduce using rule 9 (stat -> varlist EQUALS explist .)
    $end            reduce using rule 9 (stat -> varlist EQUALS explist .)
    until           reduce using rule 9 (stat -> varlist EQUALS explist .)
    COMMA           shift and go to state 136


state 104

    (49) var -> prefixexp . LSQUARE exp RSQUARE
    (50) var -> prefixexp . SDOT names
    (25) functioncall -> prefixexp . args
    (26) args -> . LPAREN RPAREN
    (27) args -> . LPAREN explist RPAREN
    (28) args -> . tableconstructor
    (29) args -> . STRING
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY

    LSQUARE         shift and go to state 45
    SDOT            shift and go to state 48
    LPAREN          shift and go to state 47
    STRING          shift and go to state 49
    LCURLY          shift and go to state 21

    tableconstructor               shift and go to state 44
    args                           shift and go to state 46

state 105

    (41) comvar -> COMMA var . comvar
    (83) prefixexp -> var .
    (41) comvar -> . COMMA var comvar
    (42) comvar -> . empty
    (82) empty -> .

    LSQUARE         reduce using rule 83 (prefixexp -> var .)
    SDOT            reduce using rule 83 (prefixexp -> var .)
    LPAREN          reduce using rule 83 (prefixexp -> var .)
    STRING          reduce using rule 83 (prefixexp -> var .)
    LCURLY          reduce using rule 83 (prefixexp -> var .)
    COMMA           shift and go to state 53
    EQUALS          reduce using rule 82 (empty -> .)

    comvar                         shift and go to state 143
    empty                          shift and go to state 55

state 106

    (22) stat -> local function names . funcbody
    (23) funcbody -> . LPAREN RPAREN block end
    (24) funcbody -> . LPAREN parlist RPAREN block end

    LPAREN          shift and go to state 109

    funcbody                       shift and go to state 144

state 107

    (20) stat -> local namelist EQUALS . explist
    (52) explist -> . explist COMMA exp
    (53) explist -> . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 92
    var                            shift and go to state 26
    explist                        shift and go to state 145
    names                          shift and go to state 4

state 108

    (21) stat -> function funcname funcbody .

    SEMI            reduce using rule 21 (stat -> function funcname funcbody .)
    return          reduce using rule 21 (stat -> function funcname funcbody .)
    break           reduce using rule 21 (stat -> function funcname funcbody .)
    do              reduce using rule 21 (stat -> function funcname funcbody .)
    while           reduce using rule 21 (stat -> function funcname funcbody .)
    repeat          reduce using rule 21 (stat -> function funcname funcbody .)
    if              reduce using rule 21 (stat -> function funcname funcbody .)
    for             reduce using rule 21 (stat -> function funcname funcbody .)
    local           reduce using rule 21 (stat -> function funcname funcbody .)
    function        reduce using rule 21 (stat -> function funcname funcbody .)
    LPAREN          reduce using rule 21 (stat -> function funcname funcbody .)
    ID              reduce using rule 21 (stat -> function funcname funcbody .)
    RESID           reduce using rule 21 (stat -> function funcname funcbody .)
    else            reduce using rule 21 (stat -> function funcname funcbody .)
    end             reduce using rule 21 (stat -> function funcname funcbody .)
    elseif          reduce using rule 21 (stat -> function funcname funcbody .)
    $end            reduce using rule 21 (stat -> function funcname funcbody .)
    until           reduce using rule 21 (stat -> function funcname funcbody .)


state 109

    (23) funcbody -> LPAREN . RPAREN block end
    (24) funcbody -> LPAREN . parlist RPAREN block end
    (30) parlist -> . namelist
    (31) parlist -> . namelist comtrp
    (32) parlist -> . TRPLDOTS
    (51) namelist -> . names comid
    (100) names -> . ID
    (101) names -> . RESID

    RPAREN          shift and go to state 149
    TRPLDOTS        shift and go to state 147
    ID              shift and go to state 15
    RESID           shift and go to state 1

    namelist                       shift and go to state 146
    parlist                        shift and go to state 148
    names                          shift and go to state 58

state 110

    (39) dotid -> SDOT . names dotid
    (100) names -> . ID
    (101) names -> . RESID

    ID              shift and go to state 15
    RESID           shift and go to state 1

    names                          shift and go to state 150

state 111

    (37) funcname -> names dotid . COLON

    COLON           shift and go to state 151


state 112

    (40) dotid -> empty .

    COLON           reduce using rule 40 (dotid -> empty .)


state 113

    (10) stat -> do block end .

    SEMI            reduce using rule 10 (stat -> do block end .)
    return          reduce using rule 10 (stat -> do block end .)
    break           reduce using rule 10 (stat -> do block end .)
    do              reduce using rule 10 (stat -> do block end .)
    while           reduce using rule 10 (stat -> do block end .)
    repeat          reduce using rule 10 (stat -> do block end .)
    if              reduce using rule 10 (stat -> do block end .)
    for             reduce using rule 10 (stat -> do block end .)
    local           reduce using rule 10 (stat -> do block end .)
    function        reduce using rule 10 (stat -> do block end .)
    LPAREN          reduce using rule 10 (stat -> do block end .)
    ID              reduce using rule 10 (stat -> do block end .)
    RESID           reduce using rule 10 (stat -> do block end .)
    else            reduce using rule 10 (stat -> do block end .)
    end             reduce using rule 10 (stat -> do block end .)
    elseif          reduce using rule 10 (stat -> do block end .)
    $end            reduce using rule 10 (stat -> do block end .)
    until           reduce using rule 10 (stat -> do block end .)


state 114

    (13) stat -> repeat block until . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 152
    var                            shift and go to state 26
    names                          shift and go to state 4

state 115

    (12) stat -> while exp do . block end
    (8) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    sdash                          shift and go to state 61
    var                            shift and go to state 9
    block                          shift and go to state 153
    names                          shift and go to state 4

state 116

    (96) field -> names EQUALS . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    names                          shift and go to state 4
    exp                            shift and go to state 154
    var                            shift and go to state 26

state 117

    (91) fieldlist -> field fieldseplist . fieldsep
    (92) fieldlist -> field fieldseplist .
    (93) fieldseplist -> fieldseplist . fieldsep field
    (98) fieldsep -> . COMMA
    (99) fieldsep -> . SEMI

    RCURLY          reduce using rule 92 (fieldlist -> field fieldseplist .)
    COMMA           shift and go to state 156
    SEMI            shift and go to state 157

    fieldsep                       shift and go to state 155

state 118

    (94) fieldseplist -> empty .

    COMMA           reduce using rule 94 (fieldseplist -> empty .)
    SEMI            reduce using rule 94 (fieldseplist -> empty .)
    RCURLY          reduce using rule 94 (fieldseplist -> empty .)


state 119

    (89) tableconstructor -> LCURLY fieldlist RCURLY .

    PLUS            reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    MINUS           reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    TIMES           reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    DIVIDE          reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    POWER           reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LT              reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LE              reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    GT              reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    GE              reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    NE              reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    CHECKEQ         reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    and             reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    or              reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    MODULO          reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    DBLDOTS         reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RPAREN          reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    then            reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    do              reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    COMMA           reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    SEMI            reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RCURLY          reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    $end            reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    end             reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    until           reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    else            reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    elseif          reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RSQUARE         reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    return          reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    break           reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    while           reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    repeat          reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    if              reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    for             reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    local           reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    function        reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LPAREN          reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    ID              reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RESID           reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LSQUARE         reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    SDOT            reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    STRING          reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LCURLY          reduce using rule 89 (tableconstructor -> LCURLY fieldlist RCURLY .)


state 120

    (95) field -> LSQUARE exp . RSQUARE EQUALS exp
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    RSQUARE         shift and go to state 158
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 121

    (73) exp -> exp and exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    LT              reduce using rule 73 (exp -> exp and exp .)
    LE              reduce using rule 73 (exp -> exp and exp .)
    GT              reduce using rule 73 (exp -> exp and exp .)
    GE              reduce using rule 73 (exp -> exp and exp .)
    NE              reduce using rule 73 (exp -> exp and exp .)
    CHECKEQ         reduce using rule 73 (exp -> exp and exp .)
    and             reduce using rule 73 (exp -> exp and exp .)
    or              reduce using rule 73 (exp -> exp and exp .)
    RPAREN          reduce using rule 73 (exp -> exp and exp .)
    then            reduce using rule 73 (exp -> exp and exp .)
    do              reduce using rule 73 (exp -> exp and exp .)
    COMMA           reduce using rule 73 (exp -> exp and exp .)
    SEMI            reduce using rule 73 (exp -> exp and exp .)
    RCURLY          reduce using rule 73 (exp -> exp and exp .)
    $end            reduce using rule 73 (exp -> exp and exp .)
    end             reduce using rule 73 (exp -> exp and exp .)
    until           reduce using rule 73 (exp -> exp and exp .)
    else            reduce using rule 73 (exp -> exp and exp .)
    elseif          reduce using rule 73 (exp -> exp and exp .)
    RSQUARE         reduce using rule 73 (exp -> exp and exp .)
    return          reduce using rule 73 (exp -> exp and exp .)
    break           reduce using rule 73 (exp -> exp and exp .)
    while           reduce using rule 73 (exp -> exp and exp .)
    repeat          reduce using rule 73 (exp -> exp and exp .)
    if              reduce using rule 73 (exp -> exp and exp .)
    for             reduce using rule 73 (exp -> exp and exp .)
    local           reduce using rule 73 (exp -> exp and exp .)
    function        reduce using rule 73 (exp -> exp and exp .)
    LPAREN          reduce using rule 73 (exp -> exp and exp .)
    ID              reduce using rule 73 (exp -> exp and exp .)
    RESID           reduce using rule 73 (exp -> exp and exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84

  ! PLUS            [ reduce using rule 73 (exp -> exp and exp .) ]
  ! MINUS           [ reduce using rule 73 (exp -> exp and exp .) ]
  ! TIMES           [ reduce using rule 73 (exp -> exp and exp .) ]
  ! DIVIDE          [ reduce using rule 73 (exp -> exp and exp .) ]
  ! POWER           [ reduce using rule 73 (exp -> exp and exp .) ]
  ! MODULO          [ reduce using rule 73 (exp -> exp and exp .) ]
  ! DBLDOTS         [ reduce using rule 73 (exp -> exp and exp .) ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]


state 122

    (68) exp -> exp LE exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    LT              reduce using rule 68 (exp -> exp LE exp .)
    LE              reduce using rule 68 (exp -> exp LE exp .)
    GT              reduce using rule 68 (exp -> exp LE exp .)
    GE              reduce using rule 68 (exp -> exp LE exp .)
    NE              reduce using rule 68 (exp -> exp LE exp .)
    CHECKEQ         reduce using rule 68 (exp -> exp LE exp .)
    and             reduce using rule 68 (exp -> exp LE exp .)
    or              reduce using rule 68 (exp -> exp LE exp .)
    RPAREN          reduce using rule 68 (exp -> exp LE exp .)
    then            reduce using rule 68 (exp -> exp LE exp .)
    do              reduce using rule 68 (exp -> exp LE exp .)
    COMMA           reduce using rule 68 (exp -> exp LE exp .)
    SEMI            reduce using rule 68 (exp -> exp LE exp .)
    RCURLY          reduce using rule 68 (exp -> exp LE exp .)
    $end            reduce using rule 68 (exp -> exp LE exp .)
    end             reduce using rule 68 (exp -> exp LE exp .)
    until           reduce using rule 68 (exp -> exp LE exp .)
    else            reduce using rule 68 (exp -> exp LE exp .)
    elseif          reduce using rule 68 (exp -> exp LE exp .)
    RSQUARE         reduce using rule 68 (exp -> exp LE exp .)
    return          reduce using rule 68 (exp -> exp LE exp .)
    break           reduce using rule 68 (exp -> exp LE exp .)
    while           reduce using rule 68 (exp -> exp LE exp .)
    repeat          reduce using rule 68 (exp -> exp LE exp .)
    if              reduce using rule 68 (exp -> exp LE exp .)
    for             reduce using rule 68 (exp -> exp LE exp .)
    local           reduce using rule 68 (exp -> exp LE exp .)
    function        reduce using rule 68 (exp -> exp LE exp .)
    LPAREN          reduce using rule 68 (exp -> exp LE exp .)
    ID              reduce using rule 68 (exp -> exp LE exp .)
    RESID           reduce using rule 68 (exp -> exp LE exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84

  ! PLUS            [ reduce using rule 68 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 68 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 68 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 68 (exp -> exp LE exp .) ]
  ! POWER           [ reduce using rule 68 (exp -> exp LE exp .) ]
  ! MODULO          [ reduce using rule 68 (exp -> exp LE exp .) ]
  ! DBLDOTS         [ reduce using rule 68 (exp -> exp LE exp .) ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]


state 123

    (66) exp -> exp POWER exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 66 (exp -> exp POWER exp .)
    MINUS           reduce using rule 66 (exp -> exp POWER exp .)
    TIMES           reduce using rule 66 (exp -> exp POWER exp .)
    DIVIDE          reduce using rule 66 (exp -> exp POWER exp .)
    LT              reduce using rule 66 (exp -> exp POWER exp .)
    LE              reduce using rule 66 (exp -> exp POWER exp .)
    GT              reduce using rule 66 (exp -> exp POWER exp .)
    GE              reduce using rule 66 (exp -> exp POWER exp .)
    NE              reduce using rule 66 (exp -> exp POWER exp .)
    CHECKEQ         reduce using rule 66 (exp -> exp POWER exp .)
    and             reduce using rule 66 (exp -> exp POWER exp .)
    or              reduce using rule 66 (exp -> exp POWER exp .)
    MODULO          reduce using rule 66 (exp -> exp POWER exp .)
    DBLDOTS         reduce using rule 66 (exp -> exp POWER exp .)
    RPAREN          reduce using rule 66 (exp -> exp POWER exp .)
    then            reduce using rule 66 (exp -> exp POWER exp .)
    do              reduce using rule 66 (exp -> exp POWER exp .)
    COMMA           reduce using rule 66 (exp -> exp POWER exp .)
    SEMI            reduce using rule 66 (exp -> exp POWER exp .)
    RCURLY          reduce using rule 66 (exp -> exp POWER exp .)
    $end            reduce using rule 66 (exp -> exp POWER exp .)
    end             reduce using rule 66 (exp -> exp POWER exp .)
    until           reduce using rule 66 (exp -> exp POWER exp .)
    else            reduce using rule 66 (exp -> exp POWER exp .)
    elseif          reduce using rule 66 (exp -> exp POWER exp .)
    RSQUARE         reduce using rule 66 (exp -> exp POWER exp .)
    return          reduce using rule 66 (exp -> exp POWER exp .)
    break           reduce using rule 66 (exp -> exp POWER exp .)
    while           reduce using rule 66 (exp -> exp POWER exp .)
    repeat          reduce using rule 66 (exp -> exp POWER exp .)
    if              reduce using rule 66 (exp -> exp POWER exp .)
    for             reduce using rule 66 (exp -> exp POWER exp .)
    local           reduce using rule 66 (exp -> exp POWER exp .)
    function        reduce using rule 66 (exp -> exp POWER exp .)
    LPAREN          reduce using rule 66 (exp -> exp POWER exp .)
    ID              reduce using rule 66 (exp -> exp POWER exp .)
    RESID           reduce using rule 66 (exp -> exp POWER exp .)
    POWER           shift and go to state 75

  ! POWER           [ reduce using rule 66 (exp -> exp POWER exp .) ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 85 ]
  ! TIMES           [ shift and go to state 78 ]
  ! DIVIDE          [ shift and go to state 87 ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]
  ! MODULO          [ shift and go to state 83 ]
  ! DBLDOTS         [ shift and go to state 84 ]


state 124

    (74) exp -> exp or exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    LT              reduce using rule 74 (exp -> exp or exp .)
    LE              reduce using rule 74 (exp -> exp or exp .)
    GT              reduce using rule 74 (exp -> exp or exp .)
    GE              reduce using rule 74 (exp -> exp or exp .)
    NE              reduce using rule 74 (exp -> exp or exp .)
    CHECKEQ         reduce using rule 74 (exp -> exp or exp .)
    and             reduce using rule 74 (exp -> exp or exp .)
    or              reduce using rule 74 (exp -> exp or exp .)
    RPAREN          reduce using rule 74 (exp -> exp or exp .)
    then            reduce using rule 74 (exp -> exp or exp .)
    do              reduce using rule 74 (exp -> exp or exp .)
    COMMA           reduce using rule 74 (exp -> exp or exp .)
    SEMI            reduce using rule 74 (exp -> exp or exp .)
    RCURLY          reduce using rule 74 (exp -> exp or exp .)
    $end            reduce using rule 74 (exp -> exp or exp .)
    end             reduce using rule 74 (exp -> exp or exp .)
    until           reduce using rule 74 (exp -> exp or exp .)
    else            reduce using rule 74 (exp -> exp or exp .)
    elseif          reduce using rule 74 (exp -> exp or exp .)
    RSQUARE         reduce using rule 74 (exp -> exp or exp .)
    return          reduce using rule 74 (exp -> exp or exp .)
    break           reduce using rule 74 (exp -> exp or exp .)
    while           reduce using rule 74 (exp -> exp or exp .)
    repeat          reduce using rule 74 (exp -> exp or exp .)
    if              reduce using rule 74 (exp -> exp or exp .)
    for             reduce using rule 74 (exp -> exp or exp .)
    local           reduce using rule 74 (exp -> exp or exp .)
    function        reduce using rule 74 (exp -> exp or exp .)
    LPAREN          reduce using rule 74 (exp -> exp or exp .)
    ID              reduce using rule 74 (exp -> exp or exp .)
    RESID           reduce using rule 74 (exp -> exp or exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84

  ! PLUS            [ reduce using rule 74 (exp -> exp or exp .) ]
  ! MINUS           [ reduce using rule 74 (exp -> exp or exp .) ]
  ! TIMES           [ reduce using rule 74 (exp -> exp or exp .) ]
  ! DIVIDE          [ reduce using rule 74 (exp -> exp or exp .) ]
  ! POWER           [ reduce using rule 74 (exp -> exp or exp .) ]
  ! MODULO          [ reduce using rule 74 (exp -> exp or exp .) ]
  ! DBLDOTS         [ reduce using rule 74 (exp -> exp or exp .) ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]


state 125

    (70) exp -> exp GE exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    LT              reduce using rule 70 (exp -> exp GE exp .)
    LE              reduce using rule 70 (exp -> exp GE exp .)
    GT              reduce using rule 70 (exp -> exp GE exp .)
    GE              reduce using rule 70 (exp -> exp GE exp .)
    NE              reduce using rule 70 (exp -> exp GE exp .)
    CHECKEQ         reduce using rule 70 (exp -> exp GE exp .)
    and             reduce using rule 70 (exp -> exp GE exp .)
    or              reduce using rule 70 (exp -> exp GE exp .)
    RPAREN          reduce using rule 70 (exp -> exp GE exp .)
    then            reduce using rule 70 (exp -> exp GE exp .)
    do              reduce using rule 70 (exp -> exp GE exp .)
    COMMA           reduce using rule 70 (exp -> exp GE exp .)
    SEMI            reduce using rule 70 (exp -> exp GE exp .)
    RCURLY          reduce using rule 70 (exp -> exp GE exp .)
    $end            reduce using rule 70 (exp -> exp GE exp .)
    end             reduce using rule 70 (exp -> exp GE exp .)
    until           reduce using rule 70 (exp -> exp GE exp .)
    else            reduce using rule 70 (exp -> exp GE exp .)
    elseif          reduce using rule 70 (exp -> exp GE exp .)
    RSQUARE         reduce using rule 70 (exp -> exp GE exp .)
    return          reduce using rule 70 (exp -> exp GE exp .)
    break           reduce using rule 70 (exp -> exp GE exp .)
    while           reduce using rule 70 (exp -> exp GE exp .)
    repeat          reduce using rule 70 (exp -> exp GE exp .)
    if              reduce using rule 70 (exp -> exp GE exp .)
    for             reduce using rule 70 (exp -> exp GE exp .)
    local           reduce using rule 70 (exp -> exp GE exp .)
    function        reduce using rule 70 (exp -> exp GE exp .)
    LPAREN          reduce using rule 70 (exp -> exp GE exp .)
    ID              reduce using rule 70 (exp -> exp GE exp .)
    RESID           reduce using rule 70 (exp -> exp GE exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84

  ! PLUS            [ reduce using rule 70 (exp -> exp GE exp .) ]
  ! MINUS           [ reduce using rule 70 (exp -> exp GE exp .) ]
  ! TIMES           [ reduce using rule 70 (exp -> exp GE exp .) ]
  ! DIVIDE          [ reduce using rule 70 (exp -> exp GE exp .) ]
  ! POWER           [ reduce using rule 70 (exp -> exp GE exp .) ]
  ! MODULO          [ reduce using rule 70 (exp -> exp GE exp .) ]
  ! DBLDOTS         [ reduce using rule 70 (exp -> exp GE exp .) ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]


state 126

    (64) exp -> exp TIMES exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 64 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 64 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 64 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 64 (exp -> exp TIMES exp .)
    LT              reduce using rule 64 (exp -> exp TIMES exp .)
    LE              reduce using rule 64 (exp -> exp TIMES exp .)
    GT              reduce using rule 64 (exp -> exp TIMES exp .)
    GE              reduce using rule 64 (exp -> exp TIMES exp .)
    NE              reduce using rule 64 (exp -> exp TIMES exp .)
    CHECKEQ         reduce using rule 64 (exp -> exp TIMES exp .)
    and             reduce using rule 64 (exp -> exp TIMES exp .)
    or              reduce using rule 64 (exp -> exp TIMES exp .)
    MODULO          reduce using rule 64 (exp -> exp TIMES exp .)
    DBLDOTS         reduce using rule 64 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 64 (exp -> exp TIMES exp .)
    then            reduce using rule 64 (exp -> exp TIMES exp .)
    do              reduce using rule 64 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 64 (exp -> exp TIMES exp .)
    SEMI            reduce using rule 64 (exp -> exp TIMES exp .)
    RCURLY          reduce using rule 64 (exp -> exp TIMES exp .)
    $end            reduce using rule 64 (exp -> exp TIMES exp .)
    end             reduce using rule 64 (exp -> exp TIMES exp .)
    until           reduce using rule 64 (exp -> exp TIMES exp .)
    else            reduce using rule 64 (exp -> exp TIMES exp .)
    elseif          reduce using rule 64 (exp -> exp TIMES exp .)
    RSQUARE         reduce using rule 64 (exp -> exp TIMES exp .)
    return          reduce using rule 64 (exp -> exp TIMES exp .)
    break           reduce using rule 64 (exp -> exp TIMES exp .)
    while           reduce using rule 64 (exp -> exp TIMES exp .)
    repeat          reduce using rule 64 (exp -> exp TIMES exp .)
    if              reduce using rule 64 (exp -> exp TIMES exp .)
    for             reduce using rule 64 (exp -> exp TIMES exp .)
    local           reduce using rule 64 (exp -> exp TIMES exp .)
    function        reduce using rule 64 (exp -> exp TIMES exp .)
    LPAREN          reduce using rule 64 (exp -> exp TIMES exp .)
    ID              reduce using rule 64 (exp -> exp TIMES exp .)
    RESID           reduce using rule 64 (exp -> exp TIMES exp .)
    POWER           shift and go to state 75

  ! POWER           [ reduce using rule 64 (exp -> exp TIMES exp .) ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 85 ]
  ! TIMES           [ shift and go to state 78 ]
  ! DIVIDE          [ shift and go to state 87 ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]
  ! MODULO          [ shift and go to state 83 ]
  ! DBLDOTS         [ shift and go to state 84 ]


state 127

    (72) exp -> exp CHECKEQ exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    LT              reduce using rule 72 (exp -> exp CHECKEQ exp .)
    LE              reduce using rule 72 (exp -> exp CHECKEQ exp .)
    GT              reduce using rule 72 (exp -> exp CHECKEQ exp .)
    GE              reduce using rule 72 (exp -> exp CHECKEQ exp .)
    NE              reduce using rule 72 (exp -> exp CHECKEQ exp .)
    CHECKEQ         reduce using rule 72 (exp -> exp CHECKEQ exp .)
    and             reduce using rule 72 (exp -> exp CHECKEQ exp .)
    or              reduce using rule 72 (exp -> exp CHECKEQ exp .)
    RPAREN          reduce using rule 72 (exp -> exp CHECKEQ exp .)
    then            reduce using rule 72 (exp -> exp CHECKEQ exp .)
    do              reduce using rule 72 (exp -> exp CHECKEQ exp .)
    COMMA           reduce using rule 72 (exp -> exp CHECKEQ exp .)
    SEMI            reduce using rule 72 (exp -> exp CHECKEQ exp .)
    RCURLY          reduce using rule 72 (exp -> exp CHECKEQ exp .)
    $end            reduce using rule 72 (exp -> exp CHECKEQ exp .)
    end             reduce using rule 72 (exp -> exp CHECKEQ exp .)
    until           reduce using rule 72 (exp -> exp CHECKEQ exp .)
    else            reduce using rule 72 (exp -> exp CHECKEQ exp .)
    elseif          reduce using rule 72 (exp -> exp CHECKEQ exp .)
    RSQUARE         reduce using rule 72 (exp -> exp CHECKEQ exp .)
    return          reduce using rule 72 (exp -> exp CHECKEQ exp .)
    break           reduce using rule 72 (exp -> exp CHECKEQ exp .)
    while           reduce using rule 72 (exp -> exp CHECKEQ exp .)
    repeat          reduce using rule 72 (exp -> exp CHECKEQ exp .)
    if              reduce using rule 72 (exp -> exp CHECKEQ exp .)
    for             reduce using rule 72 (exp -> exp CHECKEQ exp .)
    local           reduce using rule 72 (exp -> exp CHECKEQ exp .)
    function        reduce using rule 72 (exp -> exp CHECKEQ exp .)
    LPAREN          reduce using rule 72 (exp -> exp CHECKEQ exp .)
    ID              reduce using rule 72 (exp -> exp CHECKEQ exp .)
    RESID           reduce using rule 72 (exp -> exp CHECKEQ exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84

  ! PLUS            [ reduce using rule 72 (exp -> exp CHECKEQ exp .) ]
  ! MINUS           [ reduce using rule 72 (exp -> exp CHECKEQ exp .) ]
  ! TIMES           [ reduce using rule 72 (exp -> exp CHECKEQ exp .) ]
  ! DIVIDE          [ reduce using rule 72 (exp -> exp CHECKEQ exp .) ]
  ! POWER           [ reduce using rule 72 (exp -> exp CHECKEQ exp .) ]
  ! MODULO          [ reduce using rule 72 (exp -> exp CHECKEQ exp .) ]
  ! DBLDOTS         [ reduce using rule 72 (exp -> exp CHECKEQ exp .) ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]


state 128

    (67) exp -> exp LT exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    LT              reduce using rule 67 (exp -> exp LT exp .)
    LE              reduce using rule 67 (exp -> exp LT exp .)
    GT              reduce using rule 67 (exp -> exp LT exp .)
    GE              reduce using rule 67 (exp -> exp LT exp .)
    NE              reduce using rule 67 (exp -> exp LT exp .)
    CHECKEQ         reduce using rule 67 (exp -> exp LT exp .)
    and             reduce using rule 67 (exp -> exp LT exp .)
    or              reduce using rule 67 (exp -> exp LT exp .)
    RPAREN          reduce using rule 67 (exp -> exp LT exp .)
    then            reduce using rule 67 (exp -> exp LT exp .)
    do              reduce using rule 67 (exp -> exp LT exp .)
    COMMA           reduce using rule 67 (exp -> exp LT exp .)
    SEMI            reduce using rule 67 (exp -> exp LT exp .)
    RCURLY          reduce using rule 67 (exp -> exp LT exp .)
    $end            reduce using rule 67 (exp -> exp LT exp .)
    end             reduce using rule 67 (exp -> exp LT exp .)
    until           reduce using rule 67 (exp -> exp LT exp .)
    else            reduce using rule 67 (exp -> exp LT exp .)
    elseif          reduce using rule 67 (exp -> exp LT exp .)
    RSQUARE         reduce using rule 67 (exp -> exp LT exp .)
    return          reduce using rule 67 (exp -> exp LT exp .)
    break           reduce using rule 67 (exp -> exp LT exp .)
    while           reduce using rule 67 (exp -> exp LT exp .)
    repeat          reduce using rule 67 (exp -> exp LT exp .)
    if              reduce using rule 67 (exp -> exp LT exp .)
    for             reduce using rule 67 (exp -> exp LT exp .)
    local           reduce using rule 67 (exp -> exp LT exp .)
    function        reduce using rule 67 (exp -> exp LT exp .)
    LPAREN          reduce using rule 67 (exp -> exp LT exp .)
    ID              reduce using rule 67 (exp -> exp LT exp .)
    RESID           reduce using rule 67 (exp -> exp LT exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84

  ! PLUS            [ reduce using rule 67 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 67 (exp -> exp LT exp .) ]
  ! TIMES           [ reduce using rule 67 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 67 (exp -> exp LT exp .) ]
  ! POWER           [ reduce using rule 67 (exp -> exp LT exp .) ]
  ! MODULO          [ reduce using rule 67 (exp -> exp LT exp .) ]
  ! DBLDOTS         [ reduce using rule 67 (exp -> exp LT exp .) ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]


state 129

    (69) exp -> exp GT exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    LT              reduce using rule 69 (exp -> exp GT exp .)
    LE              reduce using rule 69 (exp -> exp GT exp .)
    GT              reduce using rule 69 (exp -> exp GT exp .)
    GE              reduce using rule 69 (exp -> exp GT exp .)
    NE              reduce using rule 69 (exp -> exp GT exp .)
    CHECKEQ         reduce using rule 69 (exp -> exp GT exp .)
    and             reduce using rule 69 (exp -> exp GT exp .)
    or              reduce using rule 69 (exp -> exp GT exp .)
    RPAREN          reduce using rule 69 (exp -> exp GT exp .)
    then            reduce using rule 69 (exp -> exp GT exp .)
    do              reduce using rule 69 (exp -> exp GT exp .)
    COMMA           reduce using rule 69 (exp -> exp GT exp .)
    SEMI            reduce using rule 69 (exp -> exp GT exp .)
    RCURLY          reduce using rule 69 (exp -> exp GT exp .)
    $end            reduce using rule 69 (exp -> exp GT exp .)
    end             reduce using rule 69 (exp -> exp GT exp .)
    until           reduce using rule 69 (exp -> exp GT exp .)
    else            reduce using rule 69 (exp -> exp GT exp .)
    elseif          reduce using rule 69 (exp -> exp GT exp .)
    RSQUARE         reduce using rule 69 (exp -> exp GT exp .)
    return          reduce using rule 69 (exp -> exp GT exp .)
    break           reduce using rule 69 (exp -> exp GT exp .)
    while           reduce using rule 69 (exp -> exp GT exp .)
    repeat          reduce using rule 69 (exp -> exp GT exp .)
    if              reduce using rule 69 (exp -> exp GT exp .)
    for             reduce using rule 69 (exp -> exp GT exp .)
    local           reduce using rule 69 (exp -> exp GT exp .)
    function        reduce using rule 69 (exp -> exp GT exp .)
    LPAREN          reduce using rule 69 (exp -> exp GT exp .)
    ID              reduce using rule 69 (exp -> exp GT exp .)
    RESID           reduce using rule 69 (exp -> exp GT exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84

  ! PLUS            [ reduce using rule 69 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 69 (exp -> exp GT exp .) ]
  ! TIMES           [ reduce using rule 69 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 69 (exp -> exp GT exp .) ]
  ! POWER           [ reduce using rule 69 (exp -> exp GT exp .) ]
  ! MODULO          [ reduce using rule 69 (exp -> exp GT exp .) ]
  ! DBLDOTS         [ reduce using rule 69 (exp -> exp GT exp .) ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]


state 130

    (62) exp -> exp PLUS exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 62 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 62 (exp -> exp PLUS exp .)
    LT              reduce using rule 62 (exp -> exp PLUS exp .)
    LE              reduce using rule 62 (exp -> exp PLUS exp .)
    GT              reduce using rule 62 (exp -> exp PLUS exp .)
    GE              reduce using rule 62 (exp -> exp PLUS exp .)
    NE              reduce using rule 62 (exp -> exp PLUS exp .)
    CHECKEQ         reduce using rule 62 (exp -> exp PLUS exp .)
    and             reduce using rule 62 (exp -> exp PLUS exp .)
    or              reduce using rule 62 (exp -> exp PLUS exp .)
    DBLDOTS         reduce using rule 62 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 62 (exp -> exp PLUS exp .)
    then            reduce using rule 62 (exp -> exp PLUS exp .)
    do              reduce using rule 62 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 62 (exp -> exp PLUS exp .)
    SEMI            reduce using rule 62 (exp -> exp PLUS exp .)
    RCURLY          reduce using rule 62 (exp -> exp PLUS exp .)
    $end            reduce using rule 62 (exp -> exp PLUS exp .)
    end             reduce using rule 62 (exp -> exp PLUS exp .)
    until           reduce using rule 62 (exp -> exp PLUS exp .)
    else            reduce using rule 62 (exp -> exp PLUS exp .)
    elseif          reduce using rule 62 (exp -> exp PLUS exp .)
    RSQUARE         reduce using rule 62 (exp -> exp PLUS exp .)
    return          reduce using rule 62 (exp -> exp PLUS exp .)
    break           reduce using rule 62 (exp -> exp PLUS exp .)
    while           reduce using rule 62 (exp -> exp PLUS exp .)
    repeat          reduce using rule 62 (exp -> exp PLUS exp .)
    if              reduce using rule 62 (exp -> exp PLUS exp .)
    for             reduce using rule 62 (exp -> exp PLUS exp .)
    local           reduce using rule 62 (exp -> exp PLUS exp .)
    function        reduce using rule 62 (exp -> exp PLUS exp .)
    LPAREN          reduce using rule 62 (exp -> exp PLUS exp .)
    ID              reduce using rule 62 (exp -> exp PLUS exp .)
    RESID           reduce using rule 62 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    MODULO          shift and go to state 83

  ! TIMES           [ reduce using rule 62 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 62 (exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 62 (exp -> exp PLUS exp .) ]
  ! MODULO          [ reduce using rule 62 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 85 ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]
  ! DBLDOTS         [ shift and go to state 84 ]


state 131

    (75) exp -> exp MODULO exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 75 (exp -> exp MODULO exp .)
    MINUS           reduce using rule 75 (exp -> exp MODULO exp .)
    TIMES           reduce using rule 75 (exp -> exp MODULO exp .)
    DIVIDE          reduce using rule 75 (exp -> exp MODULO exp .)
    LT              reduce using rule 75 (exp -> exp MODULO exp .)
    LE              reduce using rule 75 (exp -> exp MODULO exp .)
    GT              reduce using rule 75 (exp -> exp MODULO exp .)
    GE              reduce using rule 75 (exp -> exp MODULO exp .)
    NE              reduce using rule 75 (exp -> exp MODULO exp .)
    CHECKEQ         reduce using rule 75 (exp -> exp MODULO exp .)
    and             reduce using rule 75 (exp -> exp MODULO exp .)
    or              reduce using rule 75 (exp -> exp MODULO exp .)
    MODULO          reduce using rule 75 (exp -> exp MODULO exp .)
    DBLDOTS         reduce using rule 75 (exp -> exp MODULO exp .)
    RPAREN          reduce using rule 75 (exp -> exp MODULO exp .)
    then            reduce using rule 75 (exp -> exp MODULO exp .)
    do              reduce using rule 75 (exp -> exp MODULO exp .)
    COMMA           reduce using rule 75 (exp -> exp MODULO exp .)
    SEMI            reduce using rule 75 (exp -> exp MODULO exp .)
    RCURLY          reduce using rule 75 (exp -> exp MODULO exp .)
    $end            reduce using rule 75 (exp -> exp MODULO exp .)
    end             reduce using rule 75 (exp -> exp MODULO exp .)
    until           reduce using rule 75 (exp -> exp MODULO exp .)
    else            reduce using rule 75 (exp -> exp MODULO exp .)
    elseif          reduce using rule 75 (exp -> exp MODULO exp .)
    RSQUARE         reduce using rule 75 (exp -> exp MODULO exp .)
    return          reduce using rule 75 (exp -> exp MODULO exp .)
    break           reduce using rule 75 (exp -> exp MODULO exp .)
    while           reduce using rule 75 (exp -> exp MODULO exp .)
    repeat          reduce using rule 75 (exp -> exp MODULO exp .)
    if              reduce using rule 75 (exp -> exp MODULO exp .)
    for             reduce using rule 75 (exp -> exp MODULO exp .)
    local           reduce using rule 75 (exp -> exp MODULO exp .)
    function        reduce using rule 75 (exp -> exp MODULO exp .)
    LPAREN          reduce using rule 75 (exp -> exp MODULO exp .)
    ID              reduce using rule 75 (exp -> exp MODULO exp .)
    RESID           reduce using rule 75 (exp -> exp MODULO exp .)
    POWER           shift and go to state 75

  ! POWER           [ reduce using rule 75 (exp -> exp MODULO exp .) ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 85 ]
  ! TIMES           [ shift and go to state 78 ]
  ! DIVIDE          [ shift and go to state 87 ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]
  ! MODULO          [ shift and go to state 83 ]
  ! DBLDOTS         [ shift and go to state 84 ]


state 132

    (76) exp -> exp DBLDOTS exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    LT              reduce using rule 76 (exp -> exp DBLDOTS exp .)
    LE              reduce using rule 76 (exp -> exp DBLDOTS exp .)
    GT              reduce using rule 76 (exp -> exp DBLDOTS exp .)
    GE              reduce using rule 76 (exp -> exp DBLDOTS exp .)
    NE              reduce using rule 76 (exp -> exp DBLDOTS exp .)
    CHECKEQ         reduce using rule 76 (exp -> exp DBLDOTS exp .)
    and             reduce using rule 76 (exp -> exp DBLDOTS exp .)
    or              reduce using rule 76 (exp -> exp DBLDOTS exp .)
    RPAREN          reduce using rule 76 (exp -> exp DBLDOTS exp .)
    then            reduce using rule 76 (exp -> exp DBLDOTS exp .)
    do              reduce using rule 76 (exp -> exp DBLDOTS exp .)
    COMMA           reduce using rule 76 (exp -> exp DBLDOTS exp .)
    SEMI            reduce using rule 76 (exp -> exp DBLDOTS exp .)
    RCURLY          reduce using rule 76 (exp -> exp DBLDOTS exp .)
    $end            reduce using rule 76 (exp -> exp DBLDOTS exp .)
    end             reduce using rule 76 (exp -> exp DBLDOTS exp .)
    until           reduce using rule 76 (exp -> exp DBLDOTS exp .)
    else            reduce using rule 76 (exp -> exp DBLDOTS exp .)
    elseif          reduce using rule 76 (exp -> exp DBLDOTS exp .)
    RSQUARE         reduce using rule 76 (exp -> exp DBLDOTS exp .)
    return          reduce using rule 76 (exp -> exp DBLDOTS exp .)
    break           reduce using rule 76 (exp -> exp DBLDOTS exp .)
    while           reduce using rule 76 (exp -> exp DBLDOTS exp .)
    repeat          reduce using rule 76 (exp -> exp DBLDOTS exp .)
    if              reduce using rule 76 (exp -> exp DBLDOTS exp .)
    for             reduce using rule 76 (exp -> exp DBLDOTS exp .)
    local           reduce using rule 76 (exp -> exp DBLDOTS exp .)
    function        reduce using rule 76 (exp -> exp DBLDOTS exp .)
    LPAREN          reduce using rule 76 (exp -> exp DBLDOTS exp .)
    ID              reduce using rule 76 (exp -> exp DBLDOTS exp .)
    RESID           reduce using rule 76 (exp -> exp DBLDOTS exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84

  ! PLUS            [ reduce using rule 76 (exp -> exp DBLDOTS exp .) ]
  ! MINUS           [ reduce using rule 76 (exp -> exp DBLDOTS exp .) ]
  ! TIMES           [ reduce using rule 76 (exp -> exp DBLDOTS exp .) ]
  ! DIVIDE          [ reduce using rule 76 (exp -> exp DBLDOTS exp .) ]
  ! POWER           [ reduce using rule 76 (exp -> exp DBLDOTS exp .) ]
  ! MODULO          [ reduce using rule 76 (exp -> exp DBLDOTS exp .) ]
  ! DBLDOTS         [ reduce using rule 76 (exp -> exp DBLDOTS exp .) ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]


state 133

    (63) exp -> exp MINUS exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 63 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 63 (exp -> exp MINUS exp .)
    LT              reduce using rule 63 (exp -> exp MINUS exp .)
    LE              reduce using rule 63 (exp -> exp MINUS exp .)
    GT              reduce using rule 63 (exp -> exp MINUS exp .)
    GE              reduce using rule 63 (exp -> exp MINUS exp .)
    NE              reduce using rule 63 (exp -> exp MINUS exp .)
    CHECKEQ         reduce using rule 63 (exp -> exp MINUS exp .)
    and             reduce using rule 63 (exp -> exp MINUS exp .)
    or              reduce using rule 63 (exp -> exp MINUS exp .)
    DBLDOTS         reduce using rule 63 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 63 (exp -> exp MINUS exp .)
    then            reduce using rule 63 (exp -> exp MINUS exp .)
    do              reduce using rule 63 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 63 (exp -> exp MINUS exp .)
    SEMI            reduce using rule 63 (exp -> exp MINUS exp .)
    RCURLY          reduce using rule 63 (exp -> exp MINUS exp .)
    $end            reduce using rule 63 (exp -> exp MINUS exp .)
    end             reduce using rule 63 (exp -> exp MINUS exp .)
    until           reduce using rule 63 (exp -> exp MINUS exp .)
    else            reduce using rule 63 (exp -> exp MINUS exp .)
    elseif          reduce using rule 63 (exp -> exp MINUS exp .)
    RSQUARE         reduce using rule 63 (exp -> exp MINUS exp .)
    return          reduce using rule 63 (exp -> exp MINUS exp .)
    break           reduce using rule 63 (exp -> exp MINUS exp .)
    while           reduce using rule 63 (exp -> exp MINUS exp .)
    repeat          reduce using rule 63 (exp -> exp MINUS exp .)
    if              reduce using rule 63 (exp -> exp MINUS exp .)
    for             reduce using rule 63 (exp -> exp MINUS exp .)
    local           reduce using rule 63 (exp -> exp MINUS exp .)
    function        reduce using rule 63 (exp -> exp MINUS exp .)
    LPAREN          reduce using rule 63 (exp -> exp MINUS exp .)
    ID              reduce using rule 63 (exp -> exp MINUS exp .)
    RESID           reduce using rule 63 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    MODULO          shift and go to state 83

  ! TIMES           [ reduce using rule 63 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 63 (exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 63 (exp -> exp MINUS exp .) ]
  ! MODULO          [ reduce using rule 63 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 85 ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]
  ! DBLDOTS         [ shift and go to state 84 ]


state 134

    (71) exp -> exp NE exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    LT              reduce using rule 71 (exp -> exp NE exp .)
    LE              reduce using rule 71 (exp -> exp NE exp .)
    GT              reduce using rule 71 (exp -> exp NE exp .)
    GE              reduce using rule 71 (exp -> exp NE exp .)
    NE              reduce using rule 71 (exp -> exp NE exp .)
    CHECKEQ         reduce using rule 71 (exp -> exp NE exp .)
    and             reduce using rule 71 (exp -> exp NE exp .)
    or              reduce using rule 71 (exp -> exp NE exp .)
    RPAREN          reduce using rule 71 (exp -> exp NE exp .)
    then            reduce using rule 71 (exp -> exp NE exp .)
    do              reduce using rule 71 (exp -> exp NE exp .)
    COMMA           reduce using rule 71 (exp -> exp NE exp .)
    SEMI            reduce using rule 71 (exp -> exp NE exp .)
    RCURLY          reduce using rule 71 (exp -> exp NE exp .)
    $end            reduce using rule 71 (exp -> exp NE exp .)
    end             reduce using rule 71 (exp -> exp NE exp .)
    until           reduce using rule 71 (exp -> exp NE exp .)
    else            reduce using rule 71 (exp -> exp NE exp .)
    elseif          reduce using rule 71 (exp -> exp NE exp .)
    RSQUARE         reduce using rule 71 (exp -> exp NE exp .)
    return          reduce using rule 71 (exp -> exp NE exp .)
    break           reduce using rule 71 (exp -> exp NE exp .)
    while           reduce using rule 71 (exp -> exp NE exp .)
    repeat          reduce using rule 71 (exp -> exp NE exp .)
    if              reduce using rule 71 (exp -> exp NE exp .)
    for             reduce using rule 71 (exp -> exp NE exp .)
    local           reduce using rule 71 (exp -> exp NE exp .)
    function        reduce using rule 71 (exp -> exp NE exp .)
    LPAREN          reduce using rule 71 (exp -> exp NE exp .)
    ID              reduce using rule 71 (exp -> exp NE exp .)
    RESID           reduce using rule 71 (exp -> exp NE exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84

  ! PLUS            [ reduce using rule 71 (exp -> exp NE exp .) ]
  ! MINUS           [ reduce using rule 71 (exp -> exp NE exp .) ]
  ! TIMES           [ reduce using rule 71 (exp -> exp NE exp .) ]
  ! DIVIDE          [ reduce using rule 71 (exp -> exp NE exp .) ]
  ! POWER           [ reduce using rule 71 (exp -> exp NE exp .) ]
  ! MODULO          [ reduce using rule 71 (exp -> exp NE exp .) ]
  ! DBLDOTS         [ reduce using rule 71 (exp -> exp NE exp .) ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]


state 135

    (65) exp -> exp DIVIDE exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 65 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 65 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 65 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 65 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 65 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 65 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 65 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 65 (exp -> exp DIVIDE exp .)
    NE              reduce using rule 65 (exp -> exp DIVIDE exp .)
    CHECKEQ         reduce using rule 65 (exp -> exp DIVIDE exp .)
    and             reduce using rule 65 (exp -> exp DIVIDE exp .)
    or              reduce using rule 65 (exp -> exp DIVIDE exp .)
    MODULO          reduce using rule 65 (exp -> exp DIVIDE exp .)
    DBLDOTS         reduce using rule 65 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 65 (exp -> exp DIVIDE exp .)
    then            reduce using rule 65 (exp -> exp DIVIDE exp .)
    do              reduce using rule 65 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 65 (exp -> exp DIVIDE exp .)
    SEMI            reduce using rule 65 (exp -> exp DIVIDE exp .)
    RCURLY          reduce using rule 65 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 65 (exp -> exp DIVIDE exp .)
    end             reduce using rule 65 (exp -> exp DIVIDE exp .)
    until           reduce using rule 65 (exp -> exp DIVIDE exp .)
    else            reduce using rule 65 (exp -> exp DIVIDE exp .)
    elseif          reduce using rule 65 (exp -> exp DIVIDE exp .)
    RSQUARE         reduce using rule 65 (exp -> exp DIVIDE exp .)
    return          reduce using rule 65 (exp -> exp DIVIDE exp .)
    break           reduce using rule 65 (exp -> exp DIVIDE exp .)
    while           reduce using rule 65 (exp -> exp DIVIDE exp .)
    repeat          reduce using rule 65 (exp -> exp DIVIDE exp .)
    if              reduce using rule 65 (exp -> exp DIVIDE exp .)
    for             reduce using rule 65 (exp -> exp DIVIDE exp .)
    local           reduce using rule 65 (exp -> exp DIVIDE exp .)
    function        reduce using rule 65 (exp -> exp DIVIDE exp .)
    LPAREN          reduce using rule 65 (exp -> exp DIVIDE exp .)
    ID              reduce using rule 65 (exp -> exp DIVIDE exp .)
    RESID           reduce using rule 65 (exp -> exp DIVIDE exp .)
    POWER           shift and go to state 75

  ! POWER           [ reduce using rule 65 (exp -> exp DIVIDE exp .) ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 85 ]
  ! TIMES           [ shift and go to state 78 ]
  ! DIVIDE          [ shift and go to state 87 ]
  ! LT              [ shift and go to state 80 ]
  ! LE              [ shift and go to state 73 ]
  ! GT              [ shift and go to state 81 ]
  ! GE              [ shift and go to state 77 ]
  ! NE              [ shift and go to state 86 ]
  ! CHECKEQ         [ shift and go to state 79 ]
  ! and             [ shift and go to state 72 ]
  ! or              [ shift and go to state 76 ]
  ! MODULO          [ shift and go to state 83 ]
  ! DBLDOTS         [ shift and go to state 84 ]


state 136

    (52) explist -> explist COMMA . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 159
    var                            shift and go to state 26
    names                          shift and go to state 4

state 137

    (14) stat -> if exp then block . ifblock else block end
    (15) stat -> if exp then block . ifblock end
    (45) ifblock -> . ifblock elseif exp then block
    (46) ifblock -> . empty
    (82) empty -> .

    else            reduce using rule 82 (empty -> .)
    end             reduce using rule 82 (empty -> .)
    elseif          reduce using rule 82 (empty -> .)

    empty                          shift and go to state 160
    ifblock                        shift and go to state 161

state 138

    (49) var -> prefixexp LSQUARE exp RSQUARE .

    COMMA           reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    EQUALS          reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    LSQUARE         reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    SDOT            reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    LPAREN          reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    STRING          reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    LCURLY          reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    then            reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    PLUS            reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    MINUS           reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    TIMES           reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    DIVIDE          reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    POWER           reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    LT              reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    LE              reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    GT              reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    GE              reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    NE              reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    CHECKEQ         reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    and             reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    or              reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    MODULO          reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    DBLDOTS         reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    do              reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    SEMI            reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    RCURLY          reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    RPAREN          reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    $end            reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    end             reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    until           reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    else            reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    elseif          reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    RSQUARE         reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    return          reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    break           reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    while           reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    repeat          reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    if              reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    for             reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    local           reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    function        reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    ID              reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)
    RESID           reduce using rule 49 (var -> prefixexp LSQUARE exp RSQUARE .)


state 139

    (27) args -> LPAREN explist RPAREN .

    SEMI            reduce using rule 27 (args -> LPAREN explist RPAREN .)
    return          reduce using rule 27 (args -> LPAREN explist RPAREN .)
    break           reduce using rule 27 (args -> LPAREN explist RPAREN .)
    do              reduce using rule 27 (args -> LPAREN explist RPAREN .)
    while           reduce using rule 27 (args -> LPAREN explist RPAREN .)
    repeat          reduce using rule 27 (args -> LPAREN explist RPAREN .)
    if              reduce using rule 27 (args -> LPAREN explist RPAREN .)
    for             reduce using rule 27 (args -> LPAREN explist RPAREN .)
    local           reduce using rule 27 (args -> LPAREN explist RPAREN .)
    function        reduce using rule 27 (args -> LPAREN explist RPAREN .)
    LPAREN          reduce using rule 27 (args -> LPAREN explist RPAREN .)
    ID              reduce using rule 27 (args -> LPAREN explist RPAREN .)
    RESID           reduce using rule 27 (args -> LPAREN explist RPAREN .)
    $end            reduce using rule 27 (args -> LPAREN explist RPAREN .)
    LSQUARE         reduce using rule 27 (args -> LPAREN explist RPAREN .)
    SDOT            reduce using rule 27 (args -> LPAREN explist RPAREN .)
    STRING          reduce using rule 27 (args -> LPAREN explist RPAREN .)
    LCURLY          reduce using rule 27 (args -> LPAREN explist RPAREN .)
    end             reduce using rule 27 (args -> LPAREN explist RPAREN .)
    until           reduce using rule 27 (args -> LPAREN explist RPAREN .)
    else            reduce using rule 27 (args -> LPAREN explist RPAREN .)
    elseif          reduce using rule 27 (args -> LPAREN explist RPAREN .)
    RPAREN          reduce using rule 27 (args -> LPAREN explist RPAREN .)
    PLUS            reduce using rule 27 (args -> LPAREN explist RPAREN .)
    MINUS           reduce using rule 27 (args -> LPAREN explist RPAREN .)
    TIMES           reduce using rule 27 (args -> LPAREN explist RPAREN .)
    DIVIDE          reduce using rule 27 (args -> LPAREN explist RPAREN .)
    POWER           reduce using rule 27 (args -> LPAREN explist RPAREN .)
    LT              reduce using rule 27 (args -> LPAREN explist RPAREN .)
    LE              reduce using rule 27 (args -> LPAREN explist RPAREN .)
    GT              reduce using rule 27 (args -> LPAREN explist RPAREN .)
    GE              reduce using rule 27 (args -> LPAREN explist RPAREN .)
    NE              reduce using rule 27 (args -> LPAREN explist RPAREN .)
    CHECKEQ         reduce using rule 27 (args -> LPAREN explist RPAREN .)
    and             reduce using rule 27 (args -> LPAREN explist RPAREN .)
    or              reduce using rule 27 (args -> LPAREN explist RPAREN .)
    MODULO          reduce using rule 27 (args -> LPAREN explist RPAREN .)
    DBLDOTS         reduce using rule 27 (args -> LPAREN explist RPAREN .)
    then            reduce using rule 27 (args -> LPAREN explist RPAREN .)
    COMMA           reduce using rule 27 (args -> LPAREN explist RPAREN .)
    RCURLY          reduce using rule 27 (args -> LPAREN explist RPAREN .)
    RSQUARE         reduce using rule 27 (args -> LPAREN explist RPAREN .)


state 140

    (18) stat -> for namelist in explist . do block end
    (52) explist -> explist . COMMA exp

    do              shift and go to state 162
    COMMA           shift and go to state 136


state 141

    (16) stat -> for names EQUALS exp . COMMA exp do block end
    (17) stat -> for names EQUALS exp . COMMA exp COMMA exp do block end
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    COMMA           shift and go to state 163
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 142

    (43) comid -> COMMA names . comid
    (43) comid -> . COMMA names comid
    (44) comid -> . empty
    (82) empty -> .

    COMMA           shift and go to state 101
    in              reduce using rule 82 (empty -> .)
    EQUALS          reduce using rule 82 (empty -> .)
    SEMI            reduce using rule 82 (empty -> .)
    return          reduce using rule 82 (empty -> .)
    break           reduce using rule 82 (empty -> .)
    do              reduce using rule 82 (empty -> .)
    while           reduce using rule 82 (empty -> .)
    repeat          reduce using rule 82 (empty -> .)
    if              reduce using rule 82 (empty -> .)
    for             reduce using rule 82 (empty -> .)
    local           reduce using rule 82 (empty -> .)
    function        reduce using rule 82 (empty -> .)
    LPAREN          reduce using rule 82 (empty -> .)
    ID              reduce using rule 82 (empty -> .)
    RESID           reduce using rule 82 (empty -> .)
    $end            reduce using rule 82 (empty -> .)
    end             reduce using rule 82 (empty -> .)
    until           reduce using rule 82 (empty -> .)
    else            reduce using rule 82 (empty -> .)
    elseif          reduce using rule 82 (empty -> .)
    RPAREN          reduce using rule 82 (empty -> .)

  ! COMMA           [ reduce using rule 82 (empty -> .) ]

    empty                          shift and go to state 100
    comid                          shift and go to state 164

state 143

    (41) comvar -> COMMA var comvar .

    EQUALS          reduce using rule 41 (comvar -> COMMA var comvar .)


state 144

    (22) stat -> local function names funcbody .

    SEMI            reduce using rule 22 (stat -> local function names funcbody .)
    return          reduce using rule 22 (stat -> local function names funcbody .)
    break           reduce using rule 22 (stat -> local function names funcbody .)
    do              reduce using rule 22 (stat -> local function names funcbody .)
    while           reduce using rule 22 (stat -> local function names funcbody .)
    repeat          reduce using rule 22 (stat -> local function names funcbody .)
    if              reduce using rule 22 (stat -> local function names funcbody .)
    for             reduce using rule 22 (stat -> local function names funcbody .)
    local           reduce using rule 22 (stat -> local function names funcbody .)
    function        reduce using rule 22 (stat -> local function names funcbody .)
    LPAREN          reduce using rule 22 (stat -> local function names funcbody .)
    ID              reduce using rule 22 (stat -> local function names funcbody .)
    RESID           reduce using rule 22 (stat -> local function names funcbody .)
    else            reduce using rule 22 (stat -> local function names funcbody .)
    end             reduce using rule 22 (stat -> local function names funcbody .)
    elseif          reduce using rule 22 (stat -> local function names funcbody .)
    $end            reduce using rule 22 (stat -> local function names funcbody .)
    until           reduce using rule 22 (stat -> local function names funcbody .)


state 145

    (20) stat -> local namelist EQUALS explist .
    (52) explist -> explist . COMMA exp

    SEMI            reduce using rule 20 (stat -> local namelist EQUALS explist .)
    return          reduce using rule 20 (stat -> local namelist EQUALS explist .)
    break           reduce using rule 20 (stat -> local namelist EQUALS explist .)
    do              reduce using rule 20 (stat -> local namelist EQUALS explist .)
    while           reduce using rule 20 (stat -> local namelist EQUALS explist .)
    repeat          reduce using rule 20 (stat -> local namelist EQUALS explist .)
    if              reduce using rule 20 (stat -> local namelist EQUALS explist .)
    for             reduce using rule 20 (stat -> local namelist EQUALS explist .)
    local           reduce using rule 20 (stat -> local namelist EQUALS explist .)
    function        reduce using rule 20 (stat -> local namelist EQUALS explist .)
    LPAREN          reduce using rule 20 (stat -> local namelist EQUALS explist .)
    ID              reduce using rule 20 (stat -> local namelist EQUALS explist .)
    RESID           reduce using rule 20 (stat -> local namelist EQUALS explist .)
    else            reduce using rule 20 (stat -> local namelist EQUALS explist .)
    end             reduce using rule 20 (stat -> local namelist EQUALS explist .)
    elseif          reduce using rule 20 (stat -> local namelist EQUALS explist .)
    $end            reduce using rule 20 (stat -> local namelist EQUALS explist .)
    until           reduce using rule 20 (stat -> local namelist EQUALS explist .)
    COMMA           shift and go to state 136


state 146

    (30) parlist -> namelist .
    (31) parlist -> namelist . comtrp
    (33) comtrp -> . COMMA TRPLDOTS

    RPAREN          reduce using rule 30 (parlist -> namelist .)
    COMMA           shift and go to state 165

    comtrp                         shift and go to state 166

state 147

    (32) parlist -> TRPLDOTS .

    RPAREN          reduce using rule 32 (parlist -> TRPLDOTS .)


state 148

    (24) funcbody -> LPAREN parlist . RPAREN block end

    RPAREN          shift and go to state 167


state 149

    (23) funcbody -> LPAREN RPAREN . block end
    (8) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    block                          shift and go to state 168
    var                            shift and go to state 9
    sdash                          shift and go to state 61
    names                          shift and go to state 4

state 150

    (39) dotid -> SDOT names . dotid
    (39) dotid -> . SDOT names dotid
    (40) dotid -> . empty
    (82) empty -> .

    SDOT            shift and go to state 110
    COLON           reduce using rule 82 (empty -> .)

    dotid                          shift and go to state 169
    empty                          shift and go to state 112

state 151

    (37) funcname -> names dotid COLON .

    LPAREN          reduce using rule 37 (funcname -> names dotid COLON .)


state 152

    (13) stat -> repeat block until exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    SEMI            reduce using rule 13 (stat -> repeat block until exp .)
    return          reduce using rule 13 (stat -> repeat block until exp .)
    break           reduce using rule 13 (stat -> repeat block until exp .)
    do              reduce using rule 13 (stat -> repeat block until exp .)
    while           reduce using rule 13 (stat -> repeat block until exp .)
    repeat          reduce using rule 13 (stat -> repeat block until exp .)
    if              reduce using rule 13 (stat -> repeat block until exp .)
    for             reduce using rule 13 (stat -> repeat block until exp .)
    local           reduce using rule 13 (stat -> repeat block until exp .)
    function        reduce using rule 13 (stat -> repeat block until exp .)
    LPAREN          reduce using rule 13 (stat -> repeat block until exp .)
    ID              reduce using rule 13 (stat -> repeat block until exp .)
    RESID           reduce using rule 13 (stat -> repeat block until exp .)
    else            reduce using rule 13 (stat -> repeat block until exp .)
    end             reduce using rule 13 (stat -> repeat block until exp .)
    elseif          reduce using rule 13 (stat -> repeat block until exp .)
    $end            reduce using rule 13 (stat -> repeat block until exp .)
    until           reduce using rule 13 (stat -> repeat block until exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 153

    (12) stat -> while exp do block . end

    end             shift and go to state 170


state 154

    (96) field -> names EQUALS exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 96 (field -> names EQUALS exp .)
    SEMI            reduce using rule 96 (field -> names EQUALS exp .)
    RCURLY          reduce using rule 96 (field -> names EQUALS exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 155

    (91) fieldlist -> field fieldseplist fieldsep .
    (93) fieldseplist -> fieldseplist fieldsep . field
    (95) field -> . LSQUARE exp RSQUARE EQUALS exp
    (96) field -> . names EQUALS exp
    (97) field -> . exp
    (100) names -> . ID
    (101) names -> . RESID
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args

    RCURLY          reduce using rule 91 (fieldlist -> field fieldseplist fieldsep .)
    LSQUARE         shift and go to state 71
    ID              shift and go to state 15
    RESID           shift and go to state 1
    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    field                          shift and go to state 171
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    names                          shift and go to state 66
    exp                            shift and go to state 70
    var                            shift and go to state 26

state 156

    (98) fieldsep -> COMMA .

    LSQUARE         reduce using rule 98 (fieldsep -> COMMA .)
    ID              reduce using rule 98 (fieldsep -> COMMA .)
    RESID           reduce using rule 98 (fieldsep -> COMMA .)
    nil             reduce using rule 98 (fieldsep -> COMMA .)
    false           reduce using rule 98 (fieldsep -> COMMA .)
    true            reduce using rule 98 (fieldsep -> COMMA .)
    STRING          reduce using rule 98 (fieldsep -> COMMA .)
    TRPLDOTS        reduce using rule 98 (fieldsep -> COMMA .)
    function        reduce using rule 98 (fieldsep -> COMMA .)
    INTEGER         reduce using rule 98 (fieldsep -> COMMA .)
    FLOAT           reduce using rule 98 (fieldsep -> COMMA .)
    HEX             reduce using rule 98 (fieldsep -> COMMA .)
    LPAREN          reduce using rule 98 (fieldsep -> COMMA .)
    LCURLY          reduce using rule 98 (fieldsep -> COMMA .)
    MINUS           reduce using rule 98 (fieldsep -> COMMA .)
    not             reduce using rule 98 (fieldsep -> COMMA .)
    HASH            reduce using rule 98 (fieldsep -> COMMA .)
    RCURLY          reduce using rule 98 (fieldsep -> COMMA .)


state 157

    (99) fieldsep -> SEMI .

    LSQUARE         reduce using rule 99 (fieldsep -> SEMI .)
    ID              reduce using rule 99 (fieldsep -> SEMI .)
    RESID           reduce using rule 99 (fieldsep -> SEMI .)
    nil             reduce using rule 99 (fieldsep -> SEMI .)
    false           reduce using rule 99 (fieldsep -> SEMI .)
    true            reduce using rule 99 (fieldsep -> SEMI .)
    STRING          reduce using rule 99 (fieldsep -> SEMI .)
    TRPLDOTS        reduce using rule 99 (fieldsep -> SEMI .)
    function        reduce using rule 99 (fieldsep -> SEMI .)
    INTEGER         reduce using rule 99 (fieldsep -> SEMI .)
    FLOAT           reduce using rule 99 (fieldsep -> SEMI .)
    HEX             reduce using rule 99 (fieldsep -> SEMI .)
    LPAREN          reduce using rule 99 (fieldsep -> SEMI .)
    LCURLY          reduce using rule 99 (fieldsep -> SEMI .)
    MINUS           reduce using rule 99 (fieldsep -> SEMI .)
    not             reduce using rule 99 (fieldsep -> SEMI .)
    HASH            reduce using rule 99 (fieldsep -> SEMI .)
    RCURLY          reduce using rule 99 (fieldsep -> SEMI .)


state 158

    (95) field -> LSQUARE exp RSQUARE . EQUALS exp

    EQUALS          shift and go to state 172


state 159

    (52) explist -> explist COMMA exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    do              reduce using rule 52 (explist -> explist COMMA exp .)
    COMMA           reduce using rule 52 (explist -> explist COMMA exp .)
    SEMI            reduce using rule 52 (explist -> explist COMMA exp .)
    $end            reduce using rule 52 (explist -> explist COMMA exp .)
    end             reduce using rule 52 (explist -> explist COMMA exp .)
    until           reduce using rule 52 (explist -> explist COMMA exp .)
    else            reduce using rule 52 (explist -> explist COMMA exp .)
    elseif          reduce using rule 52 (explist -> explist COMMA exp .)
    RPAREN          reduce using rule 52 (explist -> explist COMMA exp .)
    return          reduce using rule 52 (explist -> explist COMMA exp .)
    break           reduce using rule 52 (explist -> explist COMMA exp .)
    while           reduce using rule 52 (explist -> explist COMMA exp .)
    repeat          reduce using rule 52 (explist -> explist COMMA exp .)
    if              reduce using rule 52 (explist -> explist COMMA exp .)
    for             reduce using rule 52 (explist -> explist COMMA exp .)
    local           reduce using rule 52 (explist -> explist COMMA exp .)
    function        reduce using rule 52 (explist -> explist COMMA exp .)
    LPAREN          reduce using rule 52 (explist -> explist COMMA exp .)
    ID              reduce using rule 52 (explist -> explist COMMA exp .)
    RESID           reduce using rule 52 (explist -> explist COMMA exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 160

    (46) ifblock -> empty .

    else            reduce using rule 46 (ifblock -> empty .)
    end             reduce using rule 46 (ifblock -> empty .)
    elseif          reduce using rule 46 (ifblock -> empty .)


state 161

    (14) stat -> if exp then block ifblock . else block end
    (15) stat -> if exp then block ifblock . end
    (45) ifblock -> ifblock . elseif exp then block

    else            shift and go to state 174
    end             shift and go to state 173
    elseif          shift and go to state 175


state 162

    (18) stat -> for namelist in explist do . block end
    (8) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    block                          shift and go to state 176
    var                            shift and go to state 9
    sdash                          shift and go to state 61
    names                          shift and go to state 4

state 163

    (16) stat -> for names EQUALS exp COMMA . exp do block end
    (17) stat -> for names EQUALS exp COMMA . exp COMMA exp do block end
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    names                          shift and go to state 4
    exp                            shift and go to state 177
    var                            shift and go to state 26

state 164

    (43) comid -> COMMA names comid .

    in              reduce using rule 43 (comid -> COMMA names comid .)
    EQUALS          reduce using rule 43 (comid -> COMMA names comid .)
    SEMI            reduce using rule 43 (comid -> COMMA names comid .)
    return          reduce using rule 43 (comid -> COMMA names comid .)
    break           reduce using rule 43 (comid -> COMMA names comid .)
    do              reduce using rule 43 (comid -> COMMA names comid .)
    while           reduce using rule 43 (comid -> COMMA names comid .)
    repeat          reduce using rule 43 (comid -> COMMA names comid .)
    if              reduce using rule 43 (comid -> COMMA names comid .)
    for             reduce using rule 43 (comid -> COMMA names comid .)
    local           reduce using rule 43 (comid -> COMMA names comid .)
    function        reduce using rule 43 (comid -> COMMA names comid .)
    LPAREN          reduce using rule 43 (comid -> COMMA names comid .)
    ID              reduce using rule 43 (comid -> COMMA names comid .)
    RESID           reduce using rule 43 (comid -> COMMA names comid .)
    $end            reduce using rule 43 (comid -> COMMA names comid .)
    end             reduce using rule 43 (comid -> COMMA names comid .)
    until           reduce using rule 43 (comid -> COMMA names comid .)
    else            reduce using rule 43 (comid -> COMMA names comid .)
    elseif          reduce using rule 43 (comid -> COMMA names comid .)
    COMMA           reduce using rule 43 (comid -> COMMA names comid .)
    RPAREN          reduce using rule 43 (comid -> COMMA names comid .)


state 165

    (33) comtrp -> COMMA . TRPLDOTS

    TRPLDOTS        shift and go to state 178


state 166

    (31) parlist -> namelist comtrp .

    RPAREN          reduce using rule 31 (parlist -> namelist comtrp .)


state 167

    (24) funcbody -> LPAREN parlist RPAREN . block end
    (8) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    var                            shift and go to state 9
    sdash                          shift and go to state 61
    block                          shift and go to state 179
    names                          shift and go to state 4

state 168

    (23) funcbody -> LPAREN RPAREN block . end

    end             shift and go to state 180


state 169

    (39) dotid -> SDOT names dotid .

    COLON           reduce using rule 39 (dotid -> SDOT names dotid .)


state 170

    (12) stat -> while exp do block end .

    SEMI            reduce using rule 12 (stat -> while exp do block end .)
    return          reduce using rule 12 (stat -> while exp do block end .)
    break           reduce using rule 12 (stat -> while exp do block end .)
    do              reduce using rule 12 (stat -> while exp do block end .)
    while           reduce using rule 12 (stat -> while exp do block end .)
    repeat          reduce using rule 12 (stat -> while exp do block end .)
    if              reduce using rule 12 (stat -> while exp do block end .)
    for             reduce using rule 12 (stat -> while exp do block end .)
    local           reduce using rule 12 (stat -> while exp do block end .)
    function        reduce using rule 12 (stat -> while exp do block end .)
    LPAREN          reduce using rule 12 (stat -> while exp do block end .)
    ID              reduce using rule 12 (stat -> while exp do block end .)
    RESID           reduce using rule 12 (stat -> while exp do block end .)
    else            reduce using rule 12 (stat -> while exp do block end .)
    end             reduce using rule 12 (stat -> while exp do block end .)
    elseif          reduce using rule 12 (stat -> while exp do block end .)
    $end            reduce using rule 12 (stat -> while exp do block end .)
    until           reduce using rule 12 (stat -> while exp do block end .)


state 171

    (93) fieldseplist -> fieldseplist fieldsep field .

    COMMA           reduce using rule 93 (fieldseplist -> fieldseplist fieldsep field .)
    SEMI            reduce using rule 93 (fieldseplist -> fieldseplist fieldsep field .)
    RCURLY          reduce using rule 93 (fieldseplist -> fieldseplist fieldsep field .)


state 172

    (95) field -> LSQUARE exp RSQUARE EQUALS . exp
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 181
    var                            shift and go to state 26
    names                          shift and go to state 4

state 173

    (15) stat -> if exp then block ifblock end .

    SEMI            reduce using rule 15 (stat -> if exp then block ifblock end .)
    return          reduce using rule 15 (stat -> if exp then block ifblock end .)
    break           reduce using rule 15 (stat -> if exp then block ifblock end .)
    do              reduce using rule 15 (stat -> if exp then block ifblock end .)
    while           reduce using rule 15 (stat -> if exp then block ifblock end .)
    repeat          reduce using rule 15 (stat -> if exp then block ifblock end .)
    if              reduce using rule 15 (stat -> if exp then block ifblock end .)
    for             reduce using rule 15 (stat -> if exp then block ifblock end .)
    local           reduce using rule 15 (stat -> if exp then block ifblock end .)
    function        reduce using rule 15 (stat -> if exp then block ifblock end .)
    LPAREN          reduce using rule 15 (stat -> if exp then block ifblock end .)
    ID              reduce using rule 15 (stat -> if exp then block ifblock end .)
    RESID           reduce using rule 15 (stat -> if exp then block ifblock end .)
    else            reduce using rule 15 (stat -> if exp then block ifblock end .)
    end             reduce using rule 15 (stat -> if exp then block ifblock end .)
    elseif          reduce using rule 15 (stat -> if exp then block ifblock end .)
    $end            reduce using rule 15 (stat -> if exp then block ifblock end .)
    until           reduce using rule 15 (stat -> if exp then block ifblock end .)


state 174

    (14) stat -> if exp then block ifblock else . block end
    (8) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    block                          shift and go to state 182
    var                            shift and go to state 9
    sdash                          shift and go to state 61
    names                          shift and go to state 4

state 175

    (45) ifblock -> ifblock elseif . exp then block
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    exp                            shift and go to state 183
    var                            shift and go to state 26
    names                          shift and go to state 4

state 176

    (18) stat -> for namelist in explist do block . end

    end             shift and go to state 184


state 177

    (16) stat -> for names EQUALS exp COMMA exp . do block end
    (17) stat -> for names EQUALS exp COMMA exp . COMMA exp do block end
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    do              shift and go to state 186
    COMMA           shift and go to state 185
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 178

    (33) comtrp -> COMMA TRPLDOTS .

    RPAREN          reduce using rule 33 (comtrp -> COMMA TRPLDOTS .)


state 179

    (24) funcbody -> LPAREN parlist RPAREN block . end

    end             shift and go to state 187


state 180

    (23) funcbody -> LPAREN RPAREN block end .

    SEMI            reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    return          reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    break           reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    do              reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    while           reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    repeat          reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    if              reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    for             reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    local           reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    function        reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    LPAREN          reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    ID              reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    RESID           reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    $end            reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    end             reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    until           reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    else            reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)
    elseif          reduce using rule 23 (funcbody -> LPAREN RPAREN block end .)


state 181

    (95) field -> LSQUARE exp RSQUARE EQUALS exp .
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 95 (field -> LSQUARE exp RSQUARE EQUALS exp .)
    SEMI            reduce using rule 95 (field -> LSQUARE exp RSQUARE EQUALS exp .)
    RCURLY          reduce using rule 95 (field -> LSQUARE exp RSQUARE EQUALS exp .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 182

    (14) stat -> if exp then block ifblock else block . end

    end             shift and go to state 188


state 183

    (45) ifblock -> ifblock elseif exp . then block
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    then            shift and go to state 189
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 184

    (18) stat -> for namelist in explist do block end .

    SEMI            reduce using rule 18 (stat -> for namelist in explist do block end .)
    return          reduce using rule 18 (stat -> for namelist in explist do block end .)
    break           reduce using rule 18 (stat -> for namelist in explist do block end .)
    do              reduce using rule 18 (stat -> for namelist in explist do block end .)
    while           reduce using rule 18 (stat -> for namelist in explist do block end .)
    repeat          reduce using rule 18 (stat -> for namelist in explist do block end .)
    if              reduce using rule 18 (stat -> for namelist in explist do block end .)
    for             reduce using rule 18 (stat -> for namelist in explist do block end .)
    local           reduce using rule 18 (stat -> for namelist in explist do block end .)
    function        reduce using rule 18 (stat -> for namelist in explist do block end .)
    LPAREN          reduce using rule 18 (stat -> for namelist in explist do block end .)
    ID              reduce using rule 18 (stat -> for namelist in explist do block end .)
    RESID           reduce using rule 18 (stat -> for namelist in explist do block end .)
    else            reduce using rule 18 (stat -> for namelist in explist do block end .)
    end             reduce using rule 18 (stat -> for namelist in explist do block end .)
    elseif          reduce using rule 18 (stat -> for namelist in explist do block end .)
    $end            reduce using rule 18 (stat -> for namelist in explist do block end .)
    until           reduce using rule 18 (stat -> for namelist in explist do block end .)


state 185

    (17) stat -> for names EQUALS exp COMMA exp COMMA . exp do block end
    (54) exp -> . nil
    (55) exp -> . false
    (56) exp -> . true
    (57) exp -> . Number
    (58) exp -> . STRING
    (59) exp -> . TRPLDOTS
    (60) exp -> . function
    (61) exp -> . prefixexp
    (62) exp -> . exp PLUS exp
    (63) exp -> . exp MINUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp DIVIDE exp
    (66) exp -> . exp POWER exp
    (67) exp -> . exp LT exp
    (68) exp -> . exp LE exp
    (69) exp -> . exp GT exp
    (70) exp -> . exp GE exp
    (71) exp -> . exp NE exp
    (72) exp -> . exp CHECKEQ exp
    (73) exp -> . exp and exp
    (74) exp -> . exp or exp
    (75) exp -> . exp MODULO exp
    (76) exp -> . exp DBLDOTS exp
    (77) exp -> . tableconstructor
    (78) exp -> . unop exp
    (79) Number -> . INTEGER
    (80) Number -> . FLOAT
    (81) Number -> . HEX
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (89) tableconstructor -> . LCURLY fieldlist RCURLY
    (90) tableconstructor -> . LCURLY RCURLY
    (86) unop -> . MINUS
    (87) unop -> . not
    (88) unop -> . HASH
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (25) functioncall -> . prefixexp args
    (100) names -> . ID
    (101) names -> . RESID

    nil             shift and go to state 29
    false           shift and go to state 20
    true            shift and go to state 32
    STRING          shift and go to state 24
    TRPLDOTS        shift and go to state 38
    function        shift and go to state 28
    INTEGER         shift and go to state 27
    FLOAT           shift and go to state 33
    HEX             shift and go to state 30
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 21
    MINUS           shift and go to state 23
    not             shift and go to state 31
    HASH            shift and go to state 22
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 25
    tableconstructor               shift and go to state 19
    Number                         shift and go to state 34
    unop                           shift and go to state 37
    functioncall                   shift and go to state 35
    names                          shift and go to state 4
    exp                            shift and go to state 190
    var                            shift and go to state 26

state 186

    (16) stat -> for names EQUALS exp COMMA exp do . block end
    (8) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    names                          shift and go to state 4
    var                            shift and go to state 9
    sdash                          shift and go to state 61
    block                          shift and go to state 191

state 187

    (24) funcbody -> LPAREN parlist RPAREN block end .

    SEMI            reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    return          reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    break           reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    do              reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    while           reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    repeat          reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    if              reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    for             reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    local           reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    function        reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    LPAREN          reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    ID              reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    RESID           reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    $end            reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    end             reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    until           reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    else            reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)
    elseif          reduce using rule 24 (funcbody -> LPAREN parlist RPAREN block end .)


state 188

    (14) stat -> if exp then block ifblock else block end .

    SEMI            reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    return          reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    break           reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    do              reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    while           reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    repeat          reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    if              reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    for             reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    local           reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    function        reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    LPAREN          reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    ID              reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    RESID           reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    else            reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    end             reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    elseif          reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    $end            reduce using rule 14 (stat -> if exp then block ifblock else block end .)
    until           reduce using rule 14 (stat -> if exp then block ifblock else block end .)


state 189

    (45) ifblock -> ifblock elseif exp then . block
    (8) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    block                          shift and go to state 192
    var                            shift and go to state 9
    sdash                          shift and go to state 61
    names                          shift and go to state 4

state 190

    (17) stat -> for names EQUALS exp COMMA exp COMMA exp . do block end
    (62) exp -> exp . PLUS exp
    (63) exp -> exp . MINUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . DIVIDE exp
    (66) exp -> exp . POWER exp
    (67) exp -> exp . LT exp
    (68) exp -> exp . LE exp
    (69) exp -> exp . GT exp
    (70) exp -> exp . GE exp
    (71) exp -> exp . NE exp
    (72) exp -> exp . CHECKEQ exp
    (73) exp -> exp . and exp
    (74) exp -> exp . or exp
    (75) exp -> exp . MODULO exp
    (76) exp -> exp . DBLDOTS exp

    do              shift and go to state 193
    PLUS            shift and go to state 82
    MINUS           shift and go to state 85
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 87
    POWER           shift and go to state 75
    LT              shift and go to state 80
    LE              shift and go to state 73
    GT              shift and go to state 81
    GE              shift and go to state 77
    NE              shift and go to state 86
    CHECKEQ         shift and go to state 79
    and             shift and go to state 72
    or              shift and go to state 76
    MODULO          shift and go to state 83
    DBLDOTS         shift and go to state 84


state 191

    (16) stat -> for names EQUALS exp COMMA exp do block . end

    end             shift and go to state 194


state 192

    (45) ifblock -> ifblock elseif exp then block .

    else            reduce using rule 45 (ifblock -> ifblock elseif exp then block .)
    end             reduce using rule 45 (ifblock -> ifblock elseif exp then block .)
    elseif          reduce using rule 45 (ifblock -> ifblock elseif exp then block .)


state 193

    (17) stat -> for names EQUALS exp COMMA exp COMMA exp do . block end
    (8) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . chunk laststat SEMI
    (4) chunk -> . chunk stat
    (5) chunk -> . chunk stat SEMI
    (6) chunk -> . stat
    (7) chunk -> . stat SEMI
    (9) stat -> . varlist EQUALS explist
    (10) stat -> . do block end
    (11) stat -> . functioncall
    (12) stat -> . while exp do block end
    (13) stat -> . repeat block until exp
    (14) stat -> . if exp then block ifblock else block end
    (15) stat -> . if exp then block ifblock end
    (16) stat -> . for names EQUALS exp COMMA exp do block end
    (17) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (18) stat -> . for namelist in explist do block end
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . function funcname funcbody
    (22) stat -> . local function names funcbody
    (47) varlist -> . var comvar
    (25) functioncall -> . prefixexp args
    (48) var -> . names
    (49) var -> . prefixexp LSQUARE exp RSQUARE
    (50) var -> . prefixexp SDOT names
    (83) prefixexp -> . var
    (84) prefixexp -> . LPAREN exp RPAREN
    (85) prefixexp -> . functioncall
    (100) names -> . ID
    (101) names -> . RESID

    do              shift and go to state 12
    while           shift and go to state 16
    repeat          shift and go to state 14
    if              shift and go to state 5
    for             shift and go to state 7
    local           shift and go to state 10
    function        shift and go to state 11
    LPAREN          shift and go to state 2
    ID              shift and go to state 15
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 13
    varlist                        shift and go to state 8
    chunk                          shift and go to state 3
    functioncall                   shift and go to state 17
    names                          shift and go to state 4
    var                            shift and go to state 9
    sdash                          shift and go to state 61
    block                          shift and go to state 195

state 194

    (16) stat -> for names EQUALS exp COMMA exp do block end .

    SEMI            reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    return          reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    break           reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    do              reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    while           reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    repeat          reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    if              reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    for             reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    local           reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    function        reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    LPAREN          reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    ID              reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    RESID           reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    else            reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    end             reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    elseif          reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    $end            reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)
    until           reduce using rule 16 (stat -> for names EQUALS exp COMMA exp do block end .)


state 195

    (17) stat -> for names EQUALS exp COMMA exp COMMA exp do block . end

    end             shift and go to state 196


state 196

    (17) stat -> for names EQUALS exp COMMA exp COMMA exp do block end .

    SEMI            reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    return          reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    break           reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    do              reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    while           reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    repeat          reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    if              reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    for             reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    local           reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    function        reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    LPAREN          reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    ID              reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    RESID           reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    else            reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    end             reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    elseif          reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    $end            reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    until           reduce using rule 17 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 25 resolved as shift
WARNING: reduce/reduce conflict in state 17 resolved using rule (stat -> functioncall)
WARNING: rejected rule (prefixexp -> functioncall) in state 17
