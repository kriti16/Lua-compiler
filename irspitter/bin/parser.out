Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    NEWLINE
    TDASH

Grammar

Rule 0     S' -> sdash
Rule 1     sdash -> chunk
Rule 2     sdash -> chunk laststat
Rule 3     sdash -> laststat
Rule 4     sdash -> chunk laststat SEMI
Rule 5     chunk -> chunk stat
Rule 6     chunk -> chunk stat SEMI
Rule 7     chunk -> stat SEMI
Rule 8     chunk -> stat
Rule 9     block -> sdash
Rule 10    stat -> varlist EQUALS explist
Rule 11    stat -> for names EQUALS exp COMMA exp do block end
Rule 12    stat -> for names EQUALS exp COMMA exp COMMA exp do block end
Rule 13    stat -> for namelist in explist do block end
Rule 14    stat -> while exp do block end
Rule 15    stat -> repeat block until exp
Rule 16    stat -> do block end
Rule 17    stat -> function funcname funcbody
Rule 18    stat -> local function names funcbody
Rule 19    stat -> local namelist
Rule 20    stat -> local namelist EQUALS explist
Rule 21    stat -> functioncall
Rule 22    funcbody -> LPAREN RPAREN block end
Rule 23    funcbody -> LPAREN parlist RPAREN block end
Rule 24    functioncall -> prefixexp args
Rule 25    args -> LPAREN RPAREN
Rule 26    args -> LPAREN explist RPAREN
Rule 27    args -> tableconstructor
Rule 28    args -> STRING
Rule 29    parlist -> namelist
Rule 30    parlist -> namelist comtrp
Rule 31    parlist -> TRPLDOTS
Rule 32    comtrp -> COMMA TRPLDOTS
Rule 33    laststat -> return retexplist
Rule 34    laststat -> return
Rule 35    laststat -> break
Rule 36    funcname -> names dotid COLON
Rule 37    funcname -> names
Rule 38    dotid -> SDOT names dotid
Rule 39    dotid -> empty
Rule 40    comvar -> COMMA var comvar
Rule 41    comvar -> empty
Rule 42    comid -> COMMA names comid
Rule 43    comid -> empty
Rule 44    stat -> if exp then M_if1 block ifblock end
Rule 45    M_if1 -> empty
Rule 46    stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end
Rule 47    M_if2 -> empty
Rule 48    M_if3 -> empty
Rule 49    M_if4 -> empty
Rule 50    ifblock -> ifblock M_if5 elseif M_if6 exp then block
Rule 51    ifblock -> empty
Rule 52    M_if5 -> empty
Rule 53    M_if6 -> empty
Rule 54    varlist -> var comvar
Rule 55    var -> names
Rule 56    var -> prefixexp LSQUARE exp RSQUARE
Rule 57    var -> prefixexp SDOT names
Rule 58    namelist -> names comid
Rule 59    explist -> explist COMMA exp
Rule 60    explist -> exp
Rule 61    exp -> nil
Rule 62    exp -> false
Rule 63    exp -> true
Rule 64    exp -> Number
Rule 65    exp -> STRING
Rule 66    exp -> TRPLDOTS
Rule 67    exp -> function
Rule 68    exp -> prefixexp
Rule 69    exp -> exp PLUS exp
Rule 70    exp -> exp MINUS exp
Rule 71    exp -> exp TIMES exp
Rule 72    exp -> exp DIVIDE exp
Rule 73    exp -> exp POWER exp
Rule 74    exp -> exp LT exp
Rule 75    exp -> exp LE exp
Rule 76    exp -> exp GT exp
Rule 77    exp -> exp GE exp
Rule 78    exp -> exp NE exp
Rule 79    exp -> exp CHECKEQ exp
Rule 80    exp -> exp and exp
Rule 81    exp -> exp or exp
Rule 82    exp -> exp MODULO exp
Rule 83    exp -> exp DBLDOTS exp
Rule 84    exp -> tableconstructor
Rule 85    exp -> unop exp
Rule 86    retexplist -> retexplist COMMA retexp
Rule 87    retexplist -> retexp
Rule 88    retexp -> nil
Rule 89    retexp -> false
Rule 90    retexp -> true
Rule 91    retexp -> Number
Rule 92    retexp -> STRING
Rule 93    retexp -> TRPLDOTS
Rule 94    retexp -> prefixexp
Rule 95    retexp -> exp PLUS exp
Rule 96    retexp -> exp MINUS exp
Rule 97    retexp -> exp TIMES exp
Rule 98    retexp -> exp DIVIDE exp
Rule 99    retexp -> exp POWER exp
Rule 100   retexp -> exp LT exp
Rule 101   retexp -> exp LE exp
Rule 102   retexp -> exp GT exp
Rule 103   retexp -> exp GE exp
Rule 104   retexp -> exp NE exp
Rule 105   retexp -> exp CHECKEQ exp
Rule 106   retexp -> exp and exp
Rule 107   retexp -> exp or exp
Rule 108   retexp -> exp MODULO exp
Rule 109   retexp -> exp DBLDOTS exp
Rule 110   retexp -> tableconstructor
Rule 111   retexp -> unop exp
Rule 112   Number -> INTEGER
Rule 113   Number -> FLOAT
Rule 114   Number -> HEX
Rule 115   empty -> <empty>
Rule 116   prefixexp -> var
Rule 117   prefixexp -> LPAREN exp RPAREN
Rule 118   prefixexp -> functioncall
Rule 119   unop -> MINUS
Rule 120   unop -> not
Rule 121   unop -> HASH
Rule 122   tableconstructor -> LCURLY fieldlist RCURLY
Rule 123   tableconstructor -> LCURLY RCURLY
Rule 124   fieldlist -> field fieldseplist fieldsep
Rule 125   fieldlist -> field fieldseplist
Rule 126   fieldseplist -> fieldseplist fieldsep field
Rule 127   fieldseplist -> empty
Rule 128   field -> LSQUARE exp RSQUARE EQUALS exp
Rule 129   field -> names EQUALS exp
Rule 130   field -> exp
Rule 131   fieldsep -> COMMA
Rule 132   fieldsep -> SEMI
Rule 133   names -> ID
Rule 134   names -> RESID

Terminals, with rules where they appear

CHECKEQ              : 79 105
COLON                : 36
COMMA                : 11 12 12 32 40 42 59 86 131
DBLDOTS              : 83 109
DIVIDE               : 72 98
EQUALS               : 10 11 12 20 128 129
FLOAT                : 113
GE                   : 77 103
GT                   : 76 102
HASH                 : 121
HEX                  : 114
ID                   : 133
INTEGER              : 112
LCURLY               : 122 123
LE                   : 75 101
LPAREN               : 22 23 25 26 117
LSQUARE              : 56 128
LT                   : 74 100
MINUS                : 70 96 119
MODULO               : 82 108
NE                   : 78 104
NEWLINE              : 
PLUS                 : 69 95
POWER                : 73 99
RCURLY               : 122 123
RESID                : 134
RPAREN               : 22 23 25 26 117
RSQUARE              : 56 128
SDOT                 : 38 57
SEMI                 : 4 6 7 132
STRING               : 28 65 92
TDASH                : 
TIMES                : 71 97
TRPLDOTS             : 31 32 66 93
and                  : 80 106
break                : 35
do                   : 11 12 13 14 16
else                 : 46
elseif               : 50
end                  : 11 12 13 14 16 22 23 44 46
error                : 
false                : 62 89
for                  : 11 12 13
function             : 17 18 67
if                   : 44 46
in                   : 13
local                : 18 19 20
nil                  : 61 88
not                  : 120
or                   : 81 107
repeat               : 15
return               : 33 34
then                 : 44 46 50
true                 : 63 90
until                : 15
while                : 14

Nonterminals, with rules where they appear

M_if1                : 44 46
M_if2                : 
M_if3                : 46
M_if4                : 46
M_if5                : 50
M_if6                : 50
Number               : 64 91
args                 : 24
block                : 11 12 13 14 15 16 22 23 44 46 46 50
chunk                : 1 2 4 5 6
comid                : 42 58
comtrp               : 30
comvar               : 40 54
dotid                : 36 38
empty                : 39 41 43 45 47 48 49 51 52 53 127
exp                  : 11 11 12 12 12 14 15 44 46 50 56 59 60 69 69 70 70 71 71 72 72 73 73 74 74 75 75 76 76 77 77 78 78 79 79 80 80 81 81 82 82 83 83 85 95 95 96 96 97 97 98 98 99 99 100 100 101 101 102 102 103 103 104 104 105 105 106 106 107 107 108 108 109 109 111 117 128 128 129 130
explist              : 10 13 20 26 59
field                : 124 125 126
fieldlist            : 122
fieldsep             : 124 126
fieldseplist         : 124 125 126
funcbody             : 17 18
funcname             : 17
functioncall         : 21 118
ifblock              : 44 46 50
laststat             : 2 3 4
namelist             : 13 19 20 29 30
names                : 11 12 18 36 37 38 42 55 57 58 129
parlist              : 23
prefixexp            : 24 56 57 68 94
retexp               : 86 87
retexplist           : 33 86
sdash                : 9 0
stat                 : 5 6 7 8
tableconstructor     : 27 84 110
unop                 : 85 111
var                  : 40 54 116
varlist              : 10

Parsing method: LALR

state 0

    (0) S' -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    functioncall                   shift and go to state 11
    stat                           shift and go to state 14
    sdash                          shift and go to state 21

state 1

    (134) names -> RESID .

    COMMA           reduce using rule 134 (names -> RESID .)
    EQUALS          reduce using rule 134 (names -> RESID .)
    LSQUARE         reduce using rule 134 (names -> RESID .)
    SDOT            reduce using rule 134 (names -> RESID .)
    LPAREN          reduce using rule 134 (names -> RESID .)
    STRING          reduce using rule 134 (names -> RESID .)
    LCURLY          reduce using rule 134 (names -> RESID .)
    $end            reduce using rule 134 (names -> RESID .)
    SEMI            reduce using rule 134 (names -> RESID .)
    end             reduce using rule 134 (names -> RESID .)
    until           reduce using rule 134 (names -> RESID .)
    else            reduce using rule 134 (names -> RESID .)
    elseif          reduce using rule 134 (names -> RESID .)
    PLUS            reduce using rule 134 (names -> RESID .)
    MINUS           reduce using rule 134 (names -> RESID .)
    TIMES           reduce using rule 134 (names -> RESID .)
    DIVIDE          reduce using rule 134 (names -> RESID .)
    POWER           reduce using rule 134 (names -> RESID .)
    LT              reduce using rule 134 (names -> RESID .)
    LE              reduce using rule 134 (names -> RESID .)
    GT              reduce using rule 134 (names -> RESID .)
    GE              reduce using rule 134 (names -> RESID .)
    NE              reduce using rule 134 (names -> RESID .)
    CHECKEQ         reduce using rule 134 (names -> RESID .)
    and             reduce using rule 134 (names -> RESID .)
    or              reduce using rule 134 (names -> RESID .)
    MODULO          reduce using rule 134 (names -> RESID .)
    DBLDOTS         reduce using rule 134 (names -> RESID .)
    RPAREN          reduce using rule 134 (names -> RESID .)
    then            reduce using rule 134 (names -> RESID .)
    do              reduce using rule 134 (names -> RESID .)
    RCURLY          reduce using rule 134 (names -> RESID .)
    RSQUARE         reduce using rule 134 (names -> RESID .)
    return          reduce using rule 134 (names -> RESID .)
    break           reduce using rule 134 (names -> RESID .)
    for             reduce using rule 134 (names -> RESID .)
    while           reduce using rule 134 (names -> RESID .)
    repeat          reduce using rule 134 (names -> RESID .)
    function        reduce using rule 134 (names -> RESID .)
    local           reduce using rule 134 (names -> RESID .)
    if              reduce using rule 134 (names -> RESID .)
    ID              reduce using rule 134 (names -> RESID .)
    RESID           reduce using rule 134 (names -> RESID .)
    COLON           reduce using rule 134 (names -> RESID .)
    in              reduce using rule 134 (names -> RESID .)


state 2

    (117) prefixexp -> LPAREN . exp RPAREN
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 39
    var                            shift and go to state 29
    names                          shift and go to state 4

state 3

    (1) sdash -> chunk .
    (2) sdash -> chunk . laststat
    (4) sdash -> chunk . laststat SEMI
    (5) chunk -> chunk . stat
    (6) chunk -> chunk . stat SEMI
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    end             reduce using rule 1 (sdash -> chunk .)
    else            reduce using rule 1 (sdash -> chunk .)
    elseif          reduce using rule 1 (sdash -> chunk .)
    $end            reduce using rule 1 (sdash -> chunk .)
    until           reduce using rule 1 (sdash -> chunk .)
    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 6
    stat                           shift and go to state 43
    varlist                        shift and go to state 8
    laststat                       shift and go to state 42
    names                          shift and go to state 4
    var                            shift and go to state 10
    functioncall                   shift and go to state 11

state 4

    (55) var -> names .

    COMMA           reduce using rule 55 (var -> names .)
    EQUALS          reduce using rule 55 (var -> names .)
    LSQUARE         reduce using rule 55 (var -> names .)
    SDOT            reduce using rule 55 (var -> names .)
    LPAREN          reduce using rule 55 (var -> names .)
    STRING          reduce using rule 55 (var -> names .)
    LCURLY          reduce using rule 55 (var -> names .)
    PLUS            reduce using rule 55 (var -> names .)
    MINUS           reduce using rule 55 (var -> names .)
    TIMES           reduce using rule 55 (var -> names .)
    DIVIDE          reduce using rule 55 (var -> names .)
    POWER           reduce using rule 55 (var -> names .)
    LT              reduce using rule 55 (var -> names .)
    LE              reduce using rule 55 (var -> names .)
    GT              reduce using rule 55 (var -> names .)
    GE              reduce using rule 55 (var -> names .)
    NE              reduce using rule 55 (var -> names .)
    CHECKEQ         reduce using rule 55 (var -> names .)
    and             reduce using rule 55 (var -> names .)
    or              reduce using rule 55 (var -> names .)
    MODULO          reduce using rule 55 (var -> names .)
    DBLDOTS         reduce using rule 55 (var -> names .)
    $end            reduce using rule 55 (var -> names .)
    SEMI            reduce using rule 55 (var -> names .)
    end             reduce using rule 55 (var -> names .)
    until           reduce using rule 55 (var -> names .)
    else            reduce using rule 55 (var -> names .)
    elseif          reduce using rule 55 (var -> names .)
    RPAREN          reduce using rule 55 (var -> names .)
    then            reduce using rule 55 (var -> names .)
    do              reduce using rule 55 (var -> names .)
    RCURLY          reduce using rule 55 (var -> names .)
    RSQUARE         reduce using rule 55 (var -> names .)
    return          reduce using rule 55 (var -> names .)
    break           reduce using rule 55 (var -> names .)
    for             reduce using rule 55 (var -> names .)
    while           reduce using rule 55 (var -> names .)
    repeat          reduce using rule 55 (var -> names .)
    function        reduce using rule 55 (var -> names .)
    local           reduce using rule 55 (var -> names .)
    if              reduce using rule 55 (var -> names .)
    ID              reduce using rule 55 (var -> names .)
    RESID           reduce using rule 55 (var -> names .)


state 5

    (44) stat -> if . exp then M_if1 block ifblock end
    (46) stat -> if . exp then M_if1 block ifblock M_if3 else M_if4 block end
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    names                          shift and go to state 4
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 44
    var                            shift and go to state 29

state 6

    (24) functioncall -> prefixexp . args
    (56) var -> prefixexp . LSQUARE exp RSQUARE
    (57) var -> prefixexp . SDOT names
    (25) args -> . LPAREN RPAREN
    (26) args -> . LPAREN explist RPAREN
    (27) args -> . tableconstructor
    (28) args -> . STRING
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY

    LSQUARE         shift and go to state 46
    SDOT            shift and go to state 49
    LPAREN          shift and go to state 48
    STRING          shift and go to state 50
    LCURLY          shift and go to state 24

    tableconstructor               shift and go to state 45
    args                           shift and go to state 47

state 7

    (11) stat -> for . names EQUALS exp COMMA exp do block end
    (12) stat -> for . names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> for . namelist in explist do block end
    (133) names -> . ID
    (134) names -> . RESID
    (58) namelist -> . names comid

    ID              shift and go to state 18
    RESID           shift and go to state 1

    namelist                       shift and go to state 51
    names                          shift and go to state 52

state 8

    (10) stat -> varlist . EQUALS explist

    EQUALS          shift and go to state 53


state 9

    (3) sdash -> laststat .

    end             reduce using rule 3 (sdash -> laststat .)
    else            reduce using rule 3 (sdash -> laststat .)
    elseif          reduce using rule 3 (sdash -> laststat .)
    $end            reduce using rule 3 (sdash -> laststat .)
    until           reduce using rule 3 (sdash -> laststat .)


state 10

    (54) varlist -> var . comvar
    (116) prefixexp -> var .
    (40) comvar -> . COMMA var comvar
    (41) comvar -> . empty
    (115) empty -> .

    LSQUARE         reduce using rule 116 (prefixexp -> var .)
    SDOT            reduce using rule 116 (prefixexp -> var .)
    LPAREN          reduce using rule 116 (prefixexp -> var .)
    STRING          reduce using rule 116 (prefixexp -> var .)
    LCURLY          reduce using rule 116 (prefixexp -> var .)
    COMMA           shift and go to state 54
    EQUALS          reduce using rule 115 (empty -> .)

    comvar                         shift and go to state 55
    empty                          shift and go to state 56

state 11

    (21) stat -> functioncall .
    (118) prefixexp -> functioncall .

  ! reduce/reduce conflict for LPAREN resolved using rule 21 (stat -> functioncall .)
    SEMI            reduce using rule 21 (stat -> functioncall .)
    return          reduce using rule 21 (stat -> functioncall .)
    break           reduce using rule 21 (stat -> functioncall .)
    for             reduce using rule 21 (stat -> functioncall .)
    while           reduce using rule 21 (stat -> functioncall .)
    repeat          reduce using rule 21 (stat -> functioncall .)
    do              reduce using rule 21 (stat -> functioncall .)
    function        reduce using rule 21 (stat -> functioncall .)
    local           reduce using rule 21 (stat -> functioncall .)
    if              reduce using rule 21 (stat -> functioncall .)
    LPAREN          reduce using rule 21 (stat -> functioncall .)
    ID              reduce using rule 21 (stat -> functioncall .)
    RESID           reduce using rule 21 (stat -> functioncall .)
    end             reduce using rule 21 (stat -> functioncall .)
    $end            reduce using rule 21 (stat -> functioncall .)
    until           reduce using rule 21 (stat -> functioncall .)
    else            reduce using rule 21 (stat -> functioncall .)
    elseif          reduce using rule 21 (stat -> functioncall .)
    LSQUARE         reduce using rule 118 (prefixexp -> functioncall .)
    SDOT            reduce using rule 118 (prefixexp -> functioncall .)
    STRING          reduce using rule 118 (prefixexp -> functioncall .)
    LCURLY          reduce using rule 118 (prefixexp -> functioncall .)

  ! LPAREN          [ reduce using rule 118 (prefixexp -> functioncall .) ]


state 12

    (17) stat -> function . funcname funcbody
    (36) funcname -> . names dotid COLON
    (37) funcname -> . names
    (133) names -> . ID
    (134) names -> . RESID

    ID              shift and go to state 18
    RESID           shift and go to state 1

    names                          shift and go to state 58
    funcname                       shift and go to state 57

state 13

    (16) stat -> do . block end
    (9) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    functioncall                   shift and go to state 11
    stat                           shift and go to state 14
    sdash                          shift and go to state 59
    block                          shift and go to state 60

state 14

    (7) chunk -> stat . SEMI
    (8) chunk -> stat .

    SEMI            shift and go to state 61
    return          reduce using rule 8 (chunk -> stat .)
    break           reduce using rule 8 (chunk -> stat .)
    for             reduce using rule 8 (chunk -> stat .)
    while           reduce using rule 8 (chunk -> stat .)
    repeat          reduce using rule 8 (chunk -> stat .)
    do              reduce using rule 8 (chunk -> stat .)
    function        reduce using rule 8 (chunk -> stat .)
    local           reduce using rule 8 (chunk -> stat .)
    if              reduce using rule 8 (chunk -> stat .)
    LPAREN          reduce using rule 8 (chunk -> stat .)
    ID              reduce using rule 8 (chunk -> stat .)
    RESID           reduce using rule 8 (chunk -> stat .)
    end             reduce using rule 8 (chunk -> stat .)
    else            reduce using rule 8 (chunk -> stat .)
    elseif          reduce using rule 8 (chunk -> stat .)
    until           reduce using rule 8 (chunk -> stat .)
    $end            reduce using rule 8 (chunk -> stat .)


state 15

    (15) stat -> repeat . block until exp
    (9) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    functioncall                   shift and go to state 11
    stat                           shift and go to state 14
    block                          shift and go to state 62
    sdash                          shift and go to state 59

state 16

    (33) laststat -> return . retexplist
    (34) laststat -> return .
    (86) retexplist -> . retexplist COMMA retexp
    (87) retexplist -> . retexp
    (88) retexp -> . nil
    (89) retexp -> . false
    (90) retexp -> . true
    (91) retexp -> . Number
    (92) retexp -> . STRING
    (93) retexp -> . TRPLDOTS
    (94) retexp -> . prefixexp
    (95) retexp -> . exp PLUS exp
    (96) retexp -> . exp MINUS exp
    (97) retexp -> . exp TIMES exp
    (98) retexp -> . exp DIVIDE exp
    (99) retexp -> . exp POWER exp
    (100) retexp -> . exp LT exp
    (101) retexp -> . exp LE exp
    (102) retexp -> . exp GT exp
    (103) retexp -> . exp GE exp
    (104) retexp -> . exp NE exp
    (105) retexp -> . exp CHECKEQ exp
    (106) retexp -> . exp and exp
    (107) retexp -> . exp or exp
    (108) retexp -> . exp MODULO exp
    (109) retexp -> . exp DBLDOTS exp
    (110) retexp -> . tableconstructor
    (111) retexp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    end             reduce using rule 34 (laststat -> return .)
    else            reduce using rule 34 (laststat -> return .)
    elseif          reduce using rule 34 (laststat -> return .)
    $end            reduce using rule 34 (laststat -> return .)
    SEMI            reduce using rule 34 (laststat -> return .)
    until           reduce using rule 34 (laststat -> return .)
    nil             shift and go to state 69
    false           shift and go to state 64
    true            shift and go to state 70
    STRING          shift and go to state 68
    TRPLDOTS        shift and go to state 65
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    function        shift and go to state 31
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 66
    tableconstructor               shift and go to state 63
    retexp                         shift and go to state 67
    Number                         shift and go to state 71
    unop                           shift and go to state 74
    retexplist                     shift and go to state 72
    exp                            shift and go to state 73
    var                            shift and go to state 29
    functioncall                   shift and go to state 38
    names                          shift and go to state 4

state 17

    (35) laststat -> break .

    end             reduce using rule 35 (laststat -> break .)
    else            reduce using rule 35 (laststat -> break .)
    elseif          reduce using rule 35 (laststat -> break .)
    $end            reduce using rule 35 (laststat -> break .)
    SEMI            reduce using rule 35 (laststat -> break .)
    until           reduce using rule 35 (laststat -> break .)


state 18

    (133) names -> ID .

    COMMA           reduce using rule 133 (names -> ID .)
    EQUALS          reduce using rule 133 (names -> ID .)
    LSQUARE         reduce using rule 133 (names -> ID .)
    SDOT            reduce using rule 133 (names -> ID .)
    LPAREN          reduce using rule 133 (names -> ID .)
    STRING          reduce using rule 133 (names -> ID .)
    LCURLY          reduce using rule 133 (names -> ID .)
    $end            reduce using rule 133 (names -> ID .)
    SEMI            reduce using rule 133 (names -> ID .)
    end             reduce using rule 133 (names -> ID .)
    until           reduce using rule 133 (names -> ID .)
    else            reduce using rule 133 (names -> ID .)
    elseif          reduce using rule 133 (names -> ID .)
    PLUS            reduce using rule 133 (names -> ID .)
    MINUS           reduce using rule 133 (names -> ID .)
    TIMES           reduce using rule 133 (names -> ID .)
    DIVIDE          reduce using rule 133 (names -> ID .)
    POWER           reduce using rule 133 (names -> ID .)
    LT              reduce using rule 133 (names -> ID .)
    LE              reduce using rule 133 (names -> ID .)
    GT              reduce using rule 133 (names -> ID .)
    GE              reduce using rule 133 (names -> ID .)
    NE              reduce using rule 133 (names -> ID .)
    CHECKEQ         reduce using rule 133 (names -> ID .)
    and             reduce using rule 133 (names -> ID .)
    or              reduce using rule 133 (names -> ID .)
    MODULO          reduce using rule 133 (names -> ID .)
    DBLDOTS         reduce using rule 133 (names -> ID .)
    RPAREN          reduce using rule 133 (names -> ID .)
    then            reduce using rule 133 (names -> ID .)
    do              reduce using rule 133 (names -> ID .)
    RCURLY          reduce using rule 133 (names -> ID .)
    RSQUARE         reduce using rule 133 (names -> ID .)
    return          reduce using rule 133 (names -> ID .)
    break           reduce using rule 133 (names -> ID .)
    for             reduce using rule 133 (names -> ID .)
    while           reduce using rule 133 (names -> ID .)
    repeat          reduce using rule 133 (names -> ID .)
    function        reduce using rule 133 (names -> ID .)
    local           reduce using rule 133 (names -> ID .)
    if              reduce using rule 133 (names -> ID .)
    ID              reduce using rule 133 (names -> ID .)
    RESID           reduce using rule 133 (names -> ID .)
    COLON           reduce using rule 133 (names -> ID .)
    in              reduce using rule 133 (names -> ID .)


state 19

    (18) stat -> local . function names funcbody
    (19) stat -> local . namelist
    (20) stat -> local . namelist EQUALS explist
    (58) namelist -> . names comid
    (133) names -> . ID
    (134) names -> . RESID

    function        shift and go to state 75
    ID              shift and go to state 18
    RESID           shift and go to state 1

    namelist                       shift and go to state 76
    names                          shift and go to state 77

state 20

    (14) stat -> while . exp do block end
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 78
    var                            shift and go to state 29
    names                          shift and go to state 4

state 21

    (0) S' -> sdash .



state 22

    (84) exp -> tableconstructor .

    PLUS            reduce using rule 84 (exp -> tableconstructor .)
    MINUS           reduce using rule 84 (exp -> tableconstructor .)
    TIMES           reduce using rule 84 (exp -> tableconstructor .)
    DIVIDE          reduce using rule 84 (exp -> tableconstructor .)
    POWER           reduce using rule 84 (exp -> tableconstructor .)
    LT              reduce using rule 84 (exp -> tableconstructor .)
    LE              reduce using rule 84 (exp -> tableconstructor .)
    GT              reduce using rule 84 (exp -> tableconstructor .)
    GE              reduce using rule 84 (exp -> tableconstructor .)
    NE              reduce using rule 84 (exp -> tableconstructor .)
    CHECKEQ         reduce using rule 84 (exp -> tableconstructor .)
    and             reduce using rule 84 (exp -> tableconstructor .)
    or              reduce using rule 84 (exp -> tableconstructor .)
    MODULO          reduce using rule 84 (exp -> tableconstructor .)
    DBLDOTS         reduce using rule 84 (exp -> tableconstructor .)
    RPAREN          reduce using rule 84 (exp -> tableconstructor .)
    then            reduce using rule 84 (exp -> tableconstructor .)
    do              reduce using rule 84 (exp -> tableconstructor .)
    COMMA           reduce using rule 84 (exp -> tableconstructor .)
    SEMI            reduce using rule 84 (exp -> tableconstructor .)
    RCURLY          reduce using rule 84 (exp -> tableconstructor .)
    RSQUARE         reduce using rule 84 (exp -> tableconstructor .)
    return          reduce using rule 84 (exp -> tableconstructor .)
    break           reduce using rule 84 (exp -> tableconstructor .)
    for             reduce using rule 84 (exp -> tableconstructor .)
    while           reduce using rule 84 (exp -> tableconstructor .)
    repeat          reduce using rule 84 (exp -> tableconstructor .)
    function        reduce using rule 84 (exp -> tableconstructor .)
    local           reduce using rule 84 (exp -> tableconstructor .)
    if              reduce using rule 84 (exp -> tableconstructor .)
    LPAREN          reduce using rule 84 (exp -> tableconstructor .)
    ID              reduce using rule 84 (exp -> tableconstructor .)
    RESID           reduce using rule 84 (exp -> tableconstructor .)
    $end            reduce using rule 84 (exp -> tableconstructor .)
    end             reduce using rule 84 (exp -> tableconstructor .)
    until           reduce using rule 84 (exp -> tableconstructor .)
    else            reduce using rule 84 (exp -> tableconstructor .)
    elseif          reduce using rule 84 (exp -> tableconstructor .)


state 23

    (62) exp -> false .

    PLUS            reduce using rule 62 (exp -> false .)
    MINUS           reduce using rule 62 (exp -> false .)
    TIMES           reduce using rule 62 (exp -> false .)
    DIVIDE          reduce using rule 62 (exp -> false .)
    POWER           reduce using rule 62 (exp -> false .)
    LT              reduce using rule 62 (exp -> false .)
    LE              reduce using rule 62 (exp -> false .)
    GT              reduce using rule 62 (exp -> false .)
    GE              reduce using rule 62 (exp -> false .)
    NE              reduce using rule 62 (exp -> false .)
    CHECKEQ         reduce using rule 62 (exp -> false .)
    and             reduce using rule 62 (exp -> false .)
    or              reduce using rule 62 (exp -> false .)
    MODULO          reduce using rule 62 (exp -> false .)
    DBLDOTS         reduce using rule 62 (exp -> false .)
    RPAREN          reduce using rule 62 (exp -> false .)
    then            reduce using rule 62 (exp -> false .)
    do              reduce using rule 62 (exp -> false .)
    COMMA           reduce using rule 62 (exp -> false .)
    SEMI            reduce using rule 62 (exp -> false .)
    RCURLY          reduce using rule 62 (exp -> false .)
    RSQUARE         reduce using rule 62 (exp -> false .)
    return          reduce using rule 62 (exp -> false .)
    break           reduce using rule 62 (exp -> false .)
    for             reduce using rule 62 (exp -> false .)
    while           reduce using rule 62 (exp -> false .)
    repeat          reduce using rule 62 (exp -> false .)
    function        reduce using rule 62 (exp -> false .)
    local           reduce using rule 62 (exp -> false .)
    if              reduce using rule 62 (exp -> false .)
    LPAREN          reduce using rule 62 (exp -> false .)
    ID              reduce using rule 62 (exp -> false .)
    RESID           reduce using rule 62 (exp -> false .)
    $end            reduce using rule 62 (exp -> false .)
    end             reduce using rule 62 (exp -> false .)
    until           reduce using rule 62 (exp -> false .)
    else            reduce using rule 62 (exp -> false .)
    elseif          reduce using rule 62 (exp -> false .)


state 24

    (122) tableconstructor -> LCURLY . fieldlist RCURLY
    (123) tableconstructor -> LCURLY . RCURLY
    (124) fieldlist -> . field fieldseplist fieldsep
    (125) fieldlist -> . field fieldseplist
    (128) field -> . LSQUARE exp RSQUARE EQUALS exp
    (129) field -> . names EQUALS exp
    (130) field -> . exp
    (133) names -> . ID
    (134) names -> . RESID
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args

    RCURLY          shift and go to state 80
    LSQUARE         shift and go to state 84
    ID              shift and go to state 18
    RESID           shift and go to state 1
    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    field                          shift and go to state 81
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    fieldlist                      shift and go to state 82
    exp                            shift and go to state 83
    var                            shift and go to state 29
    names                          shift and go to state 79

state 25

    (121) unop -> HASH .

    nil             reduce using rule 121 (unop -> HASH .)
    false           reduce using rule 121 (unop -> HASH .)
    true            reduce using rule 121 (unop -> HASH .)
    STRING          reduce using rule 121 (unop -> HASH .)
    TRPLDOTS        reduce using rule 121 (unop -> HASH .)
    function        reduce using rule 121 (unop -> HASH .)
    INTEGER         reduce using rule 121 (unop -> HASH .)
    FLOAT           reduce using rule 121 (unop -> HASH .)
    HEX             reduce using rule 121 (unop -> HASH .)
    LPAREN          reduce using rule 121 (unop -> HASH .)
    LCURLY          reduce using rule 121 (unop -> HASH .)
    MINUS           reduce using rule 121 (unop -> HASH .)
    not             reduce using rule 121 (unop -> HASH .)
    HASH            reduce using rule 121 (unop -> HASH .)
    ID              reduce using rule 121 (unop -> HASH .)
    RESID           reduce using rule 121 (unop -> HASH .)


state 26

    (119) unop -> MINUS .

    nil             reduce using rule 119 (unop -> MINUS .)
    false           reduce using rule 119 (unop -> MINUS .)
    true            reduce using rule 119 (unop -> MINUS .)
    STRING          reduce using rule 119 (unop -> MINUS .)
    TRPLDOTS        reduce using rule 119 (unop -> MINUS .)
    function        reduce using rule 119 (unop -> MINUS .)
    INTEGER         reduce using rule 119 (unop -> MINUS .)
    FLOAT           reduce using rule 119 (unop -> MINUS .)
    HEX             reduce using rule 119 (unop -> MINUS .)
    LPAREN          reduce using rule 119 (unop -> MINUS .)
    LCURLY          reduce using rule 119 (unop -> MINUS .)
    MINUS           reduce using rule 119 (unop -> MINUS .)
    not             reduce using rule 119 (unop -> MINUS .)
    HASH            reduce using rule 119 (unop -> MINUS .)
    ID              reduce using rule 119 (unop -> MINUS .)
    RESID           reduce using rule 119 (unop -> MINUS .)


state 27

    (65) exp -> STRING .

    PLUS            reduce using rule 65 (exp -> STRING .)
    MINUS           reduce using rule 65 (exp -> STRING .)
    TIMES           reduce using rule 65 (exp -> STRING .)
    DIVIDE          reduce using rule 65 (exp -> STRING .)
    POWER           reduce using rule 65 (exp -> STRING .)
    LT              reduce using rule 65 (exp -> STRING .)
    LE              reduce using rule 65 (exp -> STRING .)
    GT              reduce using rule 65 (exp -> STRING .)
    GE              reduce using rule 65 (exp -> STRING .)
    NE              reduce using rule 65 (exp -> STRING .)
    CHECKEQ         reduce using rule 65 (exp -> STRING .)
    and             reduce using rule 65 (exp -> STRING .)
    or              reduce using rule 65 (exp -> STRING .)
    MODULO          reduce using rule 65 (exp -> STRING .)
    DBLDOTS         reduce using rule 65 (exp -> STRING .)
    RPAREN          reduce using rule 65 (exp -> STRING .)
    then            reduce using rule 65 (exp -> STRING .)
    do              reduce using rule 65 (exp -> STRING .)
    COMMA           reduce using rule 65 (exp -> STRING .)
    SEMI            reduce using rule 65 (exp -> STRING .)
    RCURLY          reduce using rule 65 (exp -> STRING .)
    RSQUARE         reduce using rule 65 (exp -> STRING .)
    return          reduce using rule 65 (exp -> STRING .)
    break           reduce using rule 65 (exp -> STRING .)
    for             reduce using rule 65 (exp -> STRING .)
    while           reduce using rule 65 (exp -> STRING .)
    repeat          reduce using rule 65 (exp -> STRING .)
    function        reduce using rule 65 (exp -> STRING .)
    local           reduce using rule 65 (exp -> STRING .)
    if              reduce using rule 65 (exp -> STRING .)
    LPAREN          reduce using rule 65 (exp -> STRING .)
    ID              reduce using rule 65 (exp -> STRING .)
    RESID           reduce using rule 65 (exp -> STRING .)
    $end            reduce using rule 65 (exp -> STRING .)
    end             reduce using rule 65 (exp -> STRING .)
    until           reduce using rule 65 (exp -> STRING .)
    else            reduce using rule 65 (exp -> STRING .)
    elseif          reduce using rule 65 (exp -> STRING .)


state 28

    (68) exp -> prefixexp .
    (56) var -> prefixexp . LSQUARE exp RSQUARE
    (57) var -> prefixexp . SDOT names
    (24) functioncall -> prefixexp . args
    (25) args -> . LPAREN RPAREN
    (26) args -> . LPAREN explist RPAREN
    (27) args -> . tableconstructor
    (28) args -> . STRING
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY

  ! shift/reduce conflict for LPAREN resolved as shift
    PLUS            reduce using rule 68 (exp -> prefixexp .)
    MINUS           reduce using rule 68 (exp -> prefixexp .)
    TIMES           reduce using rule 68 (exp -> prefixexp .)
    DIVIDE          reduce using rule 68 (exp -> prefixexp .)
    POWER           reduce using rule 68 (exp -> prefixexp .)
    LT              reduce using rule 68 (exp -> prefixexp .)
    LE              reduce using rule 68 (exp -> prefixexp .)
    GT              reduce using rule 68 (exp -> prefixexp .)
    GE              reduce using rule 68 (exp -> prefixexp .)
    NE              reduce using rule 68 (exp -> prefixexp .)
    CHECKEQ         reduce using rule 68 (exp -> prefixexp .)
    and             reduce using rule 68 (exp -> prefixexp .)
    or              reduce using rule 68 (exp -> prefixexp .)
    MODULO          reduce using rule 68 (exp -> prefixexp .)
    DBLDOTS         reduce using rule 68 (exp -> prefixexp .)
    RPAREN          reduce using rule 68 (exp -> prefixexp .)
    then            reduce using rule 68 (exp -> prefixexp .)
    do              reduce using rule 68 (exp -> prefixexp .)
    COMMA           reduce using rule 68 (exp -> prefixexp .)
    SEMI            reduce using rule 68 (exp -> prefixexp .)
    RCURLY          reduce using rule 68 (exp -> prefixexp .)
    RSQUARE         reduce using rule 68 (exp -> prefixexp .)
    return          reduce using rule 68 (exp -> prefixexp .)
    break           reduce using rule 68 (exp -> prefixexp .)
    for             reduce using rule 68 (exp -> prefixexp .)
    while           reduce using rule 68 (exp -> prefixexp .)
    repeat          reduce using rule 68 (exp -> prefixexp .)
    function        reduce using rule 68 (exp -> prefixexp .)
    local           reduce using rule 68 (exp -> prefixexp .)
    if              reduce using rule 68 (exp -> prefixexp .)
    ID              reduce using rule 68 (exp -> prefixexp .)
    RESID           reduce using rule 68 (exp -> prefixexp .)
    $end            reduce using rule 68 (exp -> prefixexp .)
    end             reduce using rule 68 (exp -> prefixexp .)
    until           reduce using rule 68 (exp -> prefixexp .)
    else            reduce using rule 68 (exp -> prefixexp .)
    elseif          reduce using rule 68 (exp -> prefixexp .)
    LSQUARE         shift and go to state 46
    SDOT            shift and go to state 49
    LPAREN          shift and go to state 48
    STRING          shift and go to state 50
    LCURLY          shift and go to state 24

  ! LPAREN          [ reduce using rule 68 (exp -> prefixexp .) ]

    tableconstructor               shift and go to state 45
    args                           shift and go to state 47

state 29

    (116) prefixexp -> var .

    LSQUARE         reduce using rule 116 (prefixexp -> var .)
    SDOT            reduce using rule 116 (prefixexp -> var .)
    LPAREN          reduce using rule 116 (prefixexp -> var .)
    STRING          reduce using rule 116 (prefixexp -> var .)
    LCURLY          reduce using rule 116 (prefixexp -> var .)
    PLUS            reduce using rule 116 (prefixexp -> var .)
    MINUS           reduce using rule 116 (prefixexp -> var .)
    TIMES           reduce using rule 116 (prefixexp -> var .)
    DIVIDE          reduce using rule 116 (prefixexp -> var .)
    POWER           reduce using rule 116 (prefixexp -> var .)
    LT              reduce using rule 116 (prefixexp -> var .)
    LE              reduce using rule 116 (prefixexp -> var .)
    GT              reduce using rule 116 (prefixexp -> var .)
    GE              reduce using rule 116 (prefixexp -> var .)
    NE              reduce using rule 116 (prefixexp -> var .)
    CHECKEQ         reduce using rule 116 (prefixexp -> var .)
    and             reduce using rule 116 (prefixexp -> var .)
    or              reduce using rule 116 (prefixexp -> var .)
    MODULO          reduce using rule 116 (prefixexp -> var .)
    DBLDOTS         reduce using rule 116 (prefixexp -> var .)
    RPAREN          reduce using rule 116 (prefixexp -> var .)
    COMMA           reduce using rule 116 (prefixexp -> var .)
    $end            reduce using rule 116 (prefixexp -> var .)
    SEMI            reduce using rule 116 (prefixexp -> var .)
    end             reduce using rule 116 (prefixexp -> var .)
    until           reduce using rule 116 (prefixexp -> var .)
    else            reduce using rule 116 (prefixexp -> var .)
    elseif          reduce using rule 116 (prefixexp -> var .)
    then            reduce using rule 116 (prefixexp -> var .)
    do              reduce using rule 116 (prefixexp -> var .)
    RCURLY          reduce using rule 116 (prefixexp -> var .)
    RSQUARE         reduce using rule 116 (prefixexp -> var .)
    return          reduce using rule 116 (prefixexp -> var .)
    break           reduce using rule 116 (prefixexp -> var .)
    for             reduce using rule 116 (prefixexp -> var .)
    while           reduce using rule 116 (prefixexp -> var .)
    repeat          reduce using rule 116 (prefixexp -> var .)
    function        reduce using rule 116 (prefixexp -> var .)
    local           reduce using rule 116 (prefixexp -> var .)
    if              reduce using rule 116 (prefixexp -> var .)
    ID              reduce using rule 116 (prefixexp -> var .)
    RESID           reduce using rule 116 (prefixexp -> var .)


state 30

    (112) Number -> INTEGER .

    PLUS            reduce using rule 112 (Number -> INTEGER .)
    MINUS           reduce using rule 112 (Number -> INTEGER .)
    TIMES           reduce using rule 112 (Number -> INTEGER .)
    DIVIDE          reduce using rule 112 (Number -> INTEGER .)
    POWER           reduce using rule 112 (Number -> INTEGER .)
    LT              reduce using rule 112 (Number -> INTEGER .)
    LE              reduce using rule 112 (Number -> INTEGER .)
    GT              reduce using rule 112 (Number -> INTEGER .)
    GE              reduce using rule 112 (Number -> INTEGER .)
    NE              reduce using rule 112 (Number -> INTEGER .)
    CHECKEQ         reduce using rule 112 (Number -> INTEGER .)
    and             reduce using rule 112 (Number -> INTEGER .)
    or              reduce using rule 112 (Number -> INTEGER .)
    MODULO          reduce using rule 112 (Number -> INTEGER .)
    DBLDOTS         reduce using rule 112 (Number -> INTEGER .)
    COMMA           reduce using rule 112 (Number -> INTEGER .)
    $end            reduce using rule 112 (Number -> INTEGER .)
    SEMI            reduce using rule 112 (Number -> INTEGER .)
    end             reduce using rule 112 (Number -> INTEGER .)
    until           reduce using rule 112 (Number -> INTEGER .)
    else            reduce using rule 112 (Number -> INTEGER .)
    elseif          reduce using rule 112 (Number -> INTEGER .)
    RPAREN          reduce using rule 112 (Number -> INTEGER .)
    then            reduce using rule 112 (Number -> INTEGER .)
    do              reduce using rule 112 (Number -> INTEGER .)
    RCURLY          reduce using rule 112 (Number -> INTEGER .)
    RSQUARE         reduce using rule 112 (Number -> INTEGER .)
    return          reduce using rule 112 (Number -> INTEGER .)
    break           reduce using rule 112 (Number -> INTEGER .)
    for             reduce using rule 112 (Number -> INTEGER .)
    while           reduce using rule 112 (Number -> INTEGER .)
    repeat          reduce using rule 112 (Number -> INTEGER .)
    function        reduce using rule 112 (Number -> INTEGER .)
    local           reduce using rule 112 (Number -> INTEGER .)
    if              reduce using rule 112 (Number -> INTEGER .)
    LPAREN          reduce using rule 112 (Number -> INTEGER .)
    ID              reduce using rule 112 (Number -> INTEGER .)
    RESID           reduce using rule 112 (Number -> INTEGER .)


state 31

    (67) exp -> function .

    PLUS            reduce using rule 67 (exp -> function .)
    MINUS           reduce using rule 67 (exp -> function .)
    TIMES           reduce using rule 67 (exp -> function .)
    DIVIDE          reduce using rule 67 (exp -> function .)
    POWER           reduce using rule 67 (exp -> function .)
    LT              reduce using rule 67 (exp -> function .)
    LE              reduce using rule 67 (exp -> function .)
    GT              reduce using rule 67 (exp -> function .)
    GE              reduce using rule 67 (exp -> function .)
    NE              reduce using rule 67 (exp -> function .)
    CHECKEQ         reduce using rule 67 (exp -> function .)
    and             reduce using rule 67 (exp -> function .)
    or              reduce using rule 67 (exp -> function .)
    MODULO          reduce using rule 67 (exp -> function .)
    DBLDOTS         reduce using rule 67 (exp -> function .)
    RPAREN          reduce using rule 67 (exp -> function .)
    then            reduce using rule 67 (exp -> function .)
    do              reduce using rule 67 (exp -> function .)
    COMMA           reduce using rule 67 (exp -> function .)
    SEMI            reduce using rule 67 (exp -> function .)
    RCURLY          reduce using rule 67 (exp -> function .)
    RSQUARE         reduce using rule 67 (exp -> function .)
    return          reduce using rule 67 (exp -> function .)
    break           reduce using rule 67 (exp -> function .)
    for             reduce using rule 67 (exp -> function .)
    while           reduce using rule 67 (exp -> function .)
    repeat          reduce using rule 67 (exp -> function .)
    function        reduce using rule 67 (exp -> function .)
    local           reduce using rule 67 (exp -> function .)
    if              reduce using rule 67 (exp -> function .)
    LPAREN          reduce using rule 67 (exp -> function .)
    ID              reduce using rule 67 (exp -> function .)
    RESID           reduce using rule 67 (exp -> function .)
    $end            reduce using rule 67 (exp -> function .)
    end             reduce using rule 67 (exp -> function .)
    until           reduce using rule 67 (exp -> function .)
    else            reduce using rule 67 (exp -> function .)
    elseif          reduce using rule 67 (exp -> function .)


state 32

    (61) exp -> nil .

    PLUS            reduce using rule 61 (exp -> nil .)
    MINUS           reduce using rule 61 (exp -> nil .)
    TIMES           reduce using rule 61 (exp -> nil .)
    DIVIDE          reduce using rule 61 (exp -> nil .)
    POWER           reduce using rule 61 (exp -> nil .)
    LT              reduce using rule 61 (exp -> nil .)
    LE              reduce using rule 61 (exp -> nil .)
    GT              reduce using rule 61 (exp -> nil .)
    GE              reduce using rule 61 (exp -> nil .)
    NE              reduce using rule 61 (exp -> nil .)
    CHECKEQ         reduce using rule 61 (exp -> nil .)
    and             reduce using rule 61 (exp -> nil .)
    or              reduce using rule 61 (exp -> nil .)
    MODULO          reduce using rule 61 (exp -> nil .)
    DBLDOTS         reduce using rule 61 (exp -> nil .)
    RPAREN          reduce using rule 61 (exp -> nil .)
    then            reduce using rule 61 (exp -> nil .)
    do              reduce using rule 61 (exp -> nil .)
    COMMA           reduce using rule 61 (exp -> nil .)
    SEMI            reduce using rule 61 (exp -> nil .)
    RCURLY          reduce using rule 61 (exp -> nil .)
    RSQUARE         reduce using rule 61 (exp -> nil .)
    return          reduce using rule 61 (exp -> nil .)
    break           reduce using rule 61 (exp -> nil .)
    for             reduce using rule 61 (exp -> nil .)
    while           reduce using rule 61 (exp -> nil .)
    repeat          reduce using rule 61 (exp -> nil .)
    function        reduce using rule 61 (exp -> nil .)
    local           reduce using rule 61 (exp -> nil .)
    if              reduce using rule 61 (exp -> nil .)
    LPAREN          reduce using rule 61 (exp -> nil .)
    ID              reduce using rule 61 (exp -> nil .)
    RESID           reduce using rule 61 (exp -> nil .)
    $end            reduce using rule 61 (exp -> nil .)
    end             reduce using rule 61 (exp -> nil .)
    until           reduce using rule 61 (exp -> nil .)
    else            reduce using rule 61 (exp -> nil .)
    elseif          reduce using rule 61 (exp -> nil .)


state 33

    (114) Number -> HEX .

    PLUS            reduce using rule 114 (Number -> HEX .)
    MINUS           reduce using rule 114 (Number -> HEX .)
    TIMES           reduce using rule 114 (Number -> HEX .)
    DIVIDE          reduce using rule 114 (Number -> HEX .)
    POWER           reduce using rule 114 (Number -> HEX .)
    LT              reduce using rule 114 (Number -> HEX .)
    LE              reduce using rule 114 (Number -> HEX .)
    GT              reduce using rule 114 (Number -> HEX .)
    GE              reduce using rule 114 (Number -> HEX .)
    NE              reduce using rule 114 (Number -> HEX .)
    CHECKEQ         reduce using rule 114 (Number -> HEX .)
    and             reduce using rule 114 (Number -> HEX .)
    or              reduce using rule 114 (Number -> HEX .)
    MODULO          reduce using rule 114 (Number -> HEX .)
    DBLDOTS         reduce using rule 114 (Number -> HEX .)
    COMMA           reduce using rule 114 (Number -> HEX .)
    $end            reduce using rule 114 (Number -> HEX .)
    SEMI            reduce using rule 114 (Number -> HEX .)
    end             reduce using rule 114 (Number -> HEX .)
    until           reduce using rule 114 (Number -> HEX .)
    else            reduce using rule 114 (Number -> HEX .)
    elseif          reduce using rule 114 (Number -> HEX .)
    RPAREN          reduce using rule 114 (Number -> HEX .)
    then            reduce using rule 114 (Number -> HEX .)
    do              reduce using rule 114 (Number -> HEX .)
    RCURLY          reduce using rule 114 (Number -> HEX .)
    RSQUARE         reduce using rule 114 (Number -> HEX .)
    return          reduce using rule 114 (Number -> HEX .)
    break           reduce using rule 114 (Number -> HEX .)
    for             reduce using rule 114 (Number -> HEX .)
    while           reduce using rule 114 (Number -> HEX .)
    repeat          reduce using rule 114 (Number -> HEX .)
    function        reduce using rule 114 (Number -> HEX .)
    local           reduce using rule 114 (Number -> HEX .)
    if              reduce using rule 114 (Number -> HEX .)
    LPAREN          reduce using rule 114 (Number -> HEX .)
    ID              reduce using rule 114 (Number -> HEX .)
    RESID           reduce using rule 114 (Number -> HEX .)


state 34

    (120) unop -> not .

    nil             reduce using rule 120 (unop -> not .)
    false           reduce using rule 120 (unop -> not .)
    true            reduce using rule 120 (unop -> not .)
    STRING          reduce using rule 120 (unop -> not .)
    TRPLDOTS        reduce using rule 120 (unop -> not .)
    function        reduce using rule 120 (unop -> not .)
    INTEGER         reduce using rule 120 (unop -> not .)
    FLOAT           reduce using rule 120 (unop -> not .)
    HEX             reduce using rule 120 (unop -> not .)
    LPAREN          reduce using rule 120 (unop -> not .)
    LCURLY          reduce using rule 120 (unop -> not .)
    MINUS           reduce using rule 120 (unop -> not .)
    not             reduce using rule 120 (unop -> not .)
    HASH            reduce using rule 120 (unop -> not .)
    ID              reduce using rule 120 (unop -> not .)
    RESID           reduce using rule 120 (unop -> not .)


state 35

    (63) exp -> true .

    PLUS            reduce using rule 63 (exp -> true .)
    MINUS           reduce using rule 63 (exp -> true .)
    TIMES           reduce using rule 63 (exp -> true .)
    DIVIDE          reduce using rule 63 (exp -> true .)
    POWER           reduce using rule 63 (exp -> true .)
    LT              reduce using rule 63 (exp -> true .)
    LE              reduce using rule 63 (exp -> true .)
    GT              reduce using rule 63 (exp -> true .)
    GE              reduce using rule 63 (exp -> true .)
    NE              reduce using rule 63 (exp -> true .)
    CHECKEQ         reduce using rule 63 (exp -> true .)
    and             reduce using rule 63 (exp -> true .)
    or              reduce using rule 63 (exp -> true .)
    MODULO          reduce using rule 63 (exp -> true .)
    DBLDOTS         reduce using rule 63 (exp -> true .)
    RPAREN          reduce using rule 63 (exp -> true .)
    then            reduce using rule 63 (exp -> true .)
    do              reduce using rule 63 (exp -> true .)
    COMMA           reduce using rule 63 (exp -> true .)
    SEMI            reduce using rule 63 (exp -> true .)
    RCURLY          reduce using rule 63 (exp -> true .)
    RSQUARE         reduce using rule 63 (exp -> true .)
    return          reduce using rule 63 (exp -> true .)
    break           reduce using rule 63 (exp -> true .)
    for             reduce using rule 63 (exp -> true .)
    while           reduce using rule 63 (exp -> true .)
    repeat          reduce using rule 63 (exp -> true .)
    function        reduce using rule 63 (exp -> true .)
    local           reduce using rule 63 (exp -> true .)
    if              reduce using rule 63 (exp -> true .)
    LPAREN          reduce using rule 63 (exp -> true .)
    ID              reduce using rule 63 (exp -> true .)
    RESID           reduce using rule 63 (exp -> true .)
    $end            reduce using rule 63 (exp -> true .)
    end             reduce using rule 63 (exp -> true .)
    until           reduce using rule 63 (exp -> true .)
    else            reduce using rule 63 (exp -> true .)
    elseif          reduce using rule 63 (exp -> true .)


state 36

    (113) Number -> FLOAT .

    PLUS            reduce using rule 113 (Number -> FLOAT .)
    MINUS           reduce using rule 113 (Number -> FLOAT .)
    TIMES           reduce using rule 113 (Number -> FLOAT .)
    DIVIDE          reduce using rule 113 (Number -> FLOAT .)
    POWER           reduce using rule 113 (Number -> FLOAT .)
    LT              reduce using rule 113 (Number -> FLOAT .)
    LE              reduce using rule 113 (Number -> FLOAT .)
    GT              reduce using rule 113 (Number -> FLOAT .)
    GE              reduce using rule 113 (Number -> FLOAT .)
    NE              reduce using rule 113 (Number -> FLOAT .)
    CHECKEQ         reduce using rule 113 (Number -> FLOAT .)
    and             reduce using rule 113 (Number -> FLOAT .)
    or              reduce using rule 113 (Number -> FLOAT .)
    MODULO          reduce using rule 113 (Number -> FLOAT .)
    DBLDOTS         reduce using rule 113 (Number -> FLOAT .)
    COMMA           reduce using rule 113 (Number -> FLOAT .)
    $end            reduce using rule 113 (Number -> FLOAT .)
    SEMI            reduce using rule 113 (Number -> FLOAT .)
    end             reduce using rule 113 (Number -> FLOAT .)
    until           reduce using rule 113 (Number -> FLOAT .)
    else            reduce using rule 113 (Number -> FLOAT .)
    elseif          reduce using rule 113 (Number -> FLOAT .)
    RPAREN          reduce using rule 113 (Number -> FLOAT .)
    then            reduce using rule 113 (Number -> FLOAT .)
    do              reduce using rule 113 (Number -> FLOAT .)
    RCURLY          reduce using rule 113 (Number -> FLOAT .)
    RSQUARE         reduce using rule 113 (Number -> FLOAT .)
    return          reduce using rule 113 (Number -> FLOAT .)
    break           reduce using rule 113 (Number -> FLOAT .)
    for             reduce using rule 113 (Number -> FLOAT .)
    while           reduce using rule 113 (Number -> FLOAT .)
    repeat          reduce using rule 113 (Number -> FLOAT .)
    function        reduce using rule 113 (Number -> FLOAT .)
    local           reduce using rule 113 (Number -> FLOAT .)
    if              reduce using rule 113 (Number -> FLOAT .)
    LPAREN          reduce using rule 113 (Number -> FLOAT .)
    ID              reduce using rule 113 (Number -> FLOAT .)
    RESID           reduce using rule 113 (Number -> FLOAT .)


state 37

    (64) exp -> Number .

    PLUS            reduce using rule 64 (exp -> Number .)
    MINUS           reduce using rule 64 (exp -> Number .)
    TIMES           reduce using rule 64 (exp -> Number .)
    DIVIDE          reduce using rule 64 (exp -> Number .)
    POWER           reduce using rule 64 (exp -> Number .)
    LT              reduce using rule 64 (exp -> Number .)
    LE              reduce using rule 64 (exp -> Number .)
    GT              reduce using rule 64 (exp -> Number .)
    GE              reduce using rule 64 (exp -> Number .)
    NE              reduce using rule 64 (exp -> Number .)
    CHECKEQ         reduce using rule 64 (exp -> Number .)
    and             reduce using rule 64 (exp -> Number .)
    or              reduce using rule 64 (exp -> Number .)
    MODULO          reduce using rule 64 (exp -> Number .)
    DBLDOTS         reduce using rule 64 (exp -> Number .)
    RPAREN          reduce using rule 64 (exp -> Number .)
    then            reduce using rule 64 (exp -> Number .)
    do              reduce using rule 64 (exp -> Number .)
    COMMA           reduce using rule 64 (exp -> Number .)
    SEMI            reduce using rule 64 (exp -> Number .)
    RCURLY          reduce using rule 64 (exp -> Number .)
    RSQUARE         reduce using rule 64 (exp -> Number .)
    return          reduce using rule 64 (exp -> Number .)
    break           reduce using rule 64 (exp -> Number .)
    for             reduce using rule 64 (exp -> Number .)
    while           reduce using rule 64 (exp -> Number .)
    repeat          reduce using rule 64 (exp -> Number .)
    function        reduce using rule 64 (exp -> Number .)
    local           reduce using rule 64 (exp -> Number .)
    if              reduce using rule 64 (exp -> Number .)
    LPAREN          reduce using rule 64 (exp -> Number .)
    ID              reduce using rule 64 (exp -> Number .)
    RESID           reduce using rule 64 (exp -> Number .)
    $end            reduce using rule 64 (exp -> Number .)
    end             reduce using rule 64 (exp -> Number .)
    until           reduce using rule 64 (exp -> Number .)
    else            reduce using rule 64 (exp -> Number .)
    elseif          reduce using rule 64 (exp -> Number .)


state 38

    (118) prefixexp -> functioncall .

    LSQUARE         reduce using rule 118 (prefixexp -> functioncall .)
    SDOT            reduce using rule 118 (prefixexp -> functioncall .)
    LPAREN          reduce using rule 118 (prefixexp -> functioncall .)
    STRING          reduce using rule 118 (prefixexp -> functioncall .)
    LCURLY          reduce using rule 118 (prefixexp -> functioncall .)
    PLUS            reduce using rule 118 (prefixexp -> functioncall .)
    MINUS           reduce using rule 118 (prefixexp -> functioncall .)
    TIMES           reduce using rule 118 (prefixexp -> functioncall .)
    DIVIDE          reduce using rule 118 (prefixexp -> functioncall .)
    POWER           reduce using rule 118 (prefixexp -> functioncall .)
    LT              reduce using rule 118 (prefixexp -> functioncall .)
    LE              reduce using rule 118 (prefixexp -> functioncall .)
    GT              reduce using rule 118 (prefixexp -> functioncall .)
    GE              reduce using rule 118 (prefixexp -> functioncall .)
    NE              reduce using rule 118 (prefixexp -> functioncall .)
    CHECKEQ         reduce using rule 118 (prefixexp -> functioncall .)
    and             reduce using rule 118 (prefixexp -> functioncall .)
    or              reduce using rule 118 (prefixexp -> functioncall .)
    MODULO          reduce using rule 118 (prefixexp -> functioncall .)
    DBLDOTS         reduce using rule 118 (prefixexp -> functioncall .)
    RPAREN          reduce using rule 118 (prefixexp -> functioncall .)
    COMMA           reduce using rule 118 (prefixexp -> functioncall .)
    $end            reduce using rule 118 (prefixexp -> functioncall .)
    SEMI            reduce using rule 118 (prefixexp -> functioncall .)
    end             reduce using rule 118 (prefixexp -> functioncall .)
    until           reduce using rule 118 (prefixexp -> functioncall .)
    else            reduce using rule 118 (prefixexp -> functioncall .)
    elseif          reduce using rule 118 (prefixexp -> functioncall .)
    then            reduce using rule 118 (prefixexp -> functioncall .)
    do              reduce using rule 118 (prefixexp -> functioncall .)
    RCURLY          reduce using rule 118 (prefixexp -> functioncall .)
    RSQUARE         reduce using rule 118 (prefixexp -> functioncall .)
    return          reduce using rule 118 (prefixexp -> functioncall .)
    break           reduce using rule 118 (prefixexp -> functioncall .)
    for             reduce using rule 118 (prefixexp -> functioncall .)
    while           reduce using rule 118 (prefixexp -> functioncall .)
    repeat          reduce using rule 118 (prefixexp -> functioncall .)
    function        reduce using rule 118 (prefixexp -> functioncall .)
    local           reduce using rule 118 (prefixexp -> functioncall .)
    if              reduce using rule 118 (prefixexp -> functioncall .)
    ID              reduce using rule 118 (prefixexp -> functioncall .)
    RESID           reduce using rule 118 (prefixexp -> functioncall .)


state 39

    (117) prefixexp -> LPAREN exp . RPAREN
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    RPAREN          shift and go to state 87
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 40

    (85) exp -> unop . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    unop                           shift and go to state 40
    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    functioncall                   shift and go to state 38
    exp                            shift and go to state 101
    var                            shift and go to state 29
    names                          shift and go to state 4

state 41

    (66) exp -> TRPLDOTS .

    PLUS            reduce using rule 66 (exp -> TRPLDOTS .)
    MINUS           reduce using rule 66 (exp -> TRPLDOTS .)
    TIMES           reduce using rule 66 (exp -> TRPLDOTS .)
    DIVIDE          reduce using rule 66 (exp -> TRPLDOTS .)
    POWER           reduce using rule 66 (exp -> TRPLDOTS .)
    LT              reduce using rule 66 (exp -> TRPLDOTS .)
    LE              reduce using rule 66 (exp -> TRPLDOTS .)
    GT              reduce using rule 66 (exp -> TRPLDOTS .)
    GE              reduce using rule 66 (exp -> TRPLDOTS .)
    NE              reduce using rule 66 (exp -> TRPLDOTS .)
    CHECKEQ         reduce using rule 66 (exp -> TRPLDOTS .)
    and             reduce using rule 66 (exp -> TRPLDOTS .)
    or              reduce using rule 66 (exp -> TRPLDOTS .)
    MODULO          reduce using rule 66 (exp -> TRPLDOTS .)
    DBLDOTS         reduce using rule 66 (exp -> TRPLDOTS .)
    RPAREN          reduce using rule 66 (exp -> TRPLDOTS .)
    then            reduce using rule 66 (exp -> TRPLDOTS .)
    do              reduce using rule 66 (exp -> TRPLDOTS .)
    COMMA           reduce using rule 66 (exp -> TRPLDOTS .)
    SEMI            reduce using rule 66 (exp -> TRPLDOTS .)
    RCURLY          reduce using rule 66 (exp -> TRPLDOTS .)
    RSQUARE         reduce using rule 66 (exp -> TRPLDOTS .)
    return          reduce using rule 66 (exp -> TRPLDOTS .)
    break           reduce using rule 66 (exp -> TRPLDOTS .)
    for             reduce using rule 66 (exp -> TRPLDOTS .)
    while           reduce using rule 66 (exp -> TRPLDOTS .)
    repeat          reduce using rule 66 (exp -> TRPLDOTS .)
    function        reduce using rule 66 (exp -> TRPLDOTS .)
    local           reduce using rule 66 (exp -> TRPLDOTS .)
    if              reduce using rule 66 (exp -> TRPLDOTS .)
    LPAREN          reduce using rule 66 (exp -> TRPLDOTS .)
    ID              reduce using rule 66 (exp -> TRPLDOTS .)
    RESID           reduce using rule 66 (exp -> TRPLDOTS .)
    $end            reduce using rule 66 (exp -> TRPLDOTS .)
    end             reduce using rule 66 (exp -> TRPLDOTS .)
    until           reduce using rule 66 (exp -> TRPLDOTS .)
    else            reduce using rule 66 (exp -> TRPLDOTS .)
    elseif          reduce using rule 66 (exp -> TRPLDOTS .)


state 42

    (2) sdash -> chunk laststat .
    (4) sdash -> chunk laststat . SEMI

    end             reduce using rule 2 (sdash -> chunk laststat .)
    else            reduce using rule 2 (sdash -> chunk laststat .)
    elseif          reduce using rule 2 (sdash -> chunk laststat .)
    $end            reduce using rule 2 (sdash -> chunk laststat .)
    until           reduce using rule 2 (sdash -> chunk laststat .)
    SEMI            shift and go to state 102


state 43

    (5) chunk -> chunk stat .
    (6) chunk -> chunk stat . SEMI

    return          reduce using rule 5 (chunk -> chunk stat .)
    break           reduce using rule 5 (chunk -> chunk stat .)
    for             reduce using rule 5 (chunk -> chunk stat .)
    while           reduce using rule 5 (chunk -> chunk stat .)
    repeat          reduce using rule 5 (chunk -> chunk stat .)
    do              reduce using rule 5 (chunk -> chunk stat .)
    function        reduce using rule 5 (chunk -> chunk stat .)
    local           reduce using rule 5 (chunk -> chunk stat .)
    if              reduce using rule 5 (chunk -> chunk stat .)
    LPAREN          reduce using rule 5 (chunk -> chunk stat .)
    ID              reduce using rule 5 (chunk -> chunk stat .)
    RESID           reduce using rule 5 (chunk -> chunk stat .)
    end             reduce using rule 5 (chunk -> chunk stat .)
    else            reduce using rule 5 (chunk -> chunk stat .)
    elseif          reduce using rule 5 (chunk -> chunk stat .)
    until           reduce using rule 5 (chunk -> chunk stat .)
    $end            reduce using rule 5 (chunk -> chunk stat .)
    SEMI            shift and go to state 103


state 44

    (44) stat -> if exp . then M_if1 block ifblock end
    (46) stat -> if exp . then M_if1 block ifblock M_if3 else M_if4 block end
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    then            shift and go to state 104
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 45

    (27) args -> tableconstructor .

    SEMI            reduce using rule 27 (args -> tableconstructor .)
    return          reduce using rule 27 (args -> tableconstructor .)
    break           reduce using rule 27 (args -> tableconstructor .)
    for             reduce using rule 27 (args -> tableconstructor .)
    while           reduce using rule 27 (args -> tableconstructor .)
    repeat          reduce using rule 27 (args -> tableconstructor .)
    do              reduce using rule 27 (args -> tableconstructor .)
    function        reduce using rule 27 (args -> tableconstructor .)
    local           reduce using rule 27 (args -> tableconstructor .)
    if              reduce using rule 27 (args -> tableconstructor .)
    LPAREN          reduce using rule 27 (args -> tableconstructor .)
    ID              reduce using rule 27 (args -> tableconstructor .)
    RESID           reduce using rule 27 (args -> tableconstructor .)
    $end            reduce using rule 27 (args -> tableconstructor .)
    LSQUARE         reduce using rule 27 (args -> tableconstructor .)
    SDOT            reduce using rule 27 (args -> tableconstructor .)
    STRING          reduce using rule 27 (args -> tableconstructor .)
    LCURLY          reduce using rule 27 (args -> tableconstructor .)
    end             reduce using rule 27 (args -> tableconstructor .)
    until           reduce using rule 27 (args -> tableconstructor .)
    else            reduce using rule 27 (args -> tableconstructor .)
    elseif          reduce using rule 27 (args -> tableconstructor .)
    COMMA           reduce using rule 27 (args -> tableconstructor .)
    PLUS            reduce using rule 27 (args -> tableconstructor .)
    MINUS           reduce using rule 27 (args -> tableconstructor .)
    TIMES           reduce using rule 27 (args -> tableconstructor .)
    DIVIDE          reduce using rule 27 (args -> tableconstructor .)
    POWER           reduce using rule 27 (args -> tableconstructor .)
    LT              reduce using rule 27 (args -> tableconstructor .)
    LE              reduce using rule 27 (args -> tableconstructor .)
    GT              reduce using rule 27 (args -> tableconstructor .)
    GE              reduce using rule 27 (args -> tableconstructor .)
    NE              reduce using rule 27 (args -> tableconstructor .)
    CHECKEQ         reduce using rule 27 (args -> tableconstructor .)
    and             reduce using rule 27 (args -> tableconstructor .)
    or              reduce using rule 27 (args -> tableconstructor .)
    MODULO          reduce using rule 27 (args -> tableconstructor .)
    DBLDOTS         reduce using rule 27 (args -> tableconstructor .)
    RPAREN          reduce using rule 27 (args -> tableconstructor .)
    then            reduce using rule 27 (args -> tableconstructor .)
    RCURLY          reduce using rule 27 (args -> tableconstructor .)
    RSQUARE         reduce using rule 27 (args -> tableconstructor .)


state 46

    (56) var -> prefixexp LSQUARE . exp RSQUARE
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 105
    var                            shift and go to state 29
    names                          shift and go to state 4

state 47

    (24) functioncall -> prefixexp args .

    LSQUARE         reduce using rule 24 (functioncall -> prefixexp args .)
    SDOT            reduce using rule 24 (functioncall -> prefixexp args .)
    LPAREN          reduce using rule 24 (functioncall -> prefixexp args .)
    STRING          reduce using rule 24 (functioncall -> prefixexp args .)
    LCURLY          reduce using rule 24 (functioncall -> prefixexp args .)
    COMMA           reduce using rule 24 (functioncall -> prefixexp args .)
    $end            reduce using rule 24 (functioncall -> prefixexp args .)
    SEMI            reduce using rule 24 (functioncall -> prefixexp args .)
    end             reduce using rule 24 (functioncall -> prefixexp args .)
    until           reduce using rule 24 (functioncall -> prefixexp args .)
    else            reduce using rule 24 (functioncall -> prefixexp args .)
    elseif          reduce using rule 24 (functioncall -> prefixexp args .)
    PLUS            reduce using rule 24 (functioncall -> prefixexp args .)
    MINUS           reduce using rule 24 (functioncall -> prefixexp args .)
    TIMES           reduce using rule 24 (functioncall -> prefixexp args .)
    DIVIDE          reduce using rule 24 (functioncall -> prefixexp args .)
    POWER           reduce using rule 24 (functioncall -> prefixexp args .)
    LT              reduce using rule 24 (functioncall -> prefixexp args .)
    LE              reduce using rule 24 (functioncall -> prefixexp args .)
    GT              reduce using rule 24 (functioncall -> prefixexp args .)
    GE              reduce using rule 24 (functioncall -> prefixexp args .)
    NE              reduce using rule 24 (functioncall -> prefixexp args .)
    CHECKEQ         reduce using rule 24 (functioncall -> prefixexp args .)
    and             reduce using rule 24 (functioncall -> prefixexp args .)
    or              reduce using rule 24 (functioncall -> prefixexp args .)
    MODULO          reduce using rule 24 (functioncall -> prefixexp args .)
    DBLDOTS         reduce using rule 24 (functioncall -> prefixexp args .)
    return          reduce using rule 24 (functioncall -> prefixexp args .)
    break           reduce using rule 24 (functioncall -> prefixexp args .)
    for             reduce using rule 24 (functioncall -> prefixexp args .)
    while           reduce using rule 24 (functioncall -> prefixexp args .)
    repeat          reduce using rule 24 (functioncall -> prefixexp args .)
    do              reduce using rule 24 (functioncall -> prefixexp args .)
    function        reduce using rule 24 (functioncall -> prefixexp args .)
    local           reduce using rule 24 (functioncall -> prefixexp args .)
    if              reduce using rule 24 (functioncall -> prefixexp args .)
    ID              reduce using rule 24 (functioncall -> prefixexp args .)
    RESID           reduce using rule 24 (functioncall -> prefixexp args .)
    RSQUARE         reduce using rule 24 (functioncall -> prefixexp args .)
    RPAREN          reduce using rule 24 (functioncall -> prefixexp args .)
    then            reduce using rule 24 (functioncall -> prefixexp args .)
    RCURLY          reduce using rule 24 (functioncall -> prefixexp args .)


state 48

    (25) args -> LPAREN . RPAREN
    (26) args -> LPAREN . explist RPAREN
    (59) explist -> . explist COMMA exp
    (60) explist -> . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    RPAREN          shift and go to state 106
    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 108
    var                            shift and go to state 29
    explist                        shift and go to state 107
    names                          shift and go to state 4

state 49

    (57) var -> prefixexp SDOT . names
    (133) names -> . ID
    (134) names -> . RESID

    ID              shift and go to state 18
    RESID           shift and go to state 1

    names                          shift and go to state 109

state 50

    (28) args -> STRING .

    SEMI            reduce using rule 28 (args -> STRING .)
    return          reduce using rule 28 (args -> STRING .)
    break           reduce using rule 28 (args -> STRING .)
    for             reduce using rule 28 (args -> STRING .)
    while           reduce using rule 28 (args -> STRING .)
    repeat          reduce using rule 28 (args -> STRING .)
    do              reduce using rule 28 (args -> STRING .)
    function        reduce using rule 28 (args -> STRING .)
    local           reduce using rule 28 (args -> STRING .)
    if              reduce using rule 28 (args -> STRING .)
    LPAREN          reduce using rule 28 (args -> STRING .)
    ID              reduce using rule 28 (args -> STRING .)
    RESID           reduce using rule 28 (args -> STRING .)
    $end            reduce using rule 28 (args -> STRING .)
    LSQUARE         reduce using rule 28 (args -> STRING .)
    SDOT            reduce using rule 28 (args -> STRING .)
    STRING          reduce using rule 28 (args -> STRING .)
    LCURLY          reduce using rule 28 (args -> STRING .)
    end             reduce using rule 28 (args -> STRING .)
    until           reduce using rule 28 (args -> STRING .)
    else            reduce using rule 28 (args -> STRING .)
    elseif          reduce using rule 28 (args -> STRING .)
    COMMA           reduce using rule 28 (args -> STRING .)
    PLUS            reduce using rule 28 (args -> STRING .)
    MINUS           reduce using rule 28 (args -> STRING .)
    TIMES           reduce using rule 28 (args -> STRING .)
    DIVIDE          reduce using rule 28 (args -> STRING .)
    POWER           reduce using rule 28 (args -> STRING .)
    LT              reduce using rule 28 (args -> STRING .)
    LE              reduce using rule 28 (args -> STRING .)
    GT              reduce using rule 28 (args -> STRING .)
    GE              reduce using rule 28 (args -> STRING .)
    NE              reduce using rule 28 (args -> STRING .)
    CHECKEQ         reduce using rule 28 (args -> STRING .)
    and             reduce using rule 28 (args -> STRING .)
    or              reduce using rule 28 (args -> STRING .)
    MODULO          reduce using rule 28 (args -> STRING .)
    DBLDOTS         reduce using rule 28 (args -> STRING .)
    RPAREN          reduce using rule 28 (args -> STRING .)
    then            reduce using rule 28 (args -> STRING .)
    RCURLY          reduce using rule 28 (args -> STRING .)
    RSQUARE         reduce using rule 28 (args -> STRING .)


state 51

    (13) stat -> for namelist . in explist do block end

    in              shift and go to state 110


state 52

    (11) stat -> for names . EQUALS exp COMMA exp do block end
    (12) stat -> for names . EQUALS exp COMMA exp COMMA exp do block end
    (58) namelist -> names . comid
    (42) comid -> . COMMA names comid
    (43) comid -> . empty
    (115) empty -> .

    EQUALS          shift and go to state 111
    COMMA           shift and go to state 113
    in              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 112
    comid                          shift and go to state 114

state 53

    (10) stat -> varlist EQUALS . explist
    (59) explist -> . explist COMMA exp
    (60) explist -> . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 108
    var                            shift and go to state 29
    explist                        shift and go to state 115
    names                          shift and go to state 4

state 54

    (40) comvar -> COMMA . var comvar
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (133) names -> . ID
    (134) names -> . RESID
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (24) functioncall -> . prefixexp args

    ID              shift and go to state 18
    RESID           shift and go to state 1
    LPAREN          shift and go to state 2

    prefixexp                      shift and go to state 116
    functioncall                   shift and go to state 38
    names                          shift and go to state 4
    var                            shift and go to state 117

state 55

    (54) varlist -> var comvar .

    EQUALS          reduce using rule 54 (varlist -> var comvar .)


state 56

    (41) comvar -> empty .

    EQUALS          reduce using rule 41 (comvar -> empty .)


state 57

    (17) stat -> function funcname . funcbody
    (22) funcbody -> . LPAREN RPAREN block end
    (23) funcbody -> . LPAREN parlist RPAREN block end

    LPAREN          shift and go to state 119

    funcbody                       shift and go to state 118

state 58

    (36) funcname -> names . dotid COLON
    (37) funcname -> names .
    (38) dotid -> . SDOT names dotid
    (39) dotid -> . empty
    (115) empty -> .

    LPAREN          reduce using rule 37 (funcname -> names .)
    SDOT            shift and go to state 120
    COLON           reduce using rule 115 (empty -> .)

    dotid                          shift and go to state 121
    empty                          shift and go to state 122

state 59

    (9) block -> sdash .

    end             reduce using rule 9 (block -> sdash .)
    else            reduce using rule 9 (block -> sdash .)
    elseif          reduce using rule 9 (block -> sdash .)
    until           reduce using rule 9 (block -> sdash .)


state 60

    (16) stat -> do block . end

    end             shift and go to state 123


state 61

    (7) chunk -> stat SEMI .

    return          reduce using rule 7 (chunk -> stat SEMI .)
    break           reduce using rule 7 (chunk -> stat SEMI .)
    for             reduce using rule 7 (chunk -> stat SEMI .)
    while           reduce using rule 7 (chunk -> stat SEMI .)
    repeat          reduce using rule 7 (chunk -> stat SEMI .)
    do              reduce using rule 7 (chunk -> stat SEMI .)
    function        reduce using rule 7 (chunk -> stat SEMI .)
    local           reduce using rule 7 (chunk -> stat SEMI .)
    if              reduce using rule 7 (chunk -> stat SEMI .)
    LPAREN          reduce using rule 7 (chunk -> stat SEMI .)
    ID              reduce using rule 7 (chunk -> stat SEMI .)
    RESID           reduce using rule 7 (chunk -> stat SEMI .)
    end             reduce using rule 7 (chunk -> stat SEMI .)
    else            reduce using rule 7 (chunk -> stat SEMI .)
    elseif          reduce using rule 7 (chunk -> stat SEMI .)
    until           reduce using rule 7 (chunk -> stat SEMI .)
    $end            reduce using rule 7 (chunk -> stat SEMI .)


state 62

    (15) stat -> repeat block . until exp

    until           shift and go to state 124


state 63

    (110) retexp -> tableconstructor .
    (84) exp -> tableconstructor .

    COMMA           reduce using rule 110 (retexp -> tableconstructor .)
    $end            reduce using rule 110 (retexp -> tableconstructor .)
    SEMI            reduce using rule 110 (retexp -> tableconstructor .)
    end             reduce using rule 110 (retexp -> tableconstructor .)
    until           reduce using rule 110 (retexp -> tableconstructor .)
    else            reduce using rule 110 (retexp -> tableconstructor .)
    elseif          reduce using rule 110 (retexp -> tableconstructor .)
    PLUS            reduce using rule 84 (exp -> tableconstructor .)
    MINUS           reduce using rule 84 (exp -> tableconstructor .)
    TIMES           reduce using rule 84 (exp -> tableconstructor .)
    DIVIDE          reduce using rule 84 (exp -> tableconstructor .)
    POWER           reduce using rule 84 (exp -> tableconstructor .)
    LT              reduce using rule 84 (exp -> tableconstructor .)
    LE              reduce using rule 84 (exp -> tableconstructor .)
    GT              reduce using rule 84 (exp -> tableconstructor .)
    GE              reduce using rule 84 (exp -> tableconstructor .)
    NE              reduce using rule 84 (exp -> tableconstructor .)
    CHECKEQ         reduce using rule 84 (exp -> tableconstructor .)
    and             reduce using rule 84 (exp -> tableconstructor .)
    or              reduce using rule 84 (exp -> tableconstructor .)
    MODULO          reduce using rule 84 (exp -> tableconstructor .)
    DBLDOTS         reduce using rule 84 (exp -> tableconstructor .)


state 64

    (89) retexp -> false .
    (62) exp -> false .

    COMMA           reduce using rule 89 (retexp -> false .)
    $end            reduce using rule 89 (retexp -> false .)
    SEMI            reduce using rule 89 (retexp -> false .)
    end             reduce using rule 89 (retexp -> false .)
    until           reduce using rule 89 (retexp -> false .)
    else            reduce using rule 89 (retexp -> false .)
    elseif          reduce using rule 89 (retexp -> false .)
    PLUS            reduce using rule 62 (exp -> false .)
    MINUS           reduce using rule 62 (exp -> false .)
    TIMES           reduce using rule 62 (exp -> false .)
    DIVIDE          reduce using rule 62 (exp -> false .)
    POWER           reduce using rule 62 (exp -> false .)
    LT              reduce using rule 62 (exp -> false .)
    LE              reduce using rule 62 (exp -> false .)
    GT              reduce using rule 62 (exp -> false .)
    GE              reduce using rule 62 (exp -> false .)
    NE              reduce using rule 62 (exp -> false .)
    CHECKEQ         reduce using rule 62 (exp -> false .)
    and             reduce using rule 62 (exp -> false .)
    or              reduce using rule 62 (exp -> false .)
    MODULO          reduce using rule 62 (exp -> false .)
    DBLDOTS         reduce using rule 62 (exp -> false .)


state 65

    (93) retexp -> TRPLDOTS .
    (66) exp -> TRPLDOTS .

    COMMA           reduce using rule 93 (retexp -> TRPLDOTS .)
    $end            reduce using rule 93 (retexp -> TRPLDOTS .)
    SEMI            reduce using rule 93 (retexp -> TRPLDOTS .)
    end             reduce using rule 93 (retexp -> TRPLDOTS .)
    until           reduce using rule 93 (retexp -> TRPLDOTS .)
    else            reduce using rule 93 (retexp -> TRPLDOTS .)
    elseif          reduce using rule 93 (retexp -> TRPLDOTS .)
    PLUS            reduce using rule 66 (exp -> TRPLDOTS .)
    MINUS           reduce using rule 66 (exp -> TRPLDOTS .)
    TIMES           reduce using rule 66 (exp -> TRPLDOTS .)
    DIVIDE          reduce using rule 66 (exp -> TRPLDOTS .)
    POWER           reduce using rule 66 (exp -> TRPLDOTS .)
    LT              reduce using rule 66 (exp -> TRPLDOTS .)
    LE              reduce using rule 66 (exp -> TRPLDOTS .)
    GT              reduce using rule 66 (exp -> TRPLDOTS .)
    GE              reduce using rule 66 (exp -> TRPLDOTS .)
    NE              reduce using rule 66 (exp -> TRPLDOTS .)
    CHECKEQ         reduce using rule 66 (exp -> TRPLDOTS .)
    and             reduce using rule 66 (exp -> TRPLDOTS .)
    or              reduce using rule 66 (exp -> TRPLDOTS .)
    MODULO          reduce using rule 66 (exp -> TRPLDOTS .)
    DBLDOTS         reduce using rule 66 (exp -> TRPLDOTS .)


state 66

    (94) retexp -> prefixexp .
    (68) exp -> prefixexp .
    (56) var -> prefixexp . LSQUARE exp RSQUARE
    (57) var -> prefixexp . SDOT names
    (24) functioncall -> prefixexp . args
    (25) args -> . LPAREN RPAREN
    (26) args -> . LPAREN explist RPAREN
    (27) args -> . tableconstructor
    (28) args -> . STRING
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY

    COMMA           reduce using rule 94 (retexp -> prefixexp .)
    $end            reduce using rule 94 (retexp -> prefixexp .)
    SEMI            reduce using rule 94 (retexp -> prefixexp .)
    end             reduce using rule 94 (retexp -> prefixexp .)
    until           reduce using rule 94 (retexp -> prefixexp .)
    else            reduce using rule 94 (retexp -> prefixexp .)
    elseif          reduce using rule 94 (retexp -> prefixexp .)
    PLUS            reduce using rule 68 (exp -> prefixexp .)
    MINUS           reduce using rule 68 (exp -> prefixexp .)
    TIMES           reduce using rule 68 (exp -> prefixexp .)
    DIVIDE          reduce using rule 68 (exp -> prefixexp .)
    POWER           reduce using rule 68 (exp -> prefixexp .)
    LT              reduce using rule 68 (exp -> prefixexp .)
    LE              reduce using rule 68 (exp -> prefixexp .)
    GT              reduce using rule 68 (exp -> prefixexp .)
    GE              reduce using rule 68 (exp -> prefixexp .)
    NE              reduce using rule 68 (exp -> prefixexp .)
    CHECKEQ         reduce using rule 68 (exp -> prefixexp .)
    and             reduce using rule 68 (exp -> prefixexp .)
    or              reduce using rule 68 (exp -> prefixexp .)
    MODULO          reduce using rule 68 (exp -> prefixexp .)
    DBLDOTS         reduce using rule 68 (exp -> prefixexp .)
    LSQUARE         shift and go to state 46
    SDOT            shift and go to state 49
    LPAREN          shift and go to state 48
    STRING          shift and go to state 50
    LCURLY          shift and go to state 24

    tableconstructor               shift and go to state 45
    args                           shift and go to state 47

state 67

    (87) retexplist -> retexp .

    COMMA           reduce using rule 87 (retexplist -> retexp .)
    $end            reduce using rule 87 (retexplist -> retexp .)
    SEMI            reduce using rule 87 (retexplist -> retexp .)
    end             reduce using rule 87 (retexplist -> retexp .)
    until           reduce using rule 87 (retexplist -> retexp .)
    else            reduce using rule 87 (retexplist -> retexp .)
    elseif          reduce using rule 87 (retexplist -> retexp .)


state 68

    (92) retexp -> STRING .
    (65) exp -> STRING .

    COMMA           reduce using rule 92 (retexp -> STRING .)
    $end            reduce using rule 92 (retexp -> STRING .)
    SEMI            reduce using rule 92 (retexp -> STRING .)
    end             reduce using rule 92 (retexp -> STRING .)
    until           reduce using rule 92 (retexp -> STRING .)
    else            reduce using rule 92 (retexp -> STRING .)
    elseif          reduce using rule 92 (retexp -> STRING .)
    PLUS            reduce using rule 65 (exp -> STRING .)
    MINUS           reduce using rule 65 (exp -> STRING .)
    TIMES           reduce using rule 65 (exp -> STRING .)
    DIVIDE          reduce using rule 65 (exp -> STRING .)
    POWER           reduce using rule 65 (exp -> STRING .)
    LT              reduce using rule 65 (exp -> STRING .)
    LE              reduce using rule 65 (exp -> STRING .)
    GT              reduce using rule 65 (exp -> STRING .)
    GE              reduce using rule 65 (exp -> STRING .)
    NE              reduce using rule 65 (exp -> STRING .)
    CHECKEQ         reduce using rule 65 (exp -> STRING .)
    and             reduce using rule 65 (exp -> STRING .)
    or              reduce using rule 65 (exp -> STRING .)
    MODULO          reduce using rule 65 (exp -> STRING .)
    DBLDOTS         reduce using rule 65 (exp -> STRING .)


state 69

    (88) retexp -> nil .
    (61) exp -> nil .

    COMMA           reduce using rule 88 (retexp -> nil .)
    $end            reduce using rule 88 (retexp -> nil .)
    SEMI            reduce using rule 88 (retexp -> nil .)
    end             reduce using rule 88 (retexp -> nil .)
    until           reduce using rule 88 (retexp -> nil .)
    else            reduce using rule 88 (retexp -> nil .)
    elseif          reduce using rule 88 (retexp -> nil .)
    PLUS            reduce using rule 61 (exp -> nil .)
    MINUS           reduce using rule 61 (exp -> nil .)
    TIMES           reduce using rule 61 (exp -> nil .)
    DIVIDE          reduce using rule 61 (exp -> nil .)
    POWER           reduce using rule 61 (exp -> nil .)
    LT              reduce using rule 61 (exp -> nil .)
    LE              reduce using rule 61 (exp -> nil .)
    GT              reduce using rule 61 (exp -> nil .)
    GE              reduce using rule 61 (exp -> nil .)
    NE              reduce using rule 61 (exp -> nil .)
    CHECKEQ         reduce using rule 61 (exp -> nil .)
    and             reduce using rule 61 (exp -> nil .)
    or              reduce using rule 61 (exp -> nil .)
    MODULO          reduce using rule 61 (exp -> nil .)
    DBLDOTS         reduce using rule 61 (exp -> nil .)


state 70

    (90) retexp -> true .
    (63) exp -> true .

    COMMA           reduce using rule 90 (retexp -> true .)
    $end            reduce using rule 90 (retexp -> true .)
    SEMI            reduce using rule 90 (retexp -> true .)
    end             reduce using rule 90 (retexp -> true .)
    until           reduce using rule 90 (retexp -> true .)
    else            reduce using rule 90 (retexp -> true .)
    elseif          reduce using rule 90 (retexp -> true .)
    PLUS            reduce using rule 63 (exp -> true .)
    MINUS           reduce using rule 63 (exp -> true .)
    TIMES           reduce using rule 63 (exp -> true .)
    DIVIDE          reduce using rule 63 (exp -> true .)
    POWER           reduce using rule 63 (exp -> true .)
    LT              reduce using rule 63 (exp -> true .)
    LE              reduce using rule 63 (exp -> true .)
    GT              reduce using rule 63 (exp -> true .)
    GE              reduce using rule 63 (exp -> true .)
    NE              reduce using rule 63 (exp -> true .)
    CHECKEQ         reduce using rule 63 (exp -> true .)
    and             reduce using rule 63 (exp -> true .)
    or              reduce using rule 63 (exp -> true .)
    MODULO          reduce using rule 63 (exp -> true .)
    DBLDOTS         reduce using rule 63 (exp -> true .)


state 71

    (91) retexp -> Number .
    (64) exp -> Number .

    COMMA           reduce using rule 91 (retexp -> Number .)
    $end            reduce using rule 91 (retexp -> Number .)
    SEMI            reduce using rule 91 (retexp -> Number .)
    end             reduce using rule 91 (retexp -> Number .)
    until           reduce using rule 91 (retexp -> Number .)
    else            reduce using rule 91 (retexp -> Number .)
    elseif          reduce using rule 91 (retexp -> Number .)
    PLUS            reduce using rule 64 (exp -> Number .)
    MINUS           reduce using rule 64 (exp -> Number .)
    TIMES           reduce using rule 64 (exp -> Number .)
    DIVIDE          reduce using rule 64 (exp -> Number .)
    POWER           reduce using rule 64 (exp -> Number .)
    LT              reduce using rule 64 (exp -> Number .)
    LE              reduce using rule 64 (exp -> Number .)
    GT              reduce using rule 64 (exp -> Number .)
    GE              reduce using rule 64 (exp -> Number .)
    NE              reduce using rule 64 (exp -> Number .)
    CHECKEQ         reduce using rule 64 (exp -> Number .)
    and             reduce using rule 64 (exp -> Number .)
    or              reduce using rule 64 (exp -> Number .)
    MODULO          reduce using rule 64 (exp -> Number .)
    DBLDOTS         reduce using rule 64 (exp -> Number .)


state 72

    (33) laststat -> return retexplist .
    (86) retexplist -> retexplist . COMMA retexp

    end             reduce using rule 33 (laststat -> return retexplist .)
    else            reduce using rule 33 (laststat -> return retexplist .)
    elseif          reduce using rule 33 (laststat -> return retexplist .)
    $end            reduce using rule 33 (laststat -> return retexplist .)
    SEMI            reduce using rule 33 (laststat -> return retexplist .)
    until           reduce using rule 33 (laststat -> return retexplist .)
    COMMA           shift and go to state 125


state 73

    (95) retexp -> exp . PLUS exp
    (96) retexp -> exp . MINUS exp
    (97) retexp -> exp . TIMES exp
    (98) retexp -> exp . DIVIDE exp
    (99) retexp -> exp . POWER exp
    (100) retexp -> exp . LT exp
    (101) retexp -> exp . LE exp
    (102) retexp -> exp . GT exp
    (103) retexp -> exp . GE exp
    (104) retexp -> exp . NE exp
    (105) retexp -> exp . CHECKEQ exp
    (106) retexp -> exp . and exp
    (107) retexp -> exp . or exp
    (108) retexp -> exp . MODULO exp
    (109) retexp -> exp . DBLDOTS exp
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    PLUS            shift and go to state 137
    MINUS           shift and go to state 139
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 129
    POWER           shift and go to state 130
    LT              shift and go to state 135
    LE              shift and go to state 127
    GT              shift and go to state 136
    GE              shift and go to state 132
    NE              shift and go to state 140
    CHECKEQ         shift and go to state 134
    and             shift and go to state 126
    or              shift and go to state 131
    MODULO          shift and go to state 128
    DBLDOTS         shift and go to state 138


state 74

    (111) retexp -> unop . exp
    (85) exp -> unop . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    unop                           shift and go to state 40
    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    functioncall                   shift and go to state 38
    exp                            shift and go to state 141
    var                            shift and go to state 29
    names                          shift and go to state 4

state 75

    (18) stat -> local function . names funcbody
    (133) names -> . ID
    (134) names -> . RESID

    ID              shift and go to state 18
    RESID           shift and go to state 1

    names                          shift and go to state 142

state 76

    (19) stat -> local namelist .
    (20) stat -> local namelist . EQUALS explist

    SEMI            reduce using rule 19 (stat -> local namelist .)
    return          reduce using rule 19 (stat -> local namelist .)
    break           reduce using rule 19 (stat -> local namelist .)
    for             reduce using rule 19 (stat -> local namelist .)
    while           reduce using rule 19 (stat -> local namelist .)
    repeat          reduce using rule 19 (stat -> local namelist .)
    do              reduce using rule 19 (stat -> local namelist .)
    function        reduce using rule 19 (stat -> local namelist .)
    local           reduce using rule 19 (stat -> local namelist .)
    if              reduce using rule 19 (stat -> local namelist .)
    LPAREN          reduce using rule 19 (stat -> local namelist .)
    ID              reduce using rule 19 (stat -> local namelist .)
    RESID           reduce using rule 19 (stat -> local namelist .)
    end             reduce using rule 19 (stat -> local namelist .)
    $end            reduce using rule 19 (stat -> local namelist .)
    until           reduce using rule 19 (stat -> local namelist .)
    else            reduce using rule 19 (stat -> local namelist .)
    elseif          reduce using rule 19 (stat -> local namelist .)
    EQUALS          shift and go to state 143


state 77

    (58) namelist -> names . comid
    (42) comid -> . COMMA names comid
    (43) comid -> . empty
    (115) empty -> .

    COMMA           shift and go to state 113
    EQUALS          reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    return          reduce using rule 115 (empty -> .)
    break           reduce using rule 115 (empty -> .)
    for             reduce using rule 115 (empty -> .)
    while           reduce using rule 115 (empty -> .)
    repeat          reduce using rule 115 (empty -> .)
    do              reduce using rule 115 (empty -> .)
    function        reduce using rule 115 (empty -> .)
    local           reduce using rule 115 (empty -> .)
    if              reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RESID           reduce using rule 115 (empty -> .)
    $end            reduce using rule 115 (empty -> .)
    end             reduce using rule 115 (empty -> .)
    until           reduce using rule 115 (empty -> .)
    else            reduce using rule 115 (empty -> .)
    elseif          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)

  ! COMMA           [ reduce using rule 115 (empty -> .) ]

    empty                          shift and go to state 112
    comid                          shift and go to state 114

state 78

    (14) stat -> while exp . do block end
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    do              shift and go to state 144
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 79

    (129) field -> names . EQUALS exp
    (55) var -> names .

    EQUALS          shift and go to state 145
    LSQUARE         reduce using rule 55 (var -> names .)
    SDOT            reduce using rule 55 (var -> names .)
    LPAREN          reduce using rule 55 (var -> names .)
    STRING          reduce using rule 55 (var -> names .)
    LCURLY          reduce using rule 55 (var -> names .)
    PLUS            reduce using rule 55 (var -> names .)
    MINUS           reduce using rule 55 (var -> names .)
    TIMES           reduce using rule 55 (var -> names .)
    DIVIDE          reduce using rule 55 (var -> names .)
    POWER           reduce using rule 55 (var -> names .)
    LT              reduce using rule 55 (var -> names .)
    LE              reduce using rule 55 (var -> names .)
    GT              reduce using rule 55 (var -> names .)
    GE              reduce using rule 55 (var -> names .)
    NE              reduce using rule 55 (var -> names .)
    CHECKEQ         reduce using rule 55 (var -> names .)
    and             reduce using rule 55 (var -> names .)
    or              reduce using rule 55 (var -> names .)
    MODULO          reduce using rule 55 (var -> names .)
    DBLDOTS         reduce using rule 55 (var -> names .)
    COMMA           reduce using rule 55 (var -> names .)
    SEMI            reduce using rule 55 (var -> names .)
    RCURLY          reduce using rule 55 (var -> names .)


state 80

    (123) tableconstructor -> LCURLY RCURLY .

    PLUS            reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    MINUS           reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    TIMES           reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    DIVIDE          reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    POWER           reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    LT              reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    LE              reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    GT              reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    GE              reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    NE              reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    CHECKEQ         reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    and             reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    or              reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    MODULO          reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    DBLDOTS         reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    COMMA           reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    $end            reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    SEMI            reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    end             reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    until           reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    else            reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    elseif          reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    RPAREN          reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    then            reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    do              reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    RCURLY          reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    RSQUARE         reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    return          reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    break           reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    for             reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    while           reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    repeat          reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    function        reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    local           reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    if              reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    LPAREN          reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    ID              reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    RESID           reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    LSQUARE         reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    SDOT            reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    STRING          reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)
    LCURLY          reduce using rule 123 (tableconstructor -> LCURLY RCURLY .)


state 81

    (124) fieldlist -> field . fieldseplist fieldsep
    (125) fieldlist -> field . fieldseplist
    (126) fieldseplist -> . fieldseplist fieldsep field
    (127) fieldseplist -> . empty
    (115) empty -> .

    COMMA           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RCURLY          reduce using rule 115 (empty -> .)

    fieldseplist                   shift and go to state 146
    empty                          shift and go to state 147

state 82

    (122) tableconstructor -> LCURLY fieldlist . RCURLY

    RCURLY          shift and go to state 148


state 83

    (130) field -> exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 130 (field -> exp .)
    SEMI            reduce using rule 130 (field -> exp .)
    RCURLY          reduce using rule 130 (field -> exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 84

    (128) field -> LSQUARE . exp RSQUARE EQUALS exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 149
    var                            shift and go to state 29
    names                          shift and go to state 4

state 85

    (80) exp -> exp and . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 150
    var                            shift and go to state 29
    names                          shift and go to state 4

state 86

    (75) exp -> exp LE . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 151
    var                            shift and go to state 29
    names                          shift and go to state 4

state 87

    (117) prefixexp -> LPAREN exp RPAREN .

    LSQUARE         reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    SDOT            reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    STRING          reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    LCURLY          reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    POWER           reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    LE              reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    GE              reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    CHECKEQ         reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    and             reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    or              reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    MODULO          reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    DBLDOTS         reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    $end            reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    SEMI            reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    end             reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    until           reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    else            reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    elseif          reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    then            reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    do              reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    RCURLY          reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    RSQUARE         reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    return          reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    break           reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    for             reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    while           reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    repeat          reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    function        reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    local           reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    if              reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)
    RESID           reduce using rule 117 (prefixexp -> LPAREN exp RPAREN .)


state 88

    (73) exp -> exp POWER . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 152
    var                            shift and go to state 29
    names                          shift and go to state 4

state 89

    (81) exp -> exp or . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 153
    var                            shift and go to state 29
    names                          shift and go to state 4

state 90

    (77) exp -> exp GE . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 154
    var                            shift and go to state 29
    names                          shift and go to state 4

state 91

    (71) exp -> exp TIMES . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 155
    var                            shift and go to state 29
    names                          shift and go to state 4

state 92

    (79) exp -> exp CHECKEQ . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 156
    var                            shift and go to state 29
    names                          shift and go to state 4

state 93

    (74) exp -> exp LT . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 157
    var                            shift and go to state 29
    names                          shift and go to state 4

state 94

    (76) exp -> exp GT . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 158
    var                            shift and go to state 29
    names                          shift and go to state 4

state 95

    (69) exp -> exp PLUS . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 159
    var                            shift and go to state 29
    names                          shift and go to state 4

state 96

    (82) exp -> exp MODULO . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 160
    var                            shift and go to state 29
    names                          shift and go to state 4

state 97

    (83) exp -> exp DBLDOTS . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 161
    var                            shift and go to state 29
    names                          shift and go to state 4

state 98

    (70) exp -> exp MINUS . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 162
    var                            shift and go to state 29
    names                          shift and go to state 4

state 99

    (78) exp -> exp NE . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 163
    var                            shift and go to state 29
    names                          shift and go to state 4

state 100

    (72) exp -> exp DIVIDE . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 164
    var                            shift and go to state 29
    names                          shift and go to state 4

state 101

    (85) exp -> unop exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 85 (exp -> unop exp .)
    MINUS           reduce using rule 85 (exp -> unop exp .)
    TIMES           reduce using rule 85 (exp -> unop exp .)
    DIVIDE          reduce using rule 85 (exp -> unop exp .)
    LT              reduce using rule 85 (exp -> unop exp .)
    LE              reduce using rule 85 (exp -> unop exp .)
    GT              reduce using rule 85 (exp -> unop exp .)
    GE              reduce using rule 85 (exp -> unop exp .)
    NE              reduce using rule 85 (exp -> unop exp .)
    CHECKEQ         reduce using rule 85 (exp -> unop exp .)
    and             reduce using rule 85 (exp -> unop exp .)
    or              reduce using rule 85 (exp -> unop exp .)
    MODULO          reduce using rule 85 (exp -> unop exp .)
    DBLDOTS         reduce using rule 85 (exp -> unop exp .)
    RPAREN          reduce using rule 85 (exp -> unop exp .)
    then            reduce using rule 85 (exp -> unop exp .)
    do              reduce using rule 85 (exp -> unop exp .)
    COMMA           reduce using rule 85 (exp -> unop exp .)
    SEMI            reduce using rule 85 (exp -> unop exp .)
    RCURLY          reduce using rule 85 (exp -> unop exp .)
    RSQUARE         reduce using rule 85 (exp -> unop exp .)
    return          reduce using rule 85 (exp -> unop exp .)
    break           reduce using rule 85 (exp -> unop exp .)
    for             reduce using rule 85 (exp -> unop exp .)
    while           reduce using rule 85 (exp -> unop exp .)
    repeat          reduce using rule 85 (exp -> unop exp .)
    function        reduce using rule 85 (exp -> unop exp .)
    local           reduce using rule 85 (exp -> unop exp .)
    if              reduce using rule 85 (exp -> unop exp .)
    LPAREN          reduce using rule 85 (exp -> unop exp .)
    ID              reduce using rule 85 (exp -> unop exp .)
    RESID           reduce using rule 85 (exp -> unop exp .)
    $end            reduce using rule 85 (exp -> unop exp .)
    end             reduce using rule 85 (exp -> unop exp .)
    until           reduce using rule 85 (exp -> unop exp .)
    else            reduce using rule 85 (exp -> unop exp .)
    elseif          reduce using rule 85 (exp -> unop exp .)
    POWER           shift and go to state 88

  ! POWER           [ reduce using rule 85 (exp -> unop exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 100 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! MODULO          [ shift and go to state 96 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 102

    (4) sdash -> chunk laststat SEMI .

    end             reduce using rule 4 (sdash -> chunk laststat SEMI .)
    else            reduce using rule 4 (sdash -> chunk laststat SEMI .)
    elseif          reduce using rule 4 (sdash -> chunk laststat SEMI .)
    $end            reduce using rule 4 (sdash -> chunk laststat SEMI .)
    until           reduce using rule 4 (sdash -> chunk laststat SEMI .)


state 103

    (6) chunk -> chunk stat SEMI .

    return          reduce using rule 6 (chunk -> chunk stat SEMI .)
    break           reduce using rule 6 (chunk -> chunk stat SEMI .)
    for             reduce using rule 6 (chunk -> chunk stat SEMI .)
    while           reduce using rule 6 (chunk -> chunk stat SEMI .)
    repeat          reduce using rule 6 (chunk -> chunk stat SEMI .)
    do              reduce using rule 6 (chunk -> chunk stat SEMI .)
    function        reduce using rule 6 (chunk -> chunk stat SEMI .)
    local           reduce using rule 6 (chunk -> chunk stat SEMI .)
    if              reduce using rule 6 (chunk -> chunk stat SEMI .)
    LPAREN          reduce using rule 6 (chunk -> chunk stat SEMI .)
    ID              reduce using rule 6 (chunk -> chunk stat SEMI .)
    RESID           reduce using rule 6 (chunk -> chunk stat SEMI .)
    end             reduce using rule 6 (chunk -> chunk stat SEMI .)
    else            reduce using rule 6 (chunk -> chunk stat SEMI .)
    elseif          reduce using rule 6 (chunk -> chunk stat SEMI .)
    until           reduce using rule 6 (chunk -> chunk stat SEMI .)
    $end            reduce using rule 6 (chunk -> chunk stat SEMI .)


state 104

    (44) stat -> if exp then . M_if1 block ifblock end
    (46) stat -> if exp then . M_if1 block ifblock M_if3 else M_if4 block end
    (45) M_if1 -> . empty
    (115) empty -> .

    return          reduce using rule 115 (empty -> .)
    break           reduce using rule 115 (empty -> .)
    for             reduce using rule 115 (empty -> .)
    while           reduce using rule 115 (empty -> .)
    repeat          reduce using rule 115 (empty -> .)
    do              reduce using rule 115 (empty -> .)
    function        reduce using rule 115 (empty -> .)
    local           reduce using rule 115 (empty -> .)
    if              reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RESID           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 165
    M_if1                          shift and go to state 166

state 105

    (56) var -> prefixexp LSQUARE exp . RSQUARE
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    RSQUARE         shift and go to state 167
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 106

    (25) args -> LPAREN RPAREN .

    SEMI            reduce using rule 25 (args -> LPAREN RPAREN .)
    return          reduce using rule 25 (args -> LPAREN RPAREN .)
    break           reduce using rule 25 (args -> LPAREN RPAREN .)
    for             reduce using rule 25 (args -> LPAREN RPAREN .)
    while           reduce using rule 25 (args -> LPAREN RPAREN .)
    repeat          reduce using rule 25 (args -> LPAREN RPAREN .)
    do              reduce using rule 25 (args -> LPAREN RPAREN .)
    function        reduce using rule 25 (args -> LPAREN RPAREN .)
    local           reduce using rule 25 (args -> LPAREN RPAREN .)
    if              reduce using rule 25 (args -> LPAREN RPAREN .)
    LPAREN          reduce using rule 25 (args -> LPAREN RPAREN .)
    ID              reduce using rule 25 (args -> LPAREN RPAREN .)
    RESID           reduce using rule 25 (args -> LPAREN RPAREN .)
    $end            reduce using rule 25 (args -> LPAREN RPAREN .)
    LSQUARE         reduce using rule 25 (args -> LPAREN RPAREN .)
    SDOT            reduce using rule 25 (args -> LPAREN RPAREN .)
    STRING          reduce using rule 25 (args -> LPAREN RPAREN .)
    LCURLY          reduce using rule 25 (args -> LPAREN RPAREN .)
    end             reduce using rule 25 (args -> LPAREN RPAREN .)
    until           reduce using rule 25 (args -> LPAREN RPAREN .)
    else            reduce using rule 25 (args -> LPAREN RPAREN .)
    elseif          reduce using rule 25 (args -> LPAREN RPAREN .)
    COMMA           reduce using rule 25 (args -> LPAREN RPAREN .)
    PLUS            reduce using rule 25 (args -> LPAREN RPAREN .)
    MINUS           reduce using rule 25 (args -> LPAREN RPAREN .)
    TIMES           reduce using rule 25 (args -> LPAREN RPAREN .)
    DIVIDE          reduce using rule 25 (args -> LPAREN RPAREN .)
    POWER           reduce using rule 25 (args -> LPAREN RPAREN .)
    LT              reduce using rule 25 (args -> LPAREN RPAREN .)
    LE              reduce using rule 25 (args -> LPAREN RPAREN .)
    GT              reduce using rule 25 (args -> LPAREN RPAREN .)
    GE              reduce using rule 25 (args -> LPAREN RPAREN .)
    NE              reduce using rule 25 (args -> LPAREN RPAREN .)
    CHECKEQ         reduce using rule 25 (args -> LPAREN RPAREN .)
    and             reduce using rule 25 (args -> LPAREN RPAREN .)
    or              reduce using rule 25 (args -> LPAREN RPAREN .)
    MODULO          reduce using rule 25 (args -> LPAREN RPAREN .)
    DBLDOTS         reduce using rule 25 (args -> LPAREN RPAREN .)
    RPAREN          reduce using rule 25 (args -> LPAREN RPAREN .)
    then            reduce using rule 25 (args -> LPAREN RPAREN .)
    RCURLY          reduce using rule 25 (args -> LPAREN RPAREN .)
    RSQUARE         reduce using rule 25 (args -> LPAREN RPAREN .)


state 107

    (26) args -> LPAREN explist . RPAREN
    (59) explist -> explist . COMMA exp

    RPAREN          shift and go to state 169
    COMMA           shift and go to state 168


state 108

    (60) explist -> exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    do              reduce using rule 60 (explist -> exp .)
    COMMA           reduce using rule 60 (explist -> exp .)
    SEMI            reduce using rule 60 (explist -> exp .)
    return          reduce using rule 60 (explist -> exp .)
    break           reduce using rule 60 (explist -> exp .)
    for             reduce using rule 60 (explist -> exp .)
    while           reduce using rule 60 (explist -> exp .)
    repeat          reduce using rule 60 (explist -> exp .)
    function        reduce using rule 60 (explist -> exp .)
    local           reduce using rule 60 (explist -> exp .)
    if              reduce using rule 60 (explist -> exp .)
    LPAREN          reduce using rule 60 (explist -> exp .)
    ID              reduce using rule 60 (explist -> exp .)
    RESID           reduce using rule 60 (explist -> exp .)
    $end            reduce using rule 60 (explist -> exp .)
    end             reduce using rule 60 (explist -> exp .)
    until           reduce using rule 60 (explist -> exp .)
    else            reduce using rule 60 (explist -> exp .)
    elseif          reduce using rule 60 (explist -> exp .)
    RPAREN          reduce using rule 60 (explist -> exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 109

    (57) var -> prefixexp SDOT names .

    COMMA           reduce using rule 57 (var -> prefixexp SDOT names .)
    EQUALS          reduce using rule 57 (var -> prefixexp SDOT names .)
    LSQUARE         reduce using rule 57 (var -> prefixexp SDOT names .)
    SDOT            reduce using rule 57 (var -> prefixexp SDOT names .)
    LPAREN          reduce using rule 57 (var -> prefixexp SDOT names .)
    STRING          reduce using rule 57 (var -> prefixexp SDOT names .)
    LCURLY          reduce using rule 57 (var -> prefixexp SDOT names .)
    PLUS            reduce using rule 57 (var -> prefixexp SDOT names .)
    MINUS           reduce using rule 57 (var -> prefixexp SDOT names .)
    TIMES           reduce using rule 57 (var -> prefixexp SDOT names .)
    DIVIDE          reduce using rule 57 (var -> prefixexp SDOT names .)
    POWER           reduce using rule 57 (var -> prefixexp SDOT names .)
    LT              reduce using rule 57 (var -> prefixexp SDOT names .)
    LE              reduce using rule 57 (var -> prefixexp SDOT names .)
    GT              reduce using rule 57 (var -> prefixexp SDOT names .)
    GE              reduce using rule 57 (var -> prefixexp SDOT names .)
    NE              reduce using rule 57 (var -> prefixexp SDOT names .)
    CHECKEQ         reduce using rule 57 (var -> prefixexp SDOT names .)
    and             reduce using rule 57 (var -> prefixexp SDOT names .)
    or              reduce using rule 57 (var -> prefixexp SDOT names .)
    MODULO          reduce using rule 57 (var -> prefixexp SDOT names .)
    DBLDOTS         reduce using rule 57 (var -> prefixexp SDOT names .)
    $end            reduce using rule 57 (var -> prefixexp SDOT names .)
    SEMI            reduce using rule 57 (var -> prefixexp SDOT names .)
    end             reduce using rule 57 (var -> prefixexp SDOT names .)
    until           reduce using rule 57 (var -> prefixexp SDOT names .)
    else            reduce using rule 57 (var -> prefixexp SDOT names .)
    elseif          reduce using rule 57 (var -> prefixexp SDOT names .)
    RPAREN          reduce using rule 57 (var -> prefixexp SDOT names .)
    then            reduce using rule 57 (var -> prefixexp SDOT names .)
    do              reduce using rule 57 (var -> prefixexp SDOT names .)
    RCURLY          reduce using rule 57 (var -> prefixexp SDOT names .)
    RSQUARE         reduce using rule 57 (var -> prefixexp SDOT names .)
    return          reduce using rule 57 (var -> prefixexp SDOT names .)
    break           reduce using rule 57 (var -> prefixexp SDOT names .)
    for             reduce using rule 57 (var -> prefixexp SDOT names .)
    while           reduce using rule 57 (var -> prefixexp SDOT names .)
    repeat          reduce using rule 57 (var -> prefixexp SDOT names .)
    function        reduce using rule 57 (var -> prefixexp SDOT names .)
    local           reduce using rule 57 (var -> prefixexp SDOT names .)
    if              reduce using rule 57 (var -> prefixexp SDOT names .)
    ID              reduce using rule 57 (var -> prefixexp SDOT names .)
    RESID           reduce using rule 57 (var -> prefixexp SDOT names .)


state 110

    (13) stat -> for namelist in . explist do block end
    (59) explist -> . explist COMMA exp
    (60) explist -> . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 108
    var                            shift and go to state 29
    explist                        shift and go to state 170
    names                          shift and go to state 4

state 111

    (11) stat -> for names EQUALS . exp COMMA exp do block end
    (12) stat -> for names EQUALS . exp COMMA exp COMMA exp do block end
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    names                          shift and go to state 4
    exp                            shift and go to state 171
    var                            shift and go to state 29

state 112

    (43) comid -> empty .

    EQUALS          reduce using rule 43 (comid -> empty .)
    SEMI            reduce using rule 43 (comid -> empty .)
    return          reduce using rule 43 (comid -> empty .)
    break           reduce using rule 43 (comid -> empty .)
    for             reduce using rule 43 (comid -> empty .)
    while           reduce using rule 43 (comid -> empty .)
    repeat          reduce using rule 43 (comid -> empty .)
    do              reduce using rule 43 (comid -> empty .)
    function        reduce using rule 43 (comid -> empty .)
    local           reduce using rule 43 (comid -> empty .)
    if              reduce using rule 43 (comid -> empty .)
    LPAREN          reduce using rule 43 (comid -> empty .)
    ID              reduce using rule 43 (comid -> empty .)
    RESID           reduce using rule 43 (comid -> empty .)
    $end            reduce using rule 43 (comid -> empty .)
    end             reduce using rule 43 (comid -> empty .)
    until           reduce using rule 43 (comid -> empty .)
    else            reduce using rule 43 (comid -> empty .)
    elseif          reduce using rule 43 (comid -> empty .)
    COMMA           reduce using rule 43 (comid -> empty .)
    RPAREN          reduce using rule 43 (comid -> empty .)
    in              reduce using rule 43 (comid -> empty .)


state 113

    (42) comid -> COMMA . names comid
    (133) names -> . ID
    (134) names -> . RESID

    ID              shift and go to state 18
    RESID           shift and go to state 1

    names                          shift and go to state 172

state 114

    (58) namelist -> names comid .

    EQUALS          reduce using rule 58 (namelist -> names comid .)
    SEMI            reduce using rule 58 (namelist -> names comid .)
    return          reduce using rule 58 (namelist -> names comid .)
    break           reduce using rule 58 (namelist -> names comid .)
    for             reduce using rule 58 (namelist -> names comid .)
    while           reduce using rule 58 (namelist -> names comid .)
    repeat          reduce using rule 58 (namelist -> names comid .)
    do              reduce using rule 58 (namelist -> names comid .)
    function        reduce using rule 58 (namelist -> names comid .)
    local           reduce using rule 58 (namelist -> names comid .)
    if              reduce using rule 58 (namelist -> names comid .)
    LPAREN          reduce using rule 58 (namelist -> names comid .)
    ID              reduce using rule 58 (namelist -> names comid .)
    RESID           reduce using rule 58 (namelist -> names comid .)
    $end            reduce using rule 58 (namelist -> names comid .)
    end             reduce using rule 58 (namelist -> names comid .)
    until           reduce using rule 58 (namelist -> names comid .)
    else            reduce using rule 58 (namelist -> names comid .)
    elseif          reduce using rule 58 (namelist -> names comid .)
    COMMA           reduce using rule 58 (namelist -> names comid .)
    RPAREN          reduce using rule 58 (namelist -> names comid .)
    in              reduce using rule 58 (namelist -> names comid .)


state 115

    (10) stat -> varlist EQUALS explist .
    (59) explist -> explist . COMMA exp

    SEMI            reduce using rule 10 (stat -> varlist EQUALS explist .)
    return          reduce using rule 10 (stat -> varlist EQUALS explist .)
    break           reduce using rule 10 (stat -> varlist EQUALS explist .)
    for             reduce using rule 10 (stat -> varlist EQUALS explist .)
    while           reduce using rule 10 (stat -> varlist EQUALS explist .)
    repeat          reduce using rule 10 (stat -> varlist EQUALS explist .)
    do              reduce using rule 10 (stat -> varlist EQUALS explist .)
    function        reduce using rule 10 (stat -> varlist EQUALS explist .)
    local           reduce using rule 10 (stat -> varlist EQUALS explist .)
    if              reduce using rule 10 (stat -> varlist EQUALS explist .)
    LPAREN          reduce using rule 10 (stat -> varlist EQUALS explist .)
    ID              reduce using rule 10 (stat -> varlist EQUALS explist .)
    RESID           reduce using rule 10 (stat -> varlist EQUALS explist .)
    end             reduce using rule 10 (stat -> varlist EQUALS explist .)
    $end            reduce using rule 10 (stat -> varlist EQUALS explist .)
    until           reduce using rule 10 (stat -> varlist EQUALS explist .)
    else            reduce using rule 10 (stat -> varlist EQUALS explist .)
    elseif          reduce using rule 10 (stat -> varlist EQUALS explist .)
    COMMA           shift and go to state 168


state 116

    (56) var -> prefixexp . LSQUARE exp RSQUARE
    (57) var -> prefixexp . SDOT names
    (24) functioncall -> prefixexp . args
    (25) args -> . LPAREN RPAREN
    (26) args -> . LPAREN explist RPAREN
    (27) args -> . tableconstructor
    (28) args -> . STRING
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY

    LSQUARE         shift and go to state 46
    SDOT            shift and go to state 49
    LPAREN          shift and go to state 48
    STRING          shift and go to state 50
    LCURLY          shift and go to state 24

    tableconstructor               shift and go to state 45
    args                           shift and go to state 47

state 117

    (40) comvar -> COMMA var . comvar
    (116) prefixexp -> var .
    (40) comvar -> . COMMA var comvar
    (41) comvar -> . empty
    (115) empty -> .

    LSQUARE         reduce using rule 116 (prefixexp -> var .)
    SDOT            reduce using rule 116 (prefixexp -> var .)
    LPAREN          reduce using rule 116 (prefixexp -> var .)
    STRING          reduce using rule 116 (prefixexp -> var .)
    LCURLY          reduce using rule 116 (prefixexp -> var .)
    COMMA           shift and go to state 54
    EQUALS          reduce using rule 115 (empty -> .)

    comvar                         shift and go to state 173
    empty                          shift and go to state 56

state 118

    (17) stat -> function funcname funcbody .

    SEMI            reduce using rule 17 (stat -> function funcname funcbody .)
    return          reduce using rule 17 (stat -> function funcname funcbody .)
    break           reduce using rule 17 (stat -> function funcname funcbody .)
    for             reduce using rule 17 (stat -> function funcname funcbody .)
    while           reduce using rule 17 (stat -> function funcname funcbody .)
    repeat          reduce using rule 17 (stat -> function funcname funcbody .)
    do              reduce using rule 17 (stat -> function funcname funcbody .)
    function        reduce using rule 17 (stat -> function funcname funcbody .)
    local           reduce using rule 17 (stat -> function funcname funcbody .)
    if              reduce using rule 17 (stat -> function funcname funcbody .)
    LPAREN          reduce using rule 17 (stat -> function funcname funcbody .)
    ID              reduce using rule 17 (stat -> function funcname funcbody .)
    RESID           reduce using rule 17 (stat -> function funcname funcbody .)
    end             reduce using rule 17 (stat -> function funcname funcbody .)
    $end            reduce using rule 17 (stat -> function funcname funcbody .)
    until           reduce using rule 17 (stat -> function funcname funcbody .)
    else            reduce using rule 17 (stat -> function funcname funcbody .)
    elseif          reduce using rule 17 (stat -> function funcname funcbody .)


state 119

    (22) funcbody -> LPAREN . RPAREN block end
    (23) funcbody -> LPAREN . parlist RPAREN block end
    (29) parlist -> . namelist
    (30) parlist -> . namelist comtrp
    (31) parlist -> . TRPLDOTS
    (58) namelist -> . names comid
    (133) names -> . ID
    (134) names -> . RESID

    RPAREN          shift and go to state 177
    TRPLDOTS        shift and go to state 175
    ID              shift and go to state 18
    RESID           shift and go to state 1

    namelist                       shift and go to state 174
    parlist                        shift and go to state 176
    names                          shift and go to state 77

state 120

    (38) dotid -> SDOT . names dotid
    (133) names -> . ID
    (134) names -> . RESID

    ID              shift and go to state 18
    RESID           shift and go to state 1

    names                          shift and go to state 178

state 121

    (36) funcname -> names dotid . COLON

    COLON           shift and go to state 179


state 122

    (39) dotid -> empty .

    COLON           reduce using rule 39 (dotid -> empty .)


state 123

    (16) stat -> do block end .

    SEMI            reduce using rule 16 (stat -> do block end .)
    return          reduce using rule 16 (stat -> do block end .)
    break           reduce using rule 16 (stat -> do block end .)
    for             reduce using rule 16 (stat -> do block end .)
    while           reduce using rule 16 (stat -> do block end .)
    repeat          reduce using rule 16 (stat -> do block end .)
    do              reduce using rule 16 (stat -> do block end .)
    function        reduce using rule 16 (stat -> do block end .)
    local           reduce using rule 16 (stat -> do block end .)
    if              reduce using rule 16 (stat -> do block end .)
    LPAREN          reduce using rule 16 (stat -> do block end .)
    ID              reduce using rule 16 (stat -> do block end .)
    RESID           reduce using rule 16 (stat -> do block end .)
    end             reduce using rule 16 (stat -> do block end .)
    $end            reduce using rule 16 (stat -> do block end .)
    until           reduce using rule 16 (stat -> do block end .)
    else            reduce using rule 16 (stat -> do block end .)
    elseif          reduce using rule 16 (stat -> do block end .)


state 124

    (15) stat -> repeat block until . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 180
    var                            shift and go to state 29
    names                          shift and go to state 4

state 125

    (86) retexplist -> retexplist COMMA . retexp
    (88) retexp -> . nil
    (89) retexp -> . false
    (90) retexp -> . true
    (91) retexp -> . Number
    (92) retexp -> . STRING
    (93) retexp -> . TRPLDOTS
    (94) retexp -> . prefixexp
    (95) retexp -> . exp PLUS exp
    (96) retexp -> . exp MINUS exp
    (97) retexp -> . exp TIMES exp
    (98) retexp -> . exp DIVIDE exp
    (99) retexp -> . exp POWER exp
    (100) retexp -> . exp LT exp
    (101) retexp -> . exp LE exp
    (102) retexp -> . exp GT exp
    (103) retexp -> . exp GE exp
    (104) retexp -> . exp NE exp
    (105) retexp -> . exp CHECKEQ exp
    (106) retexp -> . exp and exp
    (107) retexp -> . exp or exp
    (108) retexp -> . exp MODULO exp
    (109) retexp -> . exp DBLDOTS exp
    (110) retexp -> . tableconstructor
    (111) retexp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 69
    false           shift and go to state 64
    true            shift and go to state 70
    STRING          shift and go to state 68
    TRPLDOTS        shift and go to state 65
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    function        shift and go to state 31
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 66
    tableconstructor               shift and go to state 63
    retexp                         shift and go to state 181
    Number                         shift and go to state 71
    unop                           shift and go to state 74
    exp                            shift and go to state 73
    var                            shift and go to state 29
    functioncall                   shift and go to state 38
    names                          shift and go to state 4

state 126

    (106) retexp -> exp and . exp
    (80) exp -> exp and . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 182
    var                            shift and go to state 29
    names                          shift and go to state 4

state 127

    (101) retexp -> exp LE . exp
    (75) exp -> exp LE . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 183
    var                            shift and go to state 29
    names                          shift and go to state 4

state 128

    (108) retexp -> exp MODULO . exp
    (82) exp -> exp MODULO . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 184
    var                            shift and go to state 29
    names                          shift and go to state 4

state 129

    (98) retexp -> exp DIVIDE . exp
    (72) exp -> exp DIVIDE . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 185
    var                            shift and go to state 29
    names                          shift and go to state 4

state 130

    (99) retexp -> exp POWER . exp
    (73) exp -> exp POWER . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 186
    var                            shift and go to state 29
    names                          shift and go to state 4

state 131

    (107) retexp -> exp or . exp
    (81) exp -> exp or . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 187
    var                            shift and go to state 29
    names                          shift and go to state 4

state 132

    (103) retexp -> exp GE . exp
    (77) exp -> exp GE . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 188
    var                            shift and go to state 29
    names                          shift and go to state 4

state 133

    (97) retexp -> exp TIMES . exp
    (71) exp -> exp TIMES . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 189
    var                            shift and go to state 29
    names                          shift and go to state 4

state 134

    (105) retexp -> exp CHECKEQ . exp
    (79) exp -> exp CHECKEQ . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 190
    var                            shift and go to state 29
    names                          shift and go to state 4

state 135

    (100) retexp -> exp LT . exp
    (74) exp -> exp LT . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 191
    var                            shift and go to state 29
    names                          shift and go to state 4

state 136

    (102) retexp -> exp GT . exp
    (76) exp -> exp GT . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 192
    var                            shift and go to state 29
    names                          shift and go to state 4

state 137

    (95) retexp -> exp PLUS . exp
    (69) exp -> exp PLUS . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 193
    var                            shift and go to state 29
    names                          shift and go to state 4

state 138

    (109) retexp -> exp DBLDOTS . exp
    (83) exp -> exp DBLDOTS . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 194
    var                            shift and go to state 29
    names                          shift and go to state 4

state 139

    (96) retexp -> exp MINUS . exp
    (70) exp -> exp MINUS . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 195
    var                            shift and go to state 29
    names                          shift and go to state 4

state 140

    (104) retexp -> exp NE . exp
    (78) exp -> exp NE . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 196
    var                            shift and go to state 29
    names                          shift and go to state 4

state 141

    (111) retexp -> unop exp .
    (85) exp -> unop exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 111 (retexp -> unop exp .)
    $end            reduce using rule 111 (retexp -> unop exp .)
    SEMI            reduce using rule 111 (retexp -> unop exp .)
    end             reduce using rule 111 (retexp -> unop exp .)
    until           reduce using rule 111 (retexp -> unop exp .)
    else            reduce using rule 111 (retexp -> unop exp .)
    elseif          reduce using rule 111 (retexp -> unop exp .)
    PLUS            reduce using rule 85 (exp -> unop exp .)
    MINUS           reduce using rule 85 (exp -> unop exp .)
    TIMES           reduce using rule 85 (exp -> unop exp .)
    DIVIDE          reduce using rule 85 (exp -> unop exp .)
    LT              reduce using rule 85 (exp -> unop exp .)
    LE              reduce using rule 85 (exp -> unop exp .)
    GT              reduce using rule 85 (exp -> unop exp .)
    GE              reduce using rule 85 (exp -> unop exp .)
    NE              reduce using rule 85 (exp -> unop exp .)
    CHECKEQ         reduce using rule 85 (exp -> unop exp .)
    and             reduce using rule 85 (exp -> unop exp .)
    or              reduce using rule 85 (exp -> unop exp .)
    MODULO          reduce using rule 85 (exp -> unop exp .)
    DBLDOTS         reduce using rule 85 (exp -> unop exp .)
    POWER           shift and go to state 88

  ! POWER           [ reduce using rule 85 (exp -> unop exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 100 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! MODULO          [ shift and go to state 96 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 142

    (18) stat -> local function names . funcbody
    (22) funcbody -> . LPAREN RPAREN block end
    (23) funcbody -> . LPAREN parlist RPAREN block end

    LPAREN          shift and go to state 119

    funcbody                       shift and go to state 197

state 143

    (20) stat -> local namelist EQUALS . explist
    (59) explist -> . explist COMMA exp
    (60) explist -> . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 108
    var                            shift and go to state 29
    explist                        shift and go to state 198
    names                          shift and go to state 4

state 144

    (14) stat -> while exp do . block end
    (9) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    functioncall                   shift and go to state 11
    stat                           shift and go to state 14
    block                          shift and go to state 199
    sdash                          shift and go to state 59

state 145

    (129) field -> names EQUALS . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    names                          shift and go to state 4
    exp                            shift and go to state 200
    var                            shift and go to state 29

state 146

    (124) fieldlist -> field fieldseplist . fieldsep
    (125) fieldlist -> field fieldseplist .
    (126) fieldseplist -> fieldseplist . fieldsep field
    (131) fieldsep -> . COMMA
    (132) fieldsep -> . SEMI

    RCURLY          reduce using rule 125 (fieldlist -> field fieldseplist .)
    COMMA           shift and go to state 202
    SEMI            shift and go to state 203

    fieldsep                       shift and go to state 201

state 147

    (127) fieldseplist -> empty .

    COMMA           reduce using rule 127 (fieldseplist -> empty .)
    SEMI            reduce using rule 127 (fieldseplist -> empty .)
    RCURLY          reduce using rule 127 (fieldseplist -> empty .)


state 148

    (122) tableconstructor -> LCURLY fieldlist RCURLY .

    PLUS            reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    MINUS           reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    TIMES           reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    DIVIDE          reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    POWER           reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LT              reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LE              reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    GT              reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    GE              reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    NE              reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    CHECKEQ         reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    and             reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    or              reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    MODULO          reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    DBLDOTS         reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    COMMA           reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    $end            reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    SEMI            reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    end             reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    until           reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    else            reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    elseif          reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RPAREN          reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    then            reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    do              reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RCURLY          reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RSQUARE         reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    return          reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    break           reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    for             reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    while           reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    repeat          reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    function        reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    local           reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    if              reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LPAREN          reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    ID              reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    RESID           reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LSQUARE         reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    SDOT            reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    STRING          reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)
    LCURLY          reduce using rule 122 (tableconstructor -> LCURLY fieldlist RCURLY .)


state 149

    (128) field -> LSQUARE exp . RSQUARE EQUALS exp
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    RSQUARE         shift and go to state 204
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 150

    (80) exp -> exp and exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    LT              reduce using rule 80 (exp -> exp and exp .)
    LE              reduce using rule 80 (exp -> exp and exp .)
    GT              reduce using rule 80 (exp -> exp and exp .)
    GE              reduce using rule 80 (exp -> exp and exp .)
    NE              reduce using rule 80 (exp -> exp and exp .)
    CHECKEQ         reduce using rule 80 (exp -> exp and exp .)
    and             reduce using rule 80 (exp -> exp and exp .)
    or              reduce using rule 80 (exp -> exp and exp .)
    RPAREN          reduce using rule 80 (exp -> exp and exp .)
    then            reduce using rule 80 (exp -> exp and exp .)
    do              reduce using rule 80 (exp -> exp and exp .)
    COMMA           reduce using rule 80 (exp -> exp and exp .)
    SEMI            reduce using rule 80 (exp -> exp and exp .)
    RCURLY          reduce using rule 80 (exp -> exp and exp .)
    RSQUARE         reduce using rule 80 (exp -> exp and exp .)
    return          reduce using rule 80 (exp -> exp and exp .)
    break           reduce using rule 80 (exp -> exp and exp .)
    for             reduce using rule 80 (exp -> exp and exp .)
    while           reduce using rule 80 (exp -> exp and exp .)
    repeat          reduce using rule 80 (exp -> exp and exp .)
    function        reduce using rule 80 (exp -> exp and exp .)
    local           reduce using rule 80 (exp -> exp and exp .)
    if              reduce using rule 80 (exp -> exp and exp .)
    LPAREN          reduce using rule 80 (exp -> exp and exp .)
    ID              reduce using rule 80 (exp -> exp and exp .)
    RESID           reduce using rule 80 (exp -> exp and exp .)
    $end            reduce using rule 80 (exp -> exp and exp .)
    end             reduce using rule 80 (exp -> exp and exp .)
    until           reduce using rule 80 (exp -> exp and exp .)
    else            reduce using rule 80 (exp -> exp and exp .)
    elseif          reduce using rule 80 (exp -> exp and exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 80 (exp -> exp and exp .) ]
  ! MINUS           [ reduce using rule 80 (exp -> exp and exp .) ]
  ! TIMES           [ reduce using rule 80 (exp -> exp and exp .) ]
  ! DIVIDE          [ reduce using rule 80 (exp -> exp and exp .) ]
  ! POWER           [ reduce using rule 80 (exp -> exp and exp .) ]
  ! MODULO          [ reduce using rule 80 (exp -> exp and exp .) ]
  ! DBLDOTS         [ reduce using rule 80 (exp -> exp and exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 151

    (75) exp -> exp LE exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    LT              reduce using rule 75 (exp -> exp LE exp .)
    LE              reduce using rule 75 (exp -> exp LE exp .)
    GT              reduce using rule 75 (exp -> exp LE exp .)
    GE              reduce using rule 75 (exp -> exp LE exp .)
    NE              reduce using rule 75 (exp -> exp LE exp .)
    CHECKEQ         reduce using rule 75 (exp -> exp LE exp .)
    and             reduce using rule 75 (exp -> exp LE exp .)
    or              reduce using rule 75 (exp -> exp LE exp .)
    RPAREN          reduce using rule 75 (exp -> exp LE exp .)
    then            reduce using rule 75 (exp -> exp LE exp .)
    do              reduce using rule 75 (exp -> exp LE exp .)
    COMMA           reduce using rule 75 (exp -> exp LE exp .)
    SEMI            reduce using rule 75 (exp -> exp LE exp .)
    RCURLY          reduce using rule 75 (exp -> exp LE exp .)
    RSQUARE         reduce using rule 75 (exp -> exp LE exp .)
    return          reduce using rule 75 (exp -> exp LE exp .)
    break           reduce using rule 75 (exp -> exp LE exp .)
    for             reduce using rule 75 (exp -> exp LE exp .)
    while           reduce using rule 75 (exp -> exp LE exp .)
    repeat          reduce using rule 75 (exp -> exp LE exp .)
    function        reduce using rule 75 (exp -> exp LE exp .)
    local           reduce using rule 75 (exp -> exp LE exp .)
    if              reduce using rule 75 (exp -> exp LE exp .)
    LPAREN          reduce using rule 75 (exp -> exp LE exp .)
    ID              reduce using rule 75 (exp -> exp LE exp .)
    RESID           reduce using rule 75 (exp -> exp LE exp .)
    $end            reduce using rule 75 (exp -> exp LE exp .)
    end             reduce using rule 75 (exp -> exp LE exp .)
    until           reduce using rule 75 (exp -> exp LE exp .)
    else            reduce using rule 75 (exp -> exp LE exp .)
    elseif          reduce using rule 75 (exp -> exp LE exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! POWER           [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! MODULO          [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! DBLDOTS         [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 152

    (73) exp -> exp POWER exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 73 (exp -> exp POWER exp .)
    MINUS           reduce using rule 73 (exp -> exp POWER exp .)
    TIMES           reduce using rule 73 (exp -> exp POWER exp .)
    DIVIDE          reduce using rule 73 (exp -> exp POWER exp .)
    LT              reduce using rule 73 (exp -> exp POWER exp .)
    LE              reduce using rule 73 (exp -> exp POWER exp .)
    GT              reduce using rule 73 (exp -> exp POWER exp .)
    GE              reduce using rule 73 (exp -> exp POWER exp .)
    NE              reduce using rule 73 (exp -> exp POWER exp .)
    CHECKEQ         reduce using rule 73 (exp -> exp POWER exp .)
    and             reduce using rule 73 (exp -> exp POWER exp .)
    or              reduce using rule 73 (exp -> exp POWER exp .)
    MODULO          reduce using rule 73 (exp -> exp POWER exp .)
    DBLDOTS         reduce using rule 73 (exp -> exp POWER exp .)
    RPAREN          reduce using rule 73 (exp -> exp POWER exp .)
    then            reduce using rule 73 (exp -> exp POWER exp .)
    do              reduce using rule 73 (exp -> exp POWER exp .)
    COMMA           reduce using rule 73 (exp -> exp POWER exp .)
    SEMI            reduce using rule 73 (exp -> exp POWER exp .)
    RCURLY          reduce using rule 73 (exp -> exp POWER exp .)
    RSQUARE         reduce using rule 73 (exp -> exp POWER exp .)
    return          reduce using rule 73 (exp -> exp POWER exp .)
    break           reduce using rule 73 (exp -> exp POWER exp .)
    for             reduce using rule 73 (exp -> exp POWER exp .)
    while           reduce using rule 73 (exp -> exp POWER exp .)
    repeat          reduce using rule 73 (exp -> exp POWER exp .)
    function        reduce using rule 73 (exp -> exp POWER exp .)
    local           reduce using rule 73 (exp -> exp POWER exp .)
    if              reduce using rule 73 (exp -> exp POWER exp .)
    LPAREN          reduce using rule 73 (exp -> exp POWER exp .)
    ID              reduce using rule 73 (exp -> exp POWER exp .)
    RESID           reduce using rule 73 (exp -> exp POWER exp .)
    $end            reduce using rule 73 (exp -> exp POWER exp .)
    end             reduce using rule 73 (exp -> exp POWER exp .)
    until           reduce using rule 73 (exp -> exp POWER exp .)
    else            reduce using rule 73 (exp -> exp POWER exp .)
    elseif          reduce using rule 73 (exp -> exp POWER exp .)
    POWER           shift and go to state 88

  ! POWER           [ reduce using rule 73 (exp -> exp POWER exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 100 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! MODULO          [ shift and go to state 96 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 153

    (81) exp -> exp or exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    LT              reduce using rule 81 (exp -> exp or exp .)
    LE              reduce using rule 81 (exp -> exp or exp .)
    GT              reduce using rule 81 (exp -> exp or exp .)
    GE              reduce using rule 81 (exp -> exp or exp .)
    NE              reduce using rule 81 (exp -> exp or exp .)
    CHECKEQ         reduce using rule 81 (exp -> exp or exp .)
    and             reduce using rule 81 (exp -> exp or exp .)
    or              reduce using rule 81 (exp -> exp or exp .)
    RPAREN          reduce using rule 81 (exp -> exp or exp .)
    then            reduce using rule 81 (exp -> exp or exp .)
    do              reduce using rule 81 (exp -> exp or exp .)
    COMMA           reduce using rule 81 (exp -> exp or exp .)
    SEMI            reduce using rule 81 (exp -> exp or exp .)
    RCURLY          reduce using rule 81 (exp -> exp or exp .)
    RSQUARE         reduce using rule 81 (exp -> exp or exp .)
    return          reduce using rule 81 (exp -> exp or exp .)
    break           reduce using rule 81 (exp -> exp or exp .)
    for             reduce using rule 81 (exp -> exp or exp .)
    while           reduce using rule 81 (exp -> exp or exp .)
    repeat          reduce using rule 81 (exp -> exp or exp .)
    function        reduce using rule 81 (exp -> exp or exp .)
    local           reduce using rule 81 (exp -> exp or exp .)
    if              reduce using rule 81 (exp -> exp or exp .)
    LPAREN          reduce using rule 81 (exp -> exp or exp .)
    ID              reduce using rule 81 (exp -> exp or exp .)
    RESID           reduce using rule 81 (exp -> exp or exp .)
    $end            reduce using rule 81 (exp -> exp or exp .)
    end             reduce using rule 81 (exp -> exp or exp .)
    until           reduce using rule 81 (exp -> exp or exp .)
    else            reduce using rule 81 (exp -> exp or exp .)
    elseif          reduce using rule 81 (exp -> exp or exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 81 (exp -> exp or exp .) ]
  ! MINUS           [ reduce using rule 81 (exp -> exp or exp .) ]
  ! TIMES           [ reduce using rule 81 (exp -> exp or exp .) ]
  ! DIVIDE          [ reduce using rule 81 (exp -> exp or exp .) ]
  ! POWER           [ reduce using rule 81 (exp -> exp or exp .) ]
  ! MODULO          [ reduce using rule 81 (exp -> exp or exp .) ]
  ! DBLDOTS         [ reduce using rule 81 (exp -> exp or exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 154

    (77) exp -> exp GE exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    LT              reduce using rule 77 (exp -> exp GE exp .)
    LE              reduce using rule 77 (exp -> exp GE exp .)
    GT              reduce using rule 77 (exp -> exp GE exp .)
    GE              reduce using rule 77 (exp -> exp GE exp .)
    NE              reduce using rule 77 (exp -> exp GE exp .)
    CHECKEQ         reduce using rule 77 (exp -> exp GE exp .)
    and             reduce using rule 77 (exp -> exp GE exp .)
    or              reduce using rule 77 (exp -> exp GE exp .)
    RPAREN          reduce using rule 77 (exp -> exp GE exp .)
    then            reduce using rule 77 (exp -> exp GE exp .)
    do              reduce using rule 77 (exp -> exp GE exp .)
    COMMA           reduce using rule 77 (exp -> exp GE exp .)
    SEMI            reduce using rule 77 (exp -> exp GE exp .)
    RCURLY          reduce using rule 77 (exp -> exp GE exp .)
    RSQUARE         reduce using rule 77 (exp -> exp GE exp .)
    return          reduce using rule 77 (exp -> exp GE exp .)
    break           reduce using rule 77 (exp -> exp GE exp .)
    for             reduce using rule 77 (exp -> exp GE exp .)
    while           reduce using rule 77 (exp -> exp GE exp .)
    repeat          reduce using rule 77 (exp -> exp GE exp .)
    function        reduce using rule 77 (exp -> exp GE exp .)
    local           reduce using rule 77 (exp -> exp GE exp .)
    if              reduce using rule 77 (exp -> exp GE exp .)
    LPAREN          reduce using rule 77 (exp -> exp GE exp .)
    ID              reduce using rule 77 (exp -> exp GE exp .)
    RESID           reduce using rule 77 (exp -> exp GE exp .)
    $end            reduce using rule 77 (exp -> exp GE exp .)
    end             reduce using rule 77 (exp -> exp GE exp .)
    until           reduce using rule 77 (exp -> exp GE exp .)
    else            reduce using rule 77 (exp -> exp GE exp .)
    elseif          reduce using rule 77 (exp -> exp GE exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! MINUS           [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! TIMES           [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! DIVIDE          [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! POWER           [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! MODULO          [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! DBLDOTS         [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 155

    (71) exp -> exp TIMES exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 71 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 71 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 71 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 71 (exp -> exp TIMES exp .)
    LT              reduce using rule 71 (exp -> exp TIMES exp .)
    LE              reduce using rule 71 (exp -> exp TIMES exp .)
    GT              reduce using rule 71 (exp -> exp TIMES exp .)
    GE              reduce using rule 71 (exp -> exp TIMES exp .)
    NE              reduce using rule 71 (exp -> exp TIMES exp .)
    CHECKEQ         reduce using rule 71 (exp -> exp TIMES exp .)
    and             reduce using rule 71 (exp -> exp TIMES exp .)
    or              reduce using rule 71 (exp -> exp TIMES exp .)
    MODULO          reduce using rule 71 (exp -> exp TIMES exp .)
    DBLDOTS         reduce using rule 71 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 71 (exp -> exp TIMES exp .)
    then            reduce using rule 71 (exp -> exp TIMES exp .)
    do              reduce using rule 71 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 71 (exp -> exp TIMES exp .)
    SEMI            reduce using rule 71 (exp -> exp TIMES exp .)
    RCURLY          reduce using rule 71 (exp -> exp TIMES exp .)
    RSQUARE         reduce using rule 71 (exp -> exp TIMES exp .)
    return          reduce using rule 71 (exp -> exp TIMES exp .)
    break           reduce using rule 71 (exp -> exp TIMES exp .)
    for             reduce using rule 71 (exp -> exp TIMES exp .)
    while           reduce using rule 71 (exp -> exp TIMES exp .)
    repeat          reduce using rule 71 (exp -> exp TIMES exp .)
    function        reduce using rule 71 (exp -> exp TIMES exp .)
    local           reduce using rule 71 (exp -> exp TIMES exp .)
    if              reduce using rule 71 (exp -> exp TIMES exp .)
    LPAREN          reduce using rule 71 (exp -> exp TIMES exp .)
    ID              reduce using rule 71 (exp -> exp TIMES exp .)
    RESID           reduce using rule 71 (exp -> exp TIMES exp .)
    $end            reduce using rule 71 (exp -> exp TIMES exp .)
    end             reduce using rule 71 (exp -> exp TIMES exp .)
    until           reduce using rule 71 (exp -> exp TIMES exp .)
    else            reduce using rule 71 (exp -> exp TIMES exp .)
    elseif          reduce using rule 71 (exp -> exp TIMES exp .)
    POWER           shift and go to state 88

  ! POWER           [ reduce using rule 71 (exp -> exp TIMES exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 100 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! MODULO          [ shift and go to state 96 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 156

    (79) exp -> exp CHECKEQ exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    LT              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    LE              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    GT              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    GE              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    NE              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    CHECKEQ         reduce using rule 79 (exp -> exp CHECKEQ exp .)
    and             reduce using rule 79 (exp -> exp CHECKEQ exp .)
    or              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    RPAREN          reduce using rule 79 (exp -> exp CHECKEQ exp .)
    then            reduce using rule 79 (exp -> exp CHECKEQ exp .)
    do              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    COMMA           reduce using rule 79 (exp -> exp CHECKEQ exp .)
    SEMI            reduce using rule 79 (exp -> exp CHECKEQ exp .)
    RCURLY          reduce using rule 79 (exp -> exp CHECKEQ exp .)
    RSQUARE         reduce using rule 79 (exp -> exp CHECKEQ exp .)
    return          reduce using rule 79 (exp -> exp CHECKEQ exp .)
    break           reduce using rule 79 (exp -> exp CHECKEQ exp .)
    for             reduce using rule 79 (exp -> exp CHECKEQ exp .)
    while           reduce using rule 79 (exp -> exp CHECKEQ exp .)
    repeat          reduce using rule 79 (exp -> exp CHECKEQ exp .)
    function        reduce using rule 79 (exp -> exp CHECKEQ exp .)
    local           reduce using rule 79 (exp -> exp CHECKEQ exp .)
    if              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    LPAREN          reduce using rule 79 (exp -> exp CHECKEQ exp .)
    ID              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    RESID           reduce using rule 79 (exp -> exp CHECKEQ exp .)
    $end            reduce using rule 79 (exp -> exp CHECKEQ exp .)
    end             reduce using rule 79 (exp -> exp CHECKEQ exp .)
    until           reduce using rule 79 (exp -> exp CHECKEQ exp .)
    else            reduce using rule 79 (exp -> exp CHECKEQ exp .)
    elseif          reduce using rule 79 (exp -> exp CHECKEQ exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! MINUS           [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! TIMES           [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! DIVIDE          [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! POWER           [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! MODULO          [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! DBLDOTS         [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 157

    (74) exp -> exp LT exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    LT              reduce using rule 74 (exp -> exp LT exp .)
    LE              reduce using rule 74 (exp -> exp LT exp .)
    GT              reduce using rule 74 (exp -> exp LT exp .)
    GE              reduce using rule 74 (exp -> exp LT exp .)
    NE              reduce using rule 74 (exp -> exp LT exp .)
    CHECKEQ         reduce using rule 74 (exp -> exp LT exp .)
    and             reduce using rule 74 (exp -> exp LT exp .)
    or              reduce using rule 74 (exp -> exp LT exp .)
    RPAREN          reduce using rule 74 (exp -> exp LT exp .)
    then            reduce using rule 74 (exp -> exp LT exp .)
    do              reduce using rule 74 (exp -> exp LT exp .)
    COMMA           reduce using rule 74 (exp -> exp LT exp .)
    SEMI            reduce using rule 74 (exp -> exp LT exp .)
    RCURLY          reduce using rule 74 (exp -> exp LT exp .)
    RSQUARE         reduce using rule 74 (exp -> exp LT exp .)
    return          reduce using rule 74 (exp -> exp LT exp .)
    break           reduce using rule 74 (exp -> exp LT exp .)
    for             reduce using rule 74 (exp -> exp LT exp .)
    while           reduce using rule 74 (exp -> exp LT exp .)
    repeat          reduce using rule 74 (exp -> exp LT exp .)
    function        reduce using rule 74 (exp -> exp LT exp .)
    local           reduce using rule 74 (exp -> exp LT exp .)
    if              reduce using rule 74 (exp -> exp LT exp .)
    LPAREN          reduce using rule 74 (exp -> exp LT exp .)
    ID              reduce using rule 74 (exp -> exp LT exp .)
    RESID           reduce using rule 74 (exp -> exp LT exp .)
    $end            reduce using rule 74 (exp -> exp LT exp .)
    end             reduce using rule 74 (exp -> exp LT exp .)
    until           reduce using rule 74 (exp -> exp LT exp .)
    else            reduce using rule 74 (exp -> exp LT exp .)
    elseif          reduce using rule 74 (exp -> exp LT exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! TIMES           [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! POWER           [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! MODULO          [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! DBLDOTS         [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 158

    (76) exp -> exp GT exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    LT              reduce using rule 76 (exp -> exp GT exp .)
    LE              reduce using rule 76 (exp -> exp GT exp .)
    GT              reduce using rule 76 (exp -> exp GT exp .)
    GE              reduce using rule 76 (exp -> exp GT exp .)
    NE              reduce using rule 76 (exp -> exp GT exp .)
    CHECKEQ         reduce using rule 76 (exp -> exp GT exp .)
    and             reduce using rule 76 (exp -> exp GT exp .)
    or              reduce using rule 76 (exp -> exp GT exp .)
    RPAREN          reduce using rule 76 (exp -> exp GT exp .)
    then            reduce using rule 76 (exp -> exp GT exp .)
    do              reduce using rule 76 (exp -> exp GT exp .)
    COMMA           reduce using rule 76 (exp -> exp GT exp .)
    SEMI            reduce using rule 76 (exp -> exp GT exp .)
    RCURLY          reduce using rule 76 (exp -> exp GT exp .)
    RSQUARE         reduce using rule 76 (exp -> exp GT exp .)
    return          reduce using rule 76 (exp -> exp GT exp .)
    break           reduce using rule 76 (exp -> exp GT exp .)
    for             reduce using rule 76 (exp -> exp GT exp .)
    while           reduce using rule 76 (exp -> exp GT exp .)
    repeat          reduce using rule 76 (exp -> exp GT exp .)
    function        reduce using rule 76 (exp -> exp GT exp .)
    local           reduce using rule 76 (exp -> exp GT exp .)
    if              reduce using rule 76 (exp -> exp GT exp .)
    LPAREN          reduce using rule 76 (exp -> exp GT exp .)
    ID              reduce using rule 76 (exp -> exp GT exp .)
    RESID           reduce using rule 76 (exp -> exp GT exp .)
    $end            reduce using rule 76 (exp -> exp GT exp .)
    end             reduce using rule 76 (exp -> exp GT exp .)
    until           reduce using rule 76 (exp -> exp GT exp .)
    else            reduce using rule 76 (exp -> exp GT exp .)
    elseif          reduce using rule 76 (exp -> exp GT exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! TIMES           [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! POWER           [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! MODULO          [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! DBLDOTS         [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 159

    (69) exp -> exp PLUS exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 69 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 69 (exp -> exp PLUS exp .)
    LT              reduce using rule 69 (exp -> exp PLUS exp .)
    LE              reduce using rule 69 (exp -> exp PLUS exp .)
    GT              reduce using rule 69 (exp -> exp PLUS exp .)
    GE              reduce using rule 69 (exp -> exp PLUS exp .)
    NE              reduce using rule 69 (exp -> exp PLUS exp .)
    CHECKEQ         reduce using rule 69 (exp -> exp PLUS exp .)
    and             reduce using rule 69 (exp -> exp PLUS exp .)
    or              reduce using rule 69 (exp -> exp PLUS exp .)
    DBLDOTS         reduce using rule 69 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 69 (exp -> exp PLUS exp .)
    then            reduce using rule 69 (exp -> exp PLUS exp .)
    do              reduce using rule 69 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 69 (exp -> exp PLUS exp .)
    SEMI            reduce using rule 69 (exp -> exp PLUS exp .)
    RCURLY          reduce using rule 69 (exp -> exp PLUS exp .)
    RSQUARE         reduce using rule 69 (exp -> exp PLUS exp .)
    return          reduce using rule 69 (exp -> exp PLUS exp .)
    break           reduce using rule 69 (exp -> exp PLUS exp .)
    for             reduce using rule 69 (exp -> exp PLUS exp .)
    while           reduce using rule 69 (exp -> exp PLUS exp .)
    repeat          reduce using rule 69 (exp -> exp PLUS exp .)
    function        reduce using rule 69 (exp -> exp PLUS exp .)
    local           reduce using rule 69 (exp -> exp PLUS exp .)
    if              reduce using rule 69 (exp -> exp PLUS exp .)
    LPAREN          reduce using rule 69 (exp -> exp PLUS exp .)
    ID              reduce using rule 69 (exp -> exp PLUS exp .)
    RESID           reduce using rule 69 (exp -> exp PLUS exp .)
    $end            reduce using rule 69 (exp -> exp PLUS exp .)
    end             reduce using rule 69 (exp -> exp PLUS exp .)
    until           reduce using rule 69 (exp -> exp PLUS exp .)
    else            reduce using rule 69 (exp -> exp PLUS exp .)
    elseif          reduce using rule 69 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96

  ! TIMES           [ reduce using rule 69 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 69 (exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 69 (exp -> exp PLUS exp .) ]
  ! MODULO          [ reduce using rule 69 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 160

    (82) exp -> exp MODULO exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 82 (exp -> exp MODULO exp .)
    MINUS           reduce using rule 82 (exp -> exp MODULO exp .)
    TIMES           reduce using rule 82 (exp -> exp MODULO exp .)
    DIVIDE          reduce using rule 82 (exp -> exp MODULO exp .)
    LT              reduce using rule 82 (exp -> exp MODULO exp .)
    LE              reduce using rule 82 (exp -> exp MODULO exp .)
    GT              reduce using rule 82 (exp -> exp MODULO exp .)
    GE              reduce using rule 82 (exp -> exp MODULO exp .)
    NE              reduce using rule 82 (exp -> exp MODULO exp .)
    CHECKEQ         reduce using rule 82 (exp -> exp MODULO exp .)
    and             reduce using rule 82 (exp -> exp MODULO exp .)
    or              reduce using rule 82 (exp -> exp MODULO exp .)
    MODULO          reduce using rule 82 (exp -> exp MODULO exp .)
    DBLDOTS         reduce using rule 82 (exp -> exp MODULO exp .)
    RPAREN          reduce using rule 82 (exp -> exp MODULO exp .)
    then            reduce using rule 82 (exp -> exp MODULO exp .)
    do              reduce using rule 82 (exp -> exp MODULO exp .)
    COMMA           reduce using rule 82 (exp -> exp MODULO exp .)
    SEMI            reduce using rule 82 (exp -> exp MODULO exp .)
    RCURLY          reduce using rule 82 (exp -> exp MODULO exp .)
    RSQUARE         reduce using rule 82 (exp -> exp MODULO exp .)
    return          reduce using rule 82 (exp -> exp MODULO exp .)
    break           reduce using rule 82 (exp -> exp MODULO exp .)
    for             reduce using rule 82 (exp -> exp MODULO exp .)
    while           reduce using rule 82 (exp -> exp MODULO exp .)
    repeat          reduce using rule 82 (exp -> exp MODULO exp .)
    function        reduce using rule 82 (exp -> exp MODULO exp .)
    local           reduce using rule 82 (exp -> exp MODULO exp .)
    if              reduce using rule 82 (exp -> exp MODULO exp .)
    LPAREN          reduce using rule 82 (exp -> exp MODULO exp .)
    ID              reduce using rule 82 (exp -> exp MODULO exp .)
    RESID           reduce using rule 82 (exp -> exp MODULO exp .)
    $end            reduce using rule 82 (exp -> exp MODULO exp .)
    end             reduce using rule 82 (exp -> exp MODULO exp .)
    until           reduce using rule 82 (exp -> exp MODULO exp .)
    else            reduce using rule 82 (exp -> exp MODULO exp .)
    elseif          reduce using rule 82 (exp -> exp MODULO exp .)
    POWER           shift and go to state 88

  ! POWER           [ reduce using rule 82 (exp -> exp MODULO exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 100 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! MODULO          [ shift and go to state 96 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 161

    (83) exp -> exp DBLDOTS exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    LT              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    LE              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    GT              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    GE              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    NE              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    CHECKEQ         reduce using rule 83 (exp -> exp DBLDOTS exp .)
    and             reduce using rule 83 (exp -> exp DBLDOTS exp .)
    or              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    RPAREN          reduce using rule 83 (exp -> exp DBLDOTS exp .)
    then            reduce using rule 83 (exp -> exp DBLDOTS exp .)
    do              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    COMMA           reduce using rule 83 (exp -> exp DBLDOTS exp .)
    SEMI            reduce using rule 83 (exp -> exp DBLDOTS exp .)
    RCURLY          reduce using rule 83 (exp -> exp DBLDOTS exp .)
    RSQUARE         reduce using rule 83 (exp -> exp DBLDOTS exp .)
    return          reduce using rule 83 (exp -> exp DBLDOTS exp .)
    break           reduce using rule 83 (exp -> exp DBLDOTS exp .)
    for             reduce using rule 83 (exp -> exp DBLDOTS exp .)
    while           reduce using rule 83 (exp -> exp DBLDOTS exp .)
    repeat          reduce using rule 83 (exp -> exp DBLDOTS exp .)
    function        reduce using rule 83 (exp -> exp DBLDOTS exp .)
    local           reduce using rule 83 (exp -> exp DBLDOTS exp .)
    if              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    LPAREN          reduce using rule 83 (exp -> exp DBLDOTS exp .)
    ID              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    RESID           reduce using rule 83 (exp -> exp DBLDOTS exp .)
    $end            reduce using rule 83 (exp -> exp DBLDOTS exp .)
    end             reduce using rule 83 (exp -> exp DBLDOTS exp .)
    until           reduce using rule 83 (exp -> exp DBLDOTS exp .)
    else            reduce using rule 83 (exp -> exp DBLDOTS exp .)
    elseif          reduce using rule 83 (exp -> exp DBLDOTS exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! MINUS           [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! TIMES           [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! DIVIDE          [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! POWER           [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! MODULO          [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! DBLDOTS         [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 162

    (70) exp -> exp MINUS exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 70 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 70 (exp -> exp MINUS exp .)
    LT              reduce using rule 70 (exp -> exp MINUS exp .)
    LE              reduce using rule 70 (exp -> exp MINUS exp .)
    GT              reduce using rule 70 (exp -> exp MINUS exp .)
    GE              reduce using rule 70 (exp -> exp MINUS exp .)
    NE              reduce using rule 70 (exp -> exp MINUS exp .)
    CHECKEQ         reduce using rule 70 (exp -> exp MINUS exp .)
    and             reduce using rule 70 (exp -> exp MINUS exp .)
    or              reduce using rule 70 (exp -> exp MINUS exp .)
    DBLDOTS         reduce using rule 70 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 70 (exp -> exp MINUS exp .)
    then            reduce using rule 70 (exp -> exp MINUS exp .)
    do              reduce using rule 70 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 70 (exp -> exp MINUS exp .)
    SEMI            reduce using rule 70 (exp -> exp MINUS exp .)
    RCURLY          reduce using rule 70 (exp -> exp MINUS exp .)
    RSQUARE         reduce using rule 70 (exp -> exp MINUS exp .)
    return          reduce using rule 70 (exp -> exp MINUS exp .)
    break           reduce using rule 70 (exp -> exp MINUS exp .)
    for             reduce using rule 70 (exp -> exp MINUS exp .)
    while           reduce using rule 70 (exp -> exp MINUS exp .)
    repeat          reduce using rule 70 (exp -> exp MINUS exp .)
    function        reduce using rule 70 (exp -> exp MINUS exp .)
    local           reduce using rule 70 (exp -> exp MINUS exp .)
    if              reduce using rule 70 (exp -> exp MINUS exp .)
    LPAREN          reduce using rule 70 (exp -> exp MINUS exp .)
    ID              reduce using rule 70 (exp -> exp MINUS exp .)
    RESID           reduce using rule 70 (exp -> exp MINUS exp .)
    $end            reduce using rule 70 (exp -> exp MINUS exp .)
    end             reduce using rule 70 (exp -> exp MINUS exp .)
    until           reduce using rule 70 (exp -> exp MINUS exp .)
    else            reduce using rule 70 (exp -> exp MINUS exp .)
    elseif          reduce using rule 70 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96

  ! TIMES           [ reduce using rule 70 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 70 (exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 70 (exp -> exp MINUS exp .) ]
  ! MODULO          [ reduce using rule 70 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 163

    (78) exp -> exp NE exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    LT              reduce using rule 78 (exp -> exp NE exp .)
    LE              reduce using rule 78 (exp -> exp NE exp .)
    GT              reduce using rule 78 (exp -> exp NE exp .)
    GE              reduce using rule 78 (exp -> exp NE exp .)
    NE              reduce using rule 78 (exp -> exp NE exp .)
    CHECKEQ         reduce using rule 78 (exp -> exp NE exp .)
    and             reduce using rule 78 (exp -> exp NE exp .)
    or              reduce using rule 78 (exp -> exp NE exp .)
    RPAREN          reduce using rule 78 (exp -> exp NE exp .)
    then            reduce using rule 78 (exp -> exp NE exp .)
    do              reduce using rule 78 (exp -> exp NE exp .)
    COMMA           reduce using rule 78 (exp -> exp NE exp .)
    SEMI            reduce using rule 78 (exp -> exp NE exp .)
    RCURLY          reduce using rule 78 (exp -> exp NE exp .)
    RSQUARE         reduce using rule 78 (exp -> exp NE exp .)
    return          reduce using rule 78 (exp -> exp NE exp .)
    break           reduce using rule 78 (exp -> exp NE exp .)
    for             reduce using rule 78 (exp -> exp NE exp .)
    while           reduce using rule 78 (exp -> exp NE exp .)
    repeat          reduce using rule 78 (exp -> exp NE exp .)
    function        reduce using rule 78 (exp -> exp NE exp .)
    local           reduce using rule 78 (exp -> exp NE exp .)
    if              reduce using rule 78 (exp -> exp NE exp .)
    LPAREN          reduce using rule 78 (exp -> exp NE exp .)
    ID              reduce using rule 78 (exp -> exp NE exp .)
    RESID           reduce using rule 78 (exp -> exp NE exp .)
    $end            reduce using rule 78 (exp -> exp NE exp .)
    end             reduce using rule 78 (exp -> exp NE exp .)
    until           reduce using rule 78 (exp -> exp NE exp .)
    else            reduce using rule 78 (exp -> exp NE exp .)
    elseif          reduce using rule 78 (exp -> exp NE exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! MINUS           [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! TIMES           [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! DIVIDE          [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! POWER           [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! MODULO          [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! DBLDOTS         [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 164

    (72) exp -> exp DIVIDE exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    PLUS            reduce using rule 72 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 72 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 72 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 72 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 72 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 72 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 72 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 72 (exp -> exp DIVIDE exp .)
    NE              reduce using rule 72 (exp -> exp DIVIDE exp .)
    CHECKEQ         reduce using rule 72 (exp -> exp DIVIDE exp .)
    and             reduce using rule 72 (exp -> exp DIVIDE exp .)
    or              reduce using rule 72 (exp -> exp DIVIDE exp .)
    MODULO          reduce using rule 72 (exp -> exp DIVIDE exp .)
    DBLDOTS         reduce using rule 72 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 72 (exp -> exp DIVIDE exp .)
    then            reduce using rule 72 (exp -> exp DIVIDE exp .)
    do              reduce using rule 72 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 72 (exp -> exp DIVIDE exp .)
    SEMI            reduce using rule 72 (exp -> exp DIVIDE exp .)
    RCURLY          reduce using rule 72 (exp -> exp DIVIDE exp .)
    RSQUARE         reduce using rule 72 (exp -> exp DIVIDE exp .)
    return          reduce using rule 72 (exp -> exp DIVIDE exp .)
    break           reduce using rule 72 (exp -> exp DIVIDE exp .)
    for             reduce using rule 72 (exp -> exp DIVIDE exp .)
    while           reduce using rule 72 (exp -> exp DIVIDE exp .)
    repeat          reduce using rule 72 (exp -> exp DIVIDE exp .)
    function        reduce using rule 72 (exp -> exp DIVIDE exp .)
    local           reduce using rule 72 (exp -> exp DIVIDE exp .)
    if              reduce using rule 72 (exp -> exp DIVIDE exp .)
    LPAREN          reduce using rule 72 (exp -> exp DIVIDE exp .)
    ID              reduce using rule 72 (exp -> exp DIVIDE exp .)
    RESID           reduce using rule 72 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 72 (exp -> exp DIVIDE exp .)
    end             reduce using rule 72 (exp -> exp DIVIDE exp .)
    until           reduce using rule 72 (exp -> exp DIVIDE exp .)
    else            reduce using rule 72 (exp -> exp DIVIDE exp .)
    elseif          reduce using rule 72 (exp -> exp DIVIDE exp .)
    POWER           shift and go to state 88

  ! POWER           [ reduce using rule 72 (exp -> exp DIVIDE exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 100 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! MODULO          [ shift and go to state 96 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 165

    (45) M_if1 -> empty .

    return          reduce using rule 45 (M_if1 -> empty .)
    break           reduce using rule 45 (M_if1 -> empty .)
    for             reduce using rule 45 (M_if1 -> empty .)
    while           reduce using rule 45 (M_if1 -> empty .)
    repeat          reduce using rule 45 (M_if1 -> empty .)
    do              reduce using rule 45 (M_if1 -> empty .)
    function        reduce using rule 45 (M_if1 -> empty .)
    local           reduce using rule 45 (M_if1 -> empty .)
    if              reduce using rule 45 (M_if1 -> empty .)
    LPAREN          reduce using rule 45 (M_if1 -> empty .)
    ID              reduce using rule 45 (M_if1 -> empty .)
    RESID           reduce using rule 45 (M_if1 -> empty .)


state 166

    (44) stat -> if exp then M_if1 . block ifblock end
    (46) stat -> if exp then M_if1 . block ifblock M_if3 else M_if4 block end
    (9) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    stat                           shift and go to state 14
    functioncall                   shift and go to state 11
    sdash                          shift and go to state 59
    block                          shift and go to state 205

state 167

    (56) var -> prefixexp LSQUARE exp RSQUARE .

    COMMA           reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    EQUALS          reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    LSQUARE         reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    SDOT            reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    LPAREN          reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    STRING          reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    LCURLY          reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    PLUS            reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    MINUS           reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    TIMES           reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    DIVIDE          reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    POWER           reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    LT              reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    LE              reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    GT              reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    GE              reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    NE              reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    CHECKEQ         reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    and             reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    or              reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    MODULO          reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    DBLDOTS         reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    $end            reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    SEMI            reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    end             reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    until           reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    else            reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    elseif          reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    RPAREN          reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    then            reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    do              reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    RCURLY          reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    RSQUARE         reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    return          reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    break           reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    for             reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    while           reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    repeat          reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    function        reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    local           reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    if              reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    ID              reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)
    RESID           reduce using rule 56 (var -> prefixexp LSQUARE exp RSQUARE .)


state 168

    (59) explist -> explist COMMA . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 206
    var                            shift and go to state 29
    names                          shift and go to state 4

state 169

    (26) args -> LPAREN explist RPAREN .

    SEMI            reduce using rule 26 (args -> LPAREN explist RPAREN .)
    return          reduce using rule 26 (args -> LPAREN explist RPAREN .)
    break           reduce using rule 26 (args -> LPAREN explist RPAREN .)
    for             reduce using rule 26 (args -> LPAREN explist RPAREN .)
    while           reduce using rule 26 (args -> LPAREN explist RPAREN .)
    repeat          reduce using rule 26 (args -> LPAREN explist RPAREN .)
    do              reduce using rule 26 (args -> LPAREN explist RPAREN .)
    function        reduce using rule 26 (args -> LPAREN explist RPAREN .)
    local           reduce using rule 26 (args -> LPAREN explist RPAREN .)
    if              reduce using rule 26 (args -> LPAREN explist RPAREN .)
    LPAREN          reduce using rule 26 (args -> LPAREN explist RPAREN .)
    ID              reduce using rule 26 (args -> LPAREN explist RPAREN .)
    RESID           reduce using rule 26 (args -> LPAREN explist RPAREN .)
    $end            reduce using rule 26 (args -> LPAREN explist RPAREN .)
    LSQUARE         reduce using rule 26 (args -> LPAREN explist RPAREN .)
    SDOT            reduce using rule 26 (args -> LPAREN explist RPAREN .)
    STRING          reduce using rule 26 (args -> LPAREN explist RPAREN .)
    LCURLY          reduce using rule 26 (args -> LPAREN explist RPAREN .)
    end             reduce using rule 26 (args -> LPAREN explist RPAREN .)
    until           reduce using rule 26 (args -> LPAREN explist RPAREN .)
    else            reduce using rule 26 (args -> LPAREN explist RPAREN .)
    elseif          reduce using rule 26 (args -> LPAREN explist RPAREN .)
    COMMA           reduce using rule 26 (args -> LPAREN explist RPAREN .)
    PLUS            reduce using rule 26 (args -> LPAREN explist RPAREN .)
    MINUS           reduce using rule 26 (args -> LPAREN explist RPAREN .)
    TIMES           reduce using rule 26 (args -> LPAREN explist RPAREN .)
    DIVIDE          reduce using rule 26 (args -> LPAREN explist RPAREN .)
    POWER           reduce using rule 26 (args -> LPAREN explist RPAREN .)
    LT              reduce using rule 26 (args -> LPAREN explist RPAREN .)
    LE              reduce using rule 26 (args -> LPAREN explist RPAREN .)
    GT              reduce using rule 26 (args -> LPAREN explist RPAREN .)
    GE              reduce using rule 26 (args -> LPAREN explist RPAREN .)
    NE              reduce using rule 26 (args -> LPAREN explist RPAREN .)
    CHECKEQ         reduce using rule 26 (args -> LPAREN explist RPAREN .)
    and             reduce using rule 26 (args -> LPAREN explist RPAREN .)
    or              reduce using rule 26 (args -> LPAREN explist RPAREN .)
    MODULO          reduce using rule 26 (args -> LPAREN explist RPAREN .)
    DBLDOTS         reduce using rule 26 (args -> LPAREN explist RPAREN .)
    RPAREN          reduce using rule 26 (args -> LPAREN explist RPAREN .)
    then            reduce using rule 26 (args -> LPAREN explist RPAREN .)
    RCURLY          reduce using rule 26 (args -> LPAREN explist RPAREN .)
    RSQUARE         reduce using rule 26 (args -> LPAREN explist RPAREN .)


state 170

    (13) stat -> for namelist in explist . do block end
    (59) explist -> explist . COMMA exp

    do              shift and go to state 207
    COMMA           shift and go to state 168


state 171

    (11) stat -> for names EQUALS exp . COMMA exp do block end
    (12) stat -> for names EQUALS exp . COMMA exp COMMA exp do block end
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           shift and go to state 208
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 172

    (42) comid -> COMMA names . comid
    (42) comid -> . COMMA names comid
    (43) comid -> . empty
    (115) empty -> .

    COMMA           shift and go to state 113
    in              reduce using rule 115 (empty -> .)
    EQUALS          reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    return          reduce using rule 115 (empty -> .)
    break           reduce using rule 115 (empty -> .)
    for             reduce using rule 115 (empty -> .)
    while           reduce using rule 115 (empty -> .)
    repeat          reduce using rule 115 (empty -> .)
    do              reduce using rule 115 (empty -> .)
    function        reduce using rule 115 (empty -> .)
    local           reduce using rule 115 (empty -> .)
    if              reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RESID           reduce using rule 115 (empty -> .)
    $end            reduce using rule 115 (empty -> .)
    end             reduce using rule 115 (empty -> .)
    until           reduce using rule 115 (empty -> .)
    else            reduce using rule 115 (empty -> .)
    elseif          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)

  ! COMMA           [ reduce using rule 115 (empty -> .) ]

    empty                          shift and go to state 112
    comid                          shift and go to state 209

state 173

    (40) comvar -> COMMA var comvar .

    EQUALS          reduce using rule 40 (comvar -> COMMA var comvar .)


state 174

    (29) parlist -> namelist .
    (30) parlist -> namelist . comtrp
    (32) comtrp -> . COMMA TRPLDOTS

    RPAREN          reduce using rule 29 (parlist -> namelist .)
    COMMA           shift and go to state 210

    comtrp                         shift and go to state 211

state 175

    (31) parlist -> TRPLDOTS .

    RPAREN          reduce using rule 31 (parlist -> TRPLDOTS .)


state 176

    (23) funcbody -> LPAREN parlist . RPAREN block end

    RPAREN          shift and go to state 212


state 177

    (22) funcbody -> LPAREN RPAREN . block end
    (9) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    functioncall                   shift and go to state 11
    stat                           shift and go to state 14
    sdash                          shift and go to state 59
    block                          shift and go to state 213

state 178

    (38) dotid -> SDOT names . dotid
    (38) dotid -> . SDOT names dotid
    (39) dotid -> . empty
    (115) empty -> .

    SDOT            shift and go to state 120
    COLON           reduce using rule 115 (empty -> .)

    dotid                          shift and go to state 214
    empty                          shift and go to state 122

state 179

    (36) funcname -> names dotid COLON .

    LPAREN          reduce using rule 36 (funcname -> names dotid COLON .)


state 180

    (15) stat -> repeat block until exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    SEMI            reduce using rule 15 (stat -> repeat block until exp .)
    return          reduce using rule 15 (stat -> repeat block until exp .)
    break           reduce using rule 15 (stat -> repeat block until exp .)
    for             reduce using rule 15 (stat -> repeat block until exp .)
    while           reduce using rule 15 (stat -> repeat block until exp .)
    repeat          reduce using rule 15 (stat -> repeat block until exp .)
    do              reduce using rule 15 (stat -> repeat block until exp .)
    function        reduce using rule 15 (stat -> repeat block until exp .)
    local           reduce using rule 15 (stat -> repeat block until exp .)
    if              reduce using rule 15 (stat -> repeat block until exp .)
    LPAREN          reduce using rule 15 (stat -> repeat block until exp .)
    ID              reduce using rule 15 (stat -> repeat block until exp .)
    RESID           reduce using rule 15 (stat -> repeat block until exp .)
    end             reduce using rule 15 (stat -> repeat block until exp .)
    $end            reduce using rule 15 (stat -> repeat block until exp .)
    until           reduce using rule 15 (stat -> repeat block until exp .)
    else            reduce using rule 15 (stat -> repeat block until exp .)
    elseif          reduce using rule 15 (stat -> repeat block until exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 181

    (86) retexplist -> retexplist COMMA retexp .

    COMMA           reduce using rule 86 (retexplist -> retexplist COMMA retexp .)
    $end            reduce using rule 86 (retexplist -> retexplist COMMA retexp .)
    SEMI            reduce using rule 86 (retexplist -> retexplist COMMA retexp .)
    end             reduce using rule 86 (retexplist -> retexplist COMMA retexp .)
    until           reduce using rule 86 (retexplist -> retexplist COMMA retexp .)
    else            reduce using rule 86 (retexplist -> retexplist COMMA retexp .)
    elseif          reduce using rule 86 (retexplist -> retexplist COMMA retexp .)


state 182

    (106) retexp -> exp and exp .
    (80) exp -> exp and exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 106 (retexp -> exp and exp .)
    $end            reduce using rule 106 (retexp -> exp and exp .)
    SEMI            reduce using rule 106 (retexp -> exp and exp .)
    end             reduce using rule 106 (retexp -> exp and exp .)
    until           reduce using rule 106 (retexp -> exp and exp .)
    else            reduce using rule 106 (retexp -> exp and exp .)
    elseif          reduce using rule 106 (retexp -> exp and exp .)
    LT              reduce using rule 80 (exp -> exp and exp .)
    LE              reduce using rule 80 (exp -> exp and exp .)
    GT              reduce using rule 80 (exp -> exp and exp .)
    GE              reduce using rule 80 (exp -> exp and exp .)
    NE              reduce using rule 80 (exp -> exp and exp .)
    CHECKEQ         reduce using rule 80 (exp -> exp and exp .)
    and             reduce using rule 80 (exp -> exp and exp .)
    or              reduce using rule 80 (exp -> exp and exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 80 (exp -> exp and exp .) ]
  ! MINUS           [ reduce using rule 80 (exp -> exp and exp .) ]
  ! TIMES           [ reduce using rule 80 (exp -> exp and exp .) ]
  ! DIVIDE          [ reduce using rule 80 (exp -> exp and exp .) ]
  ! POWER           [ reduce using rule 80 (exp -> exp and exp .) ]
  ! MODULO          [ reduce using rule 80 (exp -> exp and exp .) ]
  ! DBLDOTS         [ reduce using rule 80 (exp -> exp and exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 183

    (101) retexp -> exp LE exp .
    (75) exp -> exp LE exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 101 (retexp -> exp LE exp .)
    $end            reduce using rule 101 (retexp -> exp LE exp .)
    SEMI            reduce using rule 101 (retexp -> exp LE exp .)
    end             reduce using rule 101 (retexp -> exp LE exp .)
    until           reduce using rule 101 (retexp -> exp LE exp .)
    else            reduce using rule 101 (retexp -> exp LE exp .)
    elseif          reduce using rule 101 (retexp -> exp LE exp .)
    LT              reduce using rule 75 (exp -> exp LE exp .)
    LE              reduce using rule 75 (exp -> exp LE exp .)
    GT              reduce using rule 75 (exp -> exp LE exp .)
    GE              reduce using rule 75 (exp -> exp LE exp .)
    NE              reduce using rule 75 (exp -> exp LE exp .)
    CHECKEQ         reduce using rule 75 (exp -> exp LE exp .)
    and             reduce using rule 75 (exp -> exp LE exp .)
    or              reduce using rule 75 (exp -> exp LE exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! POWER           [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! MODULO          [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! DBLDOTS         [ reduce using rule 75 (exp -> exp LE exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 184

    (108) retexp -> exp MODULO exp .
    (82) exp -> exp MODULO exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 108 (retexp -> exp MODULO exp .)
    $end            reduce using rule 108 (retexp -> exp MODULO exp .)
    SEMI            reduce using rule 108 (retexp -> exp MODULO exp .)
    end             reduce using rule 108 (retexp -> exp MODULO exp .)
    until           reduce using rule 108 (retexp -> exp MODULO exp .)
    else            reduce using rule 108 (retexp -> exp MODULO exp .)
    elseif          reduce using rule 108 (retexp -> exp MODULO exp .)
    PLUS            reduce using rule 82 (exp -> exp MODULO exp .)
    MINUS           reduce using rule 82 (exp -> exp MODULO exp .)
    TIMES           reduce using rule 82 (exp -> exp MODULO exp .)
    DIVIDE          reduce using rule 82 (exp -> exp MODULO exp .)
    LT              reduce using rule 82 (exp -> exp MODULO exp .)
    LE              reduce using rule 82 (exp -> exp MODULO exp .)
    GT              reduce using rule 82 (exp -> exp MODULO exp .)
    GE              reduce using rule 82 (exp -> exp MODULO exp .)
    NE              reduce using rule 82 (exp -> exp MODULO exp .)
    CHECKEQ         reduce using rule 82 (exp -> exp MODULO exp .)
    and             reduce using rule 82 (exp -> exp MODULO exp .)
    or              reduce using rule 82 (exp -> exp MODULO exp .)
    MODULO          reduce using rule 82 (exp -> exp MODULO exp .)
    DBLDOTS         reduce using rule 82 (exp -> exp MODULO exp .)
    POWER           shift and go to state 88

  ! POWER           [ reduce using rule 82 (exp -> exp MODULO exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 100 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! MODULO          [ shift and go to state 96 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 185

    (98) retexp -> exp DIVIDE exp .
    (72) exp -> exp DIVIDE exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 98 (retexp -> exp DIVIDE exp .)
    $end            reduce using rule 98 (retexp -> exp DIVIDE exp .)
    SEMI            reduce using rule 98 (retexp -> exp DIVIDE exp .)
    end             reduce using rule 98 (retexp -> exp DIVIDE exp .)
    until           reduce using rule 98 (retexp -> exp DIVIDE exp .)
    else            reduce using rule 98 (retexp -> exp DIVIDE exp .)
    elseif          reduce using rule 98 (retexp -> exp DIVIDE exp .)
    PLUS            reduce using rule 72 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 72 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 72 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 72 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 72 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 72 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 72 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 72 (exp -> exp DIVIDE exp .)
    NE              reduce using rule 72 (exp -> exp DIVIDE exp .)
    CHECKEQ         reduce using rule 72 (exp -> exp DIVIDE exp .)
    and             reduce using rule 72 (exp -> exp DIVIDE exp .)
    or              reduce using rule 72 (exp -> exp DIVIDE exp .)
    MODULO          reduce using rule 72 (exp -> exp DIVIDE exp .)
    DBLDOTS         reduce using rule 72 (exp -> exp DIVIDE exp .)
    POWER           shift and go to state 88

  ! POWER           [ reduce using rule 72 (exp -> exp DIVIDE exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 100 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! MODULO          [ shift and go to state 96 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 186

    (99) retexp -> exp POWER exp .
    (73) exp -> exp POWER exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 99 (retexp -> exp POWER exp .)
    $end            reduce using rule 99 (retexp -> exp POWER exp .)
    SEMI            reduce using rule 99 (retexp -> exp POWER exp .)
    end             reduce using rule 99 (retexp -> exp POWER exp .)
    until           reduce using rule 99 (retexp -> exp POWER exp .)
    else            reduce using rule 99 (retexp -> exp POWER exp .)
    elseif          reduce using rule 99 (retexp -> exp POWER exp .)
    PLUS            reduce using rule 73 (exp -> exp POWER exp .)
    MINUS           reduce using rule 73 (exp -> exp POWER exp .)
    TIMES           reduce using rule 73 (exp -> exp POWER exp .)
    DIVIDE          reduce using rule 73 (exp -> exp POWER exp .)
    LT              reduce using rule 73 (exp -> exp POWER exp .)
    LE              reduce using rule 73 (exp -> exp POWER exp .)
    GT              reduce using rule 73 (exp -> exp POWER exp .)
    GE              reduce using rule 73 (exp -> exp POWER exp .)
    NE              reduce using rule 73 (exp -> exp POWER exp .)
    CHECKEQ         reduce using rule 73 (exp -> exp POWER exp .)
    and             reduce using rule 73 (exp -> exp POWER exp .)
    or              reduce using rule 73 (exp -> exp POWER exp .)
    MODULO          reduce using rule 73 (exp -> exp POWER exp .)
    DBLDOTS         reduce using rule 73 (exp -> exp POWER exp .)
    POWER           shift and go to state 88

  ! POWER           [ reduce using rule 73 (exp -> exp POWER exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 100 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! MODULO          [ shift and go to state 96 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 187

    (107) retexp -> exp or exp .
    (81) exp -> exp or exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 107 (retexp -> exp or exp .)
    $end            reduce using rule 107 (retexp -> exp or exp .)
    SEMI            reduce using rule 107 (retexp -> exp or exp .)
    end             reduce using rule 107 (retexp -> exp or exp .)
    until           reduce using rule 107 (retexp -> exp or exp .)
    else            reduce using rule 107 (retexp -> exp or exp .)
    elseif          reduce using rule 107 (retexp -> exp or exp .)
    LT              reduce using rule 81 (exp -> exp or exp .)
    LE              reduce using rule 81 (exp -> exp or exp .)
    GT              reduce using rule 81 (exp -> exp or exp .)
    GE              reduce using rule 81 (exp -> exp or exp .)
    NE              reduce using rule 81 (exp -> exp or exp .)
    CHECKEQ         reduce using rule 81 (exp -> exp or exp .)
    and             reduce using rule 81 (exp -> exp or exp .)
    or              reduce using rule 81 (exp -> exp or exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 81 (exp -> exp or exp .) ]
  ! MINUS           [ reduce using rule 81 (exp -> exp or exp .) ]
  ! TIMES           [ reduce using rule 81 (exp -> exp or exp .) ]
  ! DIVIDE          [ reduce using rule 81 (exp -> exp or exp .) ]
  ! POWER           [ reduce using rule 81 (exp -> exp or exp .) ]
  ! MODULO          [ reduce using rule 81 (exp -> exp or exp .) ]
  ! DBLDOTS         [ reduce using rule 81 (exp -> exp or exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 188

    (103) retexp -> exp GE exp .
    (77) exp -> exp GE exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 103 (retexp -> exp GE exp .)
    $end            reduce using rule 103 (retexp -> exp GE exp .)
    SEMI            reduce using rule 103 (retexp -> exp GE exp .)
    end             reduce using rule 103 (retexp -> exp GE exp .)
    until           reduce using rule 103 (retexp -> exp GE exp .)
    else            reduce using rule 103 (retexp -> exp GE exp .)
    elseif          reduce using rule 103 (retexp -> exp GE exp .)
    LT              reduce using rule 77 (exp -> exp GE exp .)
    LE              reduce using rule 77 (exp -> exp GE exp .)
    GT              reduce using rule 77 (exp -> exp GE exp .)
    GE              reduce using rule 77 (exp -> exp GE exp .)
    NE              reduce using rule 77 (exp -> exp GE exp .)
    CHECKEQ         reduce using rule 77 (exp -> exp GE exp .)
    and             reduce using rule 77 (exp -> exp GE exp .)
    or              reduce using rule 77 (exp -> exp GE exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! MINUS           [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! TIMES           [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! DIVIDE          [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! POWER           [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! MODULO          [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! DBLDOTS         [ reduce using rule 77 (exp -> exp GE exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 189

    (97) retexp -> exp TIMES exp .
    (71) exp -> exp TIMES exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 97 (retexp -> exp TIMES exp .)
    $end            reduce using rule 97 (retexp -> exp TIMES exp .)
    SEMI            reduce using rule 97 (retexp -> exp TIMES exp .)
    end             reduce using rule 97 (retexp -> exp TIMES exp .)
    until           reduce using rule 97 (retexp -> exp TIMES exp .)
    else            reduce using rule 97 (retexp -> exp TIMES exp .)
    elseif          reduce using rule 97 (retexp -> exp TIMES exp .)
    PLUS            reduce using rule 71 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 71 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 71 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 71 (exp -> exp TIMES exp .)
    LT              reduce using rule 71 (exp -> exp TIMES exp .)
    LE              reduce using rule 71 (exp -> exp TIMES exp .)
    GT              reduce using rule 71 (exp -> exp TIMES exp .)
    GE              reduce using rule 71 (exp -> exp TIMES exp .)
    NE              reduce using rule 71 (exp -> exp TIMES exp .)
    CHECKEQ         reduce using rule 71 (exp -> exp TIMES exp .)
    and             reduce using rule 71 (exp -> exp TIMES exp .)
    or              reduce using rule 71 (exp -> exp TIMES exp .)
    MODULO          reduce using rule 71 (exp -> exp TIMES exp .)
    DBLDOTS         reduce using rule 71 (exp -> exp TIMES exp .)
    POWER           shift and go to state 88

  ! POWER           [ reduce using rule 71 (exp -> exp TIMES exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 100 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! MODULO          [ shift and go to state 96 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 190

    (105) retexp -> exp CHECKEQ exp .
    (79) exp -> exp CHECKEQ exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 105 (retexp -> exp CHECKEQ exp .)
    $end            reduce using rule 105 (retexp -> exp CHECKEQ exp .)
    SEMI            reduce using rule 105 (retexp -> exp CHECKEQ exp .)
    end             reduce using rule 105 (retexp -> exp CHECKEQ exp .)
    until           reduce using rule 105 (retexp -> exp CHECKEQ exp .)
    else            reduce using rule 105 (retexp -> exp CHECKEQ exp .)
    elseif          reduce using rule 105 (retexp -> exp CHECKEQ exp .)
    LT              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    LE              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    GT              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    GE              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    NE              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    CHECKEQ         reduce using rule 79 (exp -> exp CHECKEQ exp .)
    and             reduce using rule 79 (exp -> exp CHECKEQ exp .)
    or              reduce using rule 79 (exp -> exp CHECKEQ exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! MINUS           [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! TIMES           [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! DIVIDE          [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! POWER           [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! MODULO          [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! DBLDOTS         [ reduce using rule 79 (exp -> exp CHECKEQ exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 191

    (100) retexp -> exp LT exp .
    (74) exp -> exp LT exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 100 (retexp -> exp LT exp .)
    $end            reduce using rule 100 (retexp -> exp LT exp .)
    SEMI            reduce using rule 100 (retexp -> exp LT exp .)
    end             reduce using rule 100 (retexp -> exp LT exp .)
    until           reduce using rule 100 (retexp -> exp LT exp .)
    else            reduce using rule 100 (retexp -> exp LT exp .)
    elseif          reduce using rule 100 (retexp -> exp LT exp .)
    LT              reduce using rule 74 (exp -> exp LT exp .)
    LE              reduce using rule 74 (exp -> exp LT exp .)
    GT              reduce using rule 74 (exp -> exp LT exp .)
    GE              reduce using rule 74 (exp -> exp LT exp .)
    NE              reduce using rule 74 (exp -> exp LT exp .)
    CHECKEQ         reduce using rule 74 (exp -> exp LT exp .)
    and             reduce using rule 74 (exp -> exp LT exp .)
    or              reduce using rule 74 (exp -> exp LT exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! TIMES           [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! POWER           [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! MODULO          [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! DBLDOTS         [ reduce using rule 74 (exp -> exp LT exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 192

    (102) retexp -> exp GT exp .
    (76) exp -> exp GT exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 102 (retexp -> exp GT exp .)
    $end            reduce using rule 102 (retexp -> exp GT exp .)
    SEMI            reduce using rule 102 (retexp -> exp GT exp .)
    end             reduce using rule 102 (retexp -> exp GT exp .)
    until           reduce using rule 102 (retexp -> exp GT exp .)
    else            reduce using rule 102 (retexp -> exp GT exp .)
    elseif          reduce using rule 102 (retexp -> exp GT exp .)
    LT              reduce using rule 76 (exp -> exp GT exp .)
    LE              reduce using rule 76 (exp -> exp GT exp .)
    GT              reduce using rule 76 (exp -> exp GT exp .)
    GE              reduce using rule 76 (exp -> exp GT exp .)
    NE              reduce using rule 76 (exp -> exp GT exp .)
    CHECKEQ         reduce using rule 76 (exp -> exp GT exp .)
    and             reduce using rule 76 (exp -> exp GT exp .)
    or              reduce using rule 76 (exp -> exp GT exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! TIMES           [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! POWER           [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! MODULO          [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! DBLDOTS         [ reduce using rule 76 (exp -> exp GT exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 193

    (95) retexp -> exp PLUS exp .
    (69) exp -> exp PLUS exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 95 (retexp -> exp PLUS exp .)
    $end            reduce using rule 95 (retexp -> exp PLUS exp .)
    SEMI            reduce using rule 95 (retexp -> exp PLUS exp .)
    end             reduce using rule 95 (retexp -> exp PLUS exp .)
    until           reduce using rule 95 (retexp -> exp PLUS exp .)
    else            reduce using rule 95 (retexp -> exp PLUS exp .)
    elseif          reduce using rule 95 (retexp -> exp PLUS exp .)
    PLUS            reduce using rule 69 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 69 (exp -> exp PLUS exp .)
    LT              reduce using rule 69 (exp -> exp PLUS exp .)
    LE              reduce using rule 69 (exp -> exp PLUS exp .)
    GT              reduce using rule 69 (exp -> exp PLUS exp .)
    GE              reduce using rule 69 (exp -> exp PLUS exp .)
    NE              reduce using rule 69 (exp -> exp PLUS exp .)
    CHECKEQ         reduce using rule 69 (exp -> exp PLUS exp .)
    and             reduce using rule 69 (exp -> exp PLUS exp .)
    or              reduce using rule 69 (exp -> exp PLUS exp .)
    DBLDOTS         reduce using rule 69 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96

  ! TIMES           [ reduce using rule 69 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 69 (exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 69 (exp -> exp PLUS exp .) ]
  ! MODULO          [ reduce using rule 69 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 194

    (109) retexp -> exp DBLDOTS exp .
    (83) exp -> exp DBLDOTS exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 109 (retexp -> exp DBLDOTS exp .)
    $end            reduce using rule 109 (retexp -> exp DBLDOTS exp .)
    SEMI            reduce using rule 109 (retexp -> exp DBLDOTS exp .)
    end             reduce using rule 109 (retexp -> exp DBLDOTS exp .)
    until           reduce using rule 109 (retexp -> exp DBLDOTS exp .)
    else            reduce using rule 109 (retexp -> exp DBLDOTS exp .)
    elseif          reduce using rule 109 (retexp -> exp DBLDOTS exp .)
    LT              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    LE              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    GT              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    GE              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    NE              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    CHECKEQ         reduce using rule 83 (exp -> exp DBLDOTS exp .)
    and             reduce using rule 83 (exp -> exp DBLDOTS exp .)
    or              reduce using rule 83 (exp -> exp DBLDOTS exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! MINUS           [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! TIMES           [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! DIVIDE          [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! POWER           [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! MODULO          [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! DBLDOTS         [ reduce using rule 83 (exp -> exp DBLDOTS exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 195

    (96) retexp -> exp MINUS exp .
    (70) exp -> exp MINUS exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 96 (retexp -> exp MINUS exp .)
    $end            reduce using rule 96 (retexp -> exp MINUS exp .)
    SEMI            reduce using rule 96 (retexp -> exp MINUS exp .)
    end             reduce using rule 96 (retexp -> exp MINUS exp .)
    until           reduce using rule 96 (retexp -> exp MINUS exp .)
    else            reduce using rule 96 (retexp -> exp MINUS exp .)
    elseif          reduce using rule 96 (retexp -> exp MINUS exp .)
    PLUS            reduce using rule 70 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 70 (exp -> exp MINUS exp .)
    LT              reduce using rule 70 (exp -> exp MINUS exp .)
    LE              reduce using rule 70 (exp -> exp MINUS exp .)
    GT              reduce using rule 70 (exp -> exp MINUS exp .)
    GE              reduce using rule 70 (exp -> exp MINUS exp .)
    NE              reduce using rule 70 (exp -> exp MINUS exp .)
    CHECKEQ         reduce using rule 70 (exp -> exp MINUS exp .)
    and             reduce using rule 70 (exp -> exp MINUS exp .)
    or              reduce using rule 70 (exp -> exp MINUS exp .)
    DBLDOTS         reduce using rule 70 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96

  ! TIMES           [ reduce using rule 70 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 70 (exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 70 (exp -> exp MINUS exp .) ]
  ! MODULO          [ reduce using rule 70 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 95 ]
  ! MINUS           [ shift and go to state 98 ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]
  ! DBLDOTS         [ shift and go to state 97 ]


state 196

    (104) retexp -> exp NE exp .
    (78) exp -> exp NE exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 104 (retexp -> exp NE exp .)
    $end            reduce using rule 104 (retexp -> exp NE exp .)
    SEMI            reduce using rule 104 (retexp -> exp NE exp .)
    end             reduce using rule 104 (retexp -> exp NE exp .)
    until           reduce using rule 104 (retexp -> exp NE exp .)
    else            reduce using rule 104 (retexp -> exp NE exp .)
    elseif          reduce using rule 104 (retexp -> exp NE exp .)
    LT              reduce using rule 78 (exp -> exp NE exp .)
    LE              reduce using rule 78 (exp -> exp NE exp .)
    GT              reduce using rule 78 (exp -> exp NE exp .)
    GE              reduce using rule 78 (exp -> exp NE exp .)
    NE              reduce using rule 78 (exp -> exp NE exp .)
    CHECKEQ         reduce using rule 78 (exp -> exp NE exp .)
    and             reduce using rule 78 (exp -> exp NE exp .)
    or              reduce using rule 78 (exp -> exp NE exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97

  ! PLUS            [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! MINUS           [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! TIMES           [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! DIVIDE          [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! POWER           [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! MODULO          [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! DBLDOTS         [ reduce using rule 78 (exp -> exp NE exp .) ]
  ! LT              [ shift and go to state 93 ]
  ! LE              [ shift and go to state 86 ]
  ! GT              [ shift and go to state 94 ]
  ! GE              [ shift and go to state 90 ]
  ! NE              [ shift and go to state 99 ]
  ! CHECKEQ         [ shift and go to state 92 ]
  ! and             [ shift and go to state 85 ]
  ! or              [ shift and go to state 89 ]


state 197

    (18) stat -> local function names funcbody .

    SEMI            reduce using rule 18 (stat -> local function names funcbody .)
    return          reduce using rule 18 (stat -> local function names funcbody .)
    break           reduce using rule 18 (stat -> local function names funcbody .)
    for             reduce using rule 18 (stat -> local function names funcbody .)
    while           reduce using rule 18 (stat -> local function names funcbody .)
    repeat          reduce using rule 18 (stat -> local function names funcbody .)
    do              reduce using rule 18 (stat -> local function names funcbody .)
    function        reduce using rule 18 (stat -> local function names funcbody .)
    local           reduce using rule 18 (stat -> local function names funcbody .)
    if              reduce using rule 18 (stat -> local function names funcbody .)
    LPAREN          reduce using rule 18 (stat -> local function names funcbody .)
    ID              reduce using rule 18 (stat -> local function names funcbody .)
    RESID           reduce using rule 18 (stat -> local function names funcbody .)
    end             reduce using rule 18 (stat -> local function names funcbody .)
    $end            reduce using rule 18 (stat -> local function names funcbody .)
    until           reduce using rule 18 (stat -> local function names funcbody .)
    else            reduce using rule 18 (stat -> local function names funcbody .)
    elseif          reduce using rule 18 (stat -> local function names funcbody .)


state 198

    (20) stat -> local namelist EQUALS explist .
    (59) explist -> explist . COMMA exp

    SEMI            reduce using rule 20 (stat -> local namelist EQUALS explist .)
    return          reduce using rule 20 (stat -> local namelist EQUALS explist .)
    break           reduce using rule 20 (stat -> local namelist EQUALS explist .)
    for             reduce using rule 20 (stat -> local namelist EQUALS explist .)
    while           reduce using rule 20 (stat -> local namelist EQUALS explist .)
    repeat          reduce using rule 20 (stat -> local namelist EQUALS explist .)
    do              reduce using rule 20 (stat -> local namelist EQUALS explist .)
    function        reduce using rule 20 (stat -> local namelist EQUALS explist .)
    local           reduce using rule 20 (stat -> local namelist EQUALS explist .)
    if              reduce using rule 20 (stat -> local namelist EQUALS explist .)
    LPAREN          reduce using rule 20 (stat -> local namelist EQUALS explist .)
    ID              reduce using rule 20 (stat -> local namelist EQUALS explist .)
    RESID           reduce using rule 20 (stat -> local namelist EQUALS explist .)
    end             reduce using rule 20 (stat -> local namelist EQUALS explist .)
    $end            reduce using rule 20 (stat -> local namelist EQUALS explist .)
    until           reduce using rule 20 (stat -> local namelist EQUALS explist .)
    else            reduce using rule 20 (stat -> local namelist EQUALS explist .)
    elseif          reduce using rule 20 (stat -> local namelist EQUALS explist .)
    COMMA           shift and go to state 168


state 199

    (14) stat -> while exp do block . end

    end             shift and go to state 215


state 200

    (129) field -> names EQUALS exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 129 (field -> names EQUALS exp .)
    SEMI            reduce using rule 129 (field -> names EQUALS exp .)
    RCURLY          reduce using rule 129 (field -> names EQUALS exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 201

    (124) fieldlist -> field fieldseplist fieldsep .
    (126) fieldseplist -> fieldseplist fieldsep . field
    (128) field -> . LSQUARE exp RSQUARE EQUALS exp
    (129) field -> . names EQUALS exp
    (130) field -> . exp
    (133) names -> . ID
    (134) names -> . RESID
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args

    RCURLY          reduce using rule 124 (fieldlist -> field fieldseplist fieldsep .)
    LSQUARE         shift and go to state 84
    ID              shift and go to state 18
    RESID           shift and go to state 1
    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    field                          shift and go to state 216
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    names                          shift and go to state 79
    exp                            shift and go to state 83
    var                            shift and go to state 29

state 202

    (131) fieldsep -> COMMA .

    LSQUARE         reduce using rule 131 (fieldsep -> COMMA .)
    ID              reduce using rule 131 (fieldsep -> COMMA .)
    RESID           reduce using rule 131 (fieldsep -> COMMA .)
    nil             reduce using rule 131 (fieldsep -> COMMA .)
    false           reduce using rule 131 (fieldsep -> COMMA .)
    true            reduce using rule 131 (fieldsep -> COMMA .)
    STRING          reduce using rule 131 (fieldsep -> COMMA .)
    TRPLDOTS        reduce using rule 131 (fieldsep -> COMMA .)
    function        reduce using rule 131 (fieldsep -> COMMA .)
    INTEGER         reduce using rule 131 (fieldsep -> COMMA .)
    FLOAT           reduce using rule 131 (fieldsep -> COMMA .)
    HEX             reduce using rule 131 (fieldsep -> COMMA .)
    LPAREN          reduce using rule 131 (fieldsep -> COMMA .)
    LCURLY          reduce using rule 131 (fieldsep -> COMMA .)
    MINUS           reduce using rule 131 (fieldsep -> COMMA .)
    not             reduce using rule 131 (fieldsep -> COMMA .)
    HASH            reduce using rule 131 (fieldsep -> COMMA .)
    RCURLY          reduce using rule 131 (fieldsep -> COMMA .)


state 203

    (132) fieldsep -> SEMI .

    LSQUARE         reduce using rule 132 (fieldsep -> SEMI .)
    ID              reduce using rule 132 (fieldsep -> SEMI .)
    RESID           reduce using rule 132 (fieldsep -> SEMI .)
    nil             reduce using rule 132 (fieldsep -> SEMI .)
    false           reduce using rule 132 (fieldsep -> SEMI .)
    true            reduce using rule 132 (fieldsep -> SEMI .)
    STRING          reduce using rule 132 (fieldsep -> SEMI .)
    TRPLDOTS        reduce using rule 132 (fieldsep -> SEMI .)
    function        reduce using rule 132 (fieldsep -> SEMI .)
    INTEGER         reduce using rule 132 (fieldsep -> SEMI .)
    FLOAT           reduce using rule 132 (fieldsep -> SEMI .)
    HEX             reduce using rule 132 (fieldsep -> SEMI .)
    LPAREN          reduce using rule 132 (fieldsep -> SEMI .)
    LCURLY          reduce using rule 132 (fieldsep -> SEMI .)
    MINUS           reduce using rule 132 (fieldsep -> SEMI .)
    not             reduce using rule 132 (fieldsep -> SEMI .)
    HASH            reduce using rule 132 (fieldsep -> SEMI .)
    RCURLY          reduce using rule 132 (fieldsep -> SEMI .)


state 204

    (128) field -> LSQUARE exp RSQUARE . EQUALS exp

    EQUALS          shift and go to state 217


state 205

    (44) stat -> if exp then M_if1 block . ifblock end
    (46) stat -> if exp then M_if1 block . ifblock M_if3 else M_if4 block end
    (50) ifblock -> . ifblock M_if5 elseif M_if6 exp then block
    (51) ifblock -> . empty
    (115) empty -> .

    end             reduce using rule 115 (empty -> .)
    else            reduce using rule 115 (empty -> .)
    elseif          reduce using rule 115 (empty -> .)

    ifblock                        shift and go to state 218
    empty                          shift and go to state 219

state 206

    (59) explist -> explist COMMA exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    do              reduce using rule 59 (explist -> explist COMMA exp .)
    COMMA           reduce using rule 59 (explist -> explist COMMA exp .)
    SEMI            reduce using rule 59 (explist -> explist COMMA exp .)
    return          reduce using rule 59 (explist -> explist COMMA exp .)
    break           reduce using rule 59 (explist -> explist COMMA exp .)
    for             reduce using rule 59 (explist -> explist COMMA exp .)
    while           reduce using rule 59 (explist -> explist COMMA exp .)
    repeat          reduce using rule 59 (explist -> explist COMMA exp .)
    function        reduce using rule 59 (explist -> explist COMMA exp .)
    local           reduce using rule 59 (explist -> explist COMMA exp .)
    if              reduce using rule 59 (explist -> explist COMMA exp .)
    LPAREN          reduce using rule 59 (explist -> explist COMMA exp .)
    ID              reduce using rule 59 (explist -> explist COMMA exp .)
    RESID           reduce using rule 59 (explist -> explist COMMA exp .)
    $end            reduce using rule 59 (explist -> explist COMMA exp .)
    end             reduce using rule 59 (explist -> explist COMMA exp .)
    until           reduce using rule 59 (explist -> explist COMMA exp .)
    else            reduce using rule 59 (explist -> explist COMMA exp .)
    elseif          reduce using rule 59 (explist -> explist COMMA exp .)
    RPAREN          reduce using rule 59 (explist -> explist COMMA exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 207

    (13) stat -> for namelist in explist do . block end
    (9) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    functioncall                   shift and go to state 11
    stat                           shift and go to state 14
    sdash                          shift and go to state 59
    block                          shift and go to state 220

state 208

    (11) stat -> for names EQUALS exp COMMA . exp do block end
    (12) stat -> for names EQUALS exp COMMA . exp COMMA exp do block end
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    names                          shift and go to state 4
    exp                            shift and go to state 221
    var                            shift and go to state 29

state 209

    (42) comid -> COMMA names comid .

    EQUALS          reduce using rule 42 (comid -> COMMA names comid .)
    SEMI            reduce using rule 42 (comid -> COMMA names comid .)
    return          reduce using rule 42 (comid -> COMMA names comid .)
    break           reduce using rule 42 (comid -> COMMA names comid .)
    for             reduce using rule 42 (comid -> COMMA names comid .)
    while           reduce using rule 42 (comid -> COMMA names comid .)
    repeat          reduce using rule 42 (comid -> COMMA names comid .)
    do              reduce using rule 42 (comid -> COMMA names comid .)
    function        reduce using rule 42 (comid -> COMMA names comid .)
    local           reduce using rule 42 (comid -> COMMA names comid .)
    if              reduce using rule 42 (comid -> COMMA names comid .)
    LPAREN          reduce using rule 42 (comid -> COMMA names comid .)
    ID              reduce using rule 42 (comid -> COMMA names comid .)
    RESID           reduce using rule 42 (comid -> COMMA names comid .)
    $end            reduce using rule 42 (comid -> COMMA names comid .)
    end             reduce using rule 42 (comid -> COMMA names comid .)
    until           reduce using rule 42 (comid -> COMMA names comid .)
    else            reduce using rule 42 (comid -> COMMA names comid .)
    elseif          reduce using rule 42 (comid -> COMMA names comid .)
    COMMA           reduce using rule 42 (comid -> COMMA names comid .)
    RPAREN          reduce using rule 42 (comid -> COMMA names comid .)
    in              reduce using rule 42 (comid -> COMMA names comid .)


state 210

    (32) comtrp -> COMMA . TRPLDOTS

    TRPLDOTS        shift and go to state 222


state 211

    (30) parlist -> namelist comtrp .

    RPAREN          reduce using rule 30 (parlist -> namelist comtrp .)


state 212

    (23) funcbody -> LPAREN parlist RPAREN . block end
    (9) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    functioncall                   shift and go to state 11
    stat                           shift and go to state 14
    block                          shift and go to state 223
    sdash                          shift and go to state 59

state 213

    (22) funcbody -> LPAREN RPAREN block . end

    end             shift and go to state 224


state 214

    (38) dotid -> SDOT names dotid .

    COLON           reduce using rule 38 (dotid -> SDOT names dotid .)


state 215

    (14) stat -> while exp do block end .

    SEMI            reduce using rule 14 (stat -> while exp do block end .)
    return          reduce using rule 14 (stat -> while exp do block end .)
    break           reduce using rule 14 (stat -> while exp do block end .)
    for             reduce using rule 14 (stat -> while exp do block end .)
    while           reduce using rule 14 (stat -> while exp do block end .)
    repeat          reduce using rule 14 (stat -> while exp do block end .)
    do              reduce using rule 14 (stat -> while exp do block end .)
    function        reduce using rule 14 (stat -> while exp do block end .)
    local           reduce using rule 14 (stat -> while exp do block end .)
    if              reduce using rule 14 (stat -> while exp do block end .)
    LPAREN          reduce using rule 14 (stat -> while exp do block end .)
    ID              reduce using rule 14 (stat -> while exp do block end .)
    RESID           reduce using rule 14 (stat -> while exp do block end .)
    end             reduce using rule 14 (stat -> while exp do block end .)
    $end            reduce using rule 14 (stat -> while exp do block end .)
    until           reduce using rule 14 (stat -> while exp do block end .)
    else            reduce using rule 14 (stat -> while exp do block end .)
    elseif          reduce using rule 14 (stat -> while exp do block end .)


state 216

    (126) fieldseplist -> fieldseplist fieldsep field .

    COMMA           reduce using rule 126 (fieldseplist -> fieldseplist fieldsep field .)
    SEMI            reduce using rule 126 (fieldseplist -> fieldseplist fieldsep field .)
    RCURLY          reduce using rule 126 (fieldseplist -> fieldseplist fieldsep field .)


state 217

    (128) field -> LSQUARE exp RSQUARE EQUALS . exp
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 225
    var                            shift and go to state 29
    names                          shift and go to state 4

state 218

    (44) stat -> if exp then M_if1 block ifblock . end
    (46) stat -> if exp then M_if1 block ifblock . M_if3 else M_if4 block end
    (50) ifblock -> ifblock . M_if5 elseif M_if6 exp then block
    (48) M_if3 -> . empty
    (52) M_if5 -> . empty
    (115) empty -> .

    end             shift and go to state 226
    else            reduce using rule 115 (empty -> .)
    elseif          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 227
    M_if3                          shift and go to state 229
    M_if5                          shift and go to state 228

state 219

    (51) ifblock -> empty .

    end             reduce using rule 51 (ifblock -> empty .)
    else            reduce using rule 51 (ifblock -> empty .)
    elseif          reduce using rule 51 (ifblock -> empty .)


state 220

    (13) stat -> for namelist in explist do block . end

    end             shift and go to state 230


state 221

    (11) stat -> for names EQUALS exp COMMA exp . do block end
    (12) stat -> for names EQUALS exp COMMA exp . COMMA exp do block end
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    do              shift and go to state 232
    COMMA           shift and go to state 231
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 222

    (32) comtrp -> COMMA TRPLDOTS .

    RPAREN          reduce using rule 32 (comtrp -> COMMA TRPLDOTS .)


state 223

    (23) funcbody -> LPAREN parlist RPAREN block . end

    end             shift and go to state 233


state 224

    (22) funcbody -> LPAREN RPAREN block end .

    SEMI            reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    return          reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    break           reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    for             reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    while           reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    repeat          reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    do              reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    function        reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    local           reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    if              reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    LPAREN          reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    ID              reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    RESID           reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    $end            reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    end             reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    until           reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    else            reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)
    elseif          reduce using rule 22 (funcbody -> LPAREN RPAREN block end .)


state 225

    (128) field -> LSQUARE exp RSQUARE EQUALS exp .
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    COMMA           reduce using rule 128 (field -> LSQUARE exp RSQUARE EQUALS exp .)
    SEMI            reduce using rule 128 (field -> LSQUARE exp RSQUARE EQUALS exp .)
    RCURLY          reduce using rule 128 (field -> LSQUARE exp RSQUARE EQUALS exp .)
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 226

    (44) stat -> if exp then M_if1 block ifblock end .

    SEMI            reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    return          reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    break           reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    for             reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    while           reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    repeat          reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    do              reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    function        reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    local           reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    if              reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    LPAREN          reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    ID              reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    RESID           reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    end             reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    $end            reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    until           reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    else            reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)
    elseif          reduce using rule 44 (stat -> if exp then M_if1 block ifblock end .)


state 227

    (48) M_if3 -> empty .
    (52) M_if5 -> empty .

    else            reduce using rule 48 (M_if3 -> empty .)
    elseif          reduce using rule 52 (M_if5 -> empty .)


state 228

    (50) ifblock -> ifblock M_if5 . elseif M_if6 exp then block

    elseif          shift and go to state 234


state 229

    (46) stat -> if exp then M_if1 block ifblock M_if3 . else M_if4 block end

    else            shift and go to state 235


state 230

    (13) stat -> for namelist in explist do block end .

    SEMI            reduce using rule 13 (stat -> for namelist in explist do block end .)
    return          reduce using rule 13 (stat -> for namelist in explist do block end .)
    break           reduce using rule 13 (stat -> for namelist in explist do block end .)
    for             reduce using rule 13 (stat -> for namelist in explist do block end .)
    while           reduce using rule 13 (stat -> for namelist in explist do block end .)
    repeat          reduce using rule 13 (stat -> for namelist in explist do block end .)
    do              reduce using rule 13 (stat -> for namelist in explist do block end .)
    function        reduce using rule 13 (stat -> for namelist in explist do block end .)
    local           reduce using rule 13 (stat -> for namelist in explist do block end .)
    if              reduce using rule 13 (stat -> for namelist in explist do block end .)
    LPAREN          reduce using rule 13 (stat -> for namelist in explist do block end .)
    ID              reduce using rule 13 (stat -> for namelist in explist do block end .)
    RESID           reduce using rule 13 (stat -> for namelist in explist do block end .)
    end             reduce using rule 13 (stat -> for namelist in explist do block end .)
    $end            reduce using rule 13 (stat -> for namelist in explist do block end .)
    until           reduce using rule 13 (stat -> for namelist in explist do block end .)
    else            reduce using rule 13 (stat -> for namelist in explist do block end .)
    elseif          reduce using rule 13 (stat -> for namelist in explist do block end .)


state 231

    (12) stat -> for names EQUALS exp COMMA exp COMMA . exp do block end
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    names                          shift and go to state 4
    exp                            shift and go to state 236
    var                            shift and go to state 29

state 232

    (11) stat -> for names EQUALS exp COMMA exp do . block end
    (9) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    functioncall                   shift and go to state 11
    stat                           shift and go to state 14
    block                          shift and go to state 237
    sdash                          shift and go to state 59

state 233

    (23) funcbody -> LPAREN parlist RPAREN block end .

    SEMI            reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    return          reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    break           reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    for             reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    while           reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    repeat          reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    do              reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    function        reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    local           reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    if              reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    LPAREN          reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    ID              reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    RESID           reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    $end            reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    end             reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    until           reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    else            reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)
    elseif          reduce using rule 23 (funcbody -> LPAREN parlist RPAREN block end .)


state 234

    (50) ifblock -> ifblock M_if5 elseif . M_if6 exp then block
    (53) M_if6 -> . empty
    (115) empty -> .

    nil             reduce using rule 115 (empty -> .)
    false           reduce using rule 115 (empty -> .)
    true            reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    TRPLDOTS        reduce using rule 115 (empty -> .)
    function        reduce using rule 115 (empty -> .)
    INTEGER         reduce using rule 115 (empty -> .)
    FLOAT           reduce using rule 115 (empty -> .)
    HEX             reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    LCURLY          reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    not             reduce using rule 115 (empty -> .)
    HASH            reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RESID           reduce using rule 115 (empty -> .)

    M_if6                          shift and go to state 239
    empty                          shift and go to state 238

state 235

    (46) stat -> if exp then M_if1 block ifblock M_if3 else . M_if4 block end
    (49) M_if4 -> . empty
    (115) empty -> .

    return          reduce using rule 115 (empty -> .)
    break           reduce using rule 115 (empty -> .)
    for             reduce using rule 115 (empty -> .)
    while           reduce using rule 115 (empty -> .)
    repeat          reduce using rule 115 (empty -> .)
    do              reduce using rule 115 (empty -> .)
    function        reduce using rule 115 (empty -> .)
    local           reduce using rule 115 (empty -> .)
    if              reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    RESID           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 240
    M_if4                          shift and go to state 241

state 236

    (12) stat -> for names EQUALS exp COMMA exp COMMA exp . do block end
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    do              shift and go to state 242
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 237

    (11) stat -> for names EQUALS exp COMMA exp do block . end

    end             shift and go to state 243


state 238

    (53) M_if6 -> empty .

    nil             reduce using rule 53 (M_if6 -> empty .)
    false           reduce using rule 53 (M_if6 -> empty .)
    true            reduce using rule 53 (M_if6 -> empty .)
    STRING          reduce using rule 53 (M_if6 -> empty .)
    TRPLDOTS        reduce using rule 53 (M_if6 -> empty .)
    function        reduce using rule 53 (M_if6 -> empty .)
    INTEGER         reduce using rule 53 (M_if6 -> empty .)
    FLOAT           reduce using rule 53 (M_if6 -> empty .)
    HEX             reduce using rule 53 (M_if6 -> empty .)
    LPAREN          reduce using rule 53 (M_if6 -> empty .)
    LCURLY          reduce using rule 53 (M_if6 -> empty .)
    MINUS           reduce using rule 53 (M_if6 -> empty .)
    not             reduce using rule 53 (M_if6 -> empty .)
    HASH            reduce using rule 53 (M_if6 -> empty .)
    ID              reduce using rule 53 (M_if6 -> empty .)
    RESID           reduce using rule 53 (M_if6 -> empty .)


state 239

    (50) ifblock -> ifblock M_if5 elseif M_if6 . exp then block
    (61) exp -> . nil
    (62) exp -> . false
    (63) exp -> . true
    (64) exp -> . Number
    (65) exp -> . STRING
    (66) exp -> . TRPLDOTS
    (67) exp -> . function
    (68) exp -> . prefixexp
    (69) exp -> . exp PLUS exp
    (70) exp -> . exp MINUS exp
    (71) exp -> . exp TIMES exp
    (72) exp -> . exp DIVIDE exp
    (73) exp -> . exp POWER exp
    (74) exp -> . exp LT exp
    (75) exp -> . exp LE exp
    (76) exp -> . exp GT exp
    (77) exp -> . exp GE exp
    (78) exp -> . exp NE exp
    (79) exp -> . exp CHECKEQ exp
    (80) exp -> . exp and exp
    (81) exp -> . exp or exp
    (82) exp -> . exp MODULO exp
    (83) exp -> . exp DBLDOTS exp
    (84) exp -> . tableconstructor
    (85) exp -> . unop exp
    (112) Number -> . INTEGER
    (113) Number -> . FLOAT
    (114) Number -> . HEX
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (122) tableconstructor -> . LCURLY fieldlist RCURLY
    (123) tableconstructor -> . LCURLY RCURLY
    (119) unop -> . MINUS
    (120) unop -> . not
    (121) unop -> . HASH
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (24) functioncall -> . prefixexp args
    (133) names -> . ID
    (134) names -> . RESID

    nil             shift and go to state 32
    false           shift and go to state 23
    true            shift and go to state 35
    STRING          shift and go to state 27
    TRPLDOTS        shift and go to state 41
    function        shift and go to state 31
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 36
    HEX             shift and go to state 33
    LPAREN          shift and go to state 2
    LCURLY          shift and go to state 24
    MINUS           shift and go to state 26
    not             shift and go to state 34
    HASH            shift and go to state 25
    ID              shift and go to state 18
    RESID           shift and go to state 1

    prefixexp                      shift and go to state 28
    tableconstructor               shift and go to state 22
    names                          shift and go to state 4
    Number                         shift and go to state 37
    unop                           shift and go to state 40
    functioncall                   shift and go to state 38
    exp                            shift and go to state 244
    var                            shift and go to state 29

state 240

    (49) M_if4 -> empty .

    return          reduce using rule 49 (M_if4 -> empty .)
    break           reduce using rule 49 (M_if4 -> empty .)
    for             reduce using rule 49 (M_if4 -> empty .)
    while           reduce using rule 49 (M_if4 -> empty .)
    repeat          reduce using rule 49 (M_if4 -> empty .)
    do              reduce using rule 49 (M_if4 -> empty .)
    function        reduce using rule 49 (M_if4 -> empty .)
    local           reduce using rule 49 (M_if4 -> empty .)
    if              reduce using rule 49 (M_if4 -> empty .)
    LPAREN          reduce using rule 49 (M_if4 -> empty .)
    ID              reduce using rule 49 (M_if4 -> empty .)
    RESID           reduce using rule 49 (M_if4 -> empty .)


state 241

    (46) stat -> if exp then M_if1 block ifblock M_if3 else M_if4 . block end
    (9) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    stat                           shift and go to state 14
    functioncall                   shift and go to state 11
    sdash                          shift and go to state 59
    block                          shift and go to state 245

state 242

    (12) stat -> for names EQUALS exp COMMA exp COMMA exp do . block end
    (9) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    functioncall                   shift and go to state 11
    stat                           shift and go to state 14
    block                          shift and go to state 246
    sdash                          shift and go to state 59

state 243

    (11) stat -> for names EQUALS exp COMMA exp do block end .

    SEMI            reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    return          reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    break           reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    for             reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    while           reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    repeat          reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    do              reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    function        reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    local           reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    if              reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    LPAREN          reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    ID              reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    RESID           reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    end             reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    $end            reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    until           reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    else            reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)
    elseif          reduce using rule 11 (stat -> for names EQUALS exp COMMA exp do block end .)


state 244

    (50) ifblock -> ifblock M_if5 elseif M_if6 exp . then block
    (69) exp -> exp . PLUS exp
    (70) exp -> exp . MINUS exp
    (71) exp -> exp . TIMES exp
    (72) exp -> exp . DIVIDE exp
    (73) exp -> exp . POWER exp
    (74) exp -> exp . LT exp
    (75) exp -> exp . LE exp
    (76) exp -> exp . GT exp
    (77) exp -> exp . GE exp
    (78) exp -> exp . NE exp
    (79) exp -> exp . CHECKEQ exp
    (80) exp -> exp . and exp
    (81) exp -> exp . or exp
    (82) exp -> exp . MODULO exp
    (83) exp -> exp . DBLDOTS exp

    then            shift and go to state 247
    PLUS            shift and go to state 95
    MINUS           shift and go to state 98
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 100
    POWER           shift and go to state 88
    LT              shift and go to state 93
    LE              shift and go to state 86
    GT              shift and go to state 94
    GE              shift and go to state 90
    NE              shift and go to state 99
    CHECKEQ         shift and go to state 92
    and             shift and go to state 85
    or              shift and go to state 89
    MODULO          shift and go to state 96
    DBLDOTS         shift and go to state 97


state 245

    (46) stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block . end

    end             shift and go to state 248


state 246

    (12) stat -> for names EQUALS exp COMMA exp COMMA exp do block . end

    end             shift and go to state 249


state 247

    (50) ifblock -> ifblock M_if5 elseif M_if6 exp then . block
    (9) block -> . sdash
    (1) sdash -> . chunk
    (2) sdash -> . chunk laststat
    (3) sdash -> . laststat
    (4) sdash -> . chunk laststat SEMI
    (5) chunk -> . chunk stat
    (6) chunk -> . chunk stat SEMI
    (7) chunk -> . stat SEMI
    (8) chunk -> . stat
    (33) laststat -> . return retexplist
    (34) laststat -> . return
    (35) laststat -> . break
    (10) stat -> . varlist EQUALS explist
    (11) stat -> . for names EQUALS exp COMMA exp do block end
    (12) stat -> . for names EQUALS exp COMMA exp COMMA exp do block end
    (13) stat -> . for namelist in explist do block end
    (14) stat -> . while exp do block end
    (15) stat -> . repeat block until exp
    (16) stat -> . do block end
    (17) stat -> . function funcname funcbody
    (18) stat -> . local function names funcbody
    (19) stat -> . local namelist
    (20) stat -> . local namelist EQUALS explist
    (21) stat -> . functioncall
    (44) stat -> . if exp then M_if1 block ifblock end
    (46) stat -> . if exp then M_if1 block ifblock M_if3 else M_if4 block end
    (54) varlist -> . var comvar
    (24) functioncall -> . prefixexp args
    (55) var -> . names
    (56) var -> . prefixexp LSQUARE exp RSQUARE
    (57) var -> . prefixexp SDOT names
    (116) prefixexp -> . var
    (117) prefixexp -> . LPAREN exp RPAREN
    (118) prefixexp -> . functioncall
    (133) names -> . ID
    (134) names -> . RESID

    return          shift and go to state 16
    break           shift and go to state 17
    for             shift and go to state 7
    while           shift and go to state 20
    repeat          shift and go to state 15
    do              shift and go to state 13
    function        shift and go to state 12
    local           shift and go to state 19
    if              shift and go to state 5
    LPAREN          shift and go to state 2
    ID              shift and go to state 18
    RESID           shift and go to state 1

    chunk                          shift and go to state 3
    names                          shift and go to state 4
    prefixexp                      shift and go to state 6
    varlist                        shift and go to state 8
    laststat                       shift and go to state 9
    var                            shift and go to state 10
    functioncall                   shift and go to state 11
    stat                           shift and go to state 14
    sdash                          shift and go to state 59
    block                          shift and go to state 250

state 248

    (46) stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .

    SEMI            reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    return          reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    break           reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    for             reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    while           reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    repeat          reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    do              reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    function        reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    local           reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    if              reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    LPAREN          reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    ID              reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    RESID           reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    end             reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    $end            reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    until           reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    else            reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)
    elseif          reduce using rule 46 (stat -> if exp then M_if1 block ifblock M_if3 else M_if4 block end .)


state 249

    (12) stat -> for names EQUALS exp COMMA exp COMMA exp do block end .

    SEMI            reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    return          reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    break           reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    for             reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    while           reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    repeat          reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    do              reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    function        reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    local           reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    if              reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    LPAREN          reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    ID              reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    RESID           reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    end             reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    $end            reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    until           reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    else            reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)
    elseif          reduce using rule 12 (stat -> for names EQUALS exp COMMA exp COMMA exp do block end .)


state 250

    (50) ifblock -> ifblock M_if5 elseif M_if6 exp then block .

    end             reduce using rule 50 (ifblock -> ifblock M_if5 elseif M_if6 exp then block .)
    else            reduce using rule 50 (ifblock -> ifblock M_if5 elseif M_if6 exp then block .)
    elseif          reduce using rule 50 (ifblock -> ifblock M_if5 elseif M_if6 exp then block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 28 resolved as shift
WARNING: reduce/reduce conflict in state 11 resolved using rule (stat -> functioncall)
WARNING: rejected rule (prefixexp -> functioncall) in state 11
