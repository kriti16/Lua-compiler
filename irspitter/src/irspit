#! /usr/bin/python2
from __future__ import print_function
from lexer import Lualexer
import ply.yacc as yacc
import sys
import logging
from TAC import TACList
from SymbolTable import *

class node(object):
	def __init__(self, value, children = []):
		self.value = value
		self.children = children


proto = type(node(5))


class LuaParser(object):

    def __init__(self):
        lexerClass = Lualexer()
        lexer = lexerClass.lexer
        tokens = lexerClass.tokenList
        errors_list = []
        self.TAC = TACList()
        convert = {'PLUS':'+'}
        self.SymbolTable = SymbolTable()
        def p_sdash_start(p):
        	'''sdash : chunk
        	| chunk laststat
                | laststat
        	| chunk laststat SEMI'''
    
        def p_chunk(p):
            '''chunk : chunk stat
            | chunk stat SEMI
    	    | stat SEMI
            | stat
            '''
            
        def p_block_chunk(p):
            ''' block : sdash'''
        def p_stat_var_exp(p):
            '''stat :  varlist EQUALS explist
            '''
            if not self.SymbolTable.isPresentIdent(p[1]):
                self.SymbolTable.addVar(p[1])
                tempVar = self.SymbolTable.create_temp()
                p[1].Locate = tempVar
            else:
                p[1].Locate = self.SymbolTable.getIdent(p[1]).Locate
            self.TAC.inject('=',[p[1].Locate,p[3].Locate])
            
        def p_stat_statement(p):
            '''stat : do block end
            | functioncall
            | while exp do block end 
	    | repeat block until exp 
	    | if exp then block ifblock else block end 
            | if exp then block ifblock  end 
	    | for names EQUALS exp COMMA exp  do block end 
            | for names EQUALS exp COMMA exp COMMA exp do block end 
	    | for namelist in explist do block end 
	    | local namelist 
            | local namelist EQUALS explist
            | function funcname funcbody
            | local function names funcbody'''

        def p_funcbody_parlist(p):
            '''funcbody : LPAREN RPAREN block end
            | LPAREN  parlist RPAREN block end'''

        def p_functioncall_prefix(p):
            '''functioncall : prefixexp args'''


        def p_args_explist(p):
            '''args : LPAREN RPAREN
            | LPAREN explist RPAREN
            | tableconstructor
            | STRING'''

        def p_parlist_namelist(p):
            '''parlist : namelist 
            |  namelist comtrp  %prec comtrp
            | TRPLDOTS'''

        def p_comtrp_parlist(p):
            'comtrp : COMMA TRPLDOTS'

        def p_laststat_break(p):
            '''laststat : return retexplist 
            | return 
            | break'''

        def p_funcname_names(p):
            '''funcname : names dotid COLON 
            | names'''

        def p_dotid(p):
            '''dotid : SDOT names dotid 
            | empty'''

        def p_comvar(p):
            '''comvar : COMMA var comvar 
            | empty'''
            

        def p_comid(p):
            '''comid : COMMA names comid 
            | empty'''
            
        def p_ifblock_elseif(p):
            '''ifblock : ifblock elseif exp then block 
            | empty '''
        
        def p_varlist_var(p):
            '''varlist : var comvar '''
            p[0] = p[1]
                
        def p_var_names(p):
            '''var :  names 
            | prefixexp LSQUARE exp RSQUARE 
            | prefixexp SDOT names '''
            if len(p) == 2:
                tempSymbol = Symbol()
                tempSymbol.Iden = p[1]
                p[0] = tempSymbol
            
        def p_namelist_names(p):
            'namelist :  names  comid'

        def p_explist_exp(p):
            '''explist : explist COMMA exp
            | exp '''
            if len(p) == 2:
                p[0] = p[1]
            
        def p_exp_primi(p):
            '''exp :  nil 
            | false 
            | true 
            | Number 
            | STRING
            '''
            p[0] = p[1]
            
        def p_exp_oper(p):
            '''exp : TRPLDOTS 
            | function 
	    | prefixexp 
            | exp PLUS exp
            | exp MINUS exp
            | exp TIMES exp
            | exp DIVIDE exp
            | exp POWER exp
            | exp LT exp
            | exp LE exp
            | exp GT exp
            | exp GE exp
            | exp NE exp
            | exp CHECKEQ exp
            | exp and exp
            | exp or exp
            | exp MODULO exp
            | exp DBLDOTS exp
            | tableconstructor
            | unop exp  %prec unop'''
            
            ###############################################
            ## HANDLING 2 ARGUEMENTS ##
            ##############################################
            if len(p) == 2:    
                if self.SymbolTable.isPresentIdent(p[1]):
                        p[1].Locate = self.SymbolTable.getIdent(p[1]).Locate
                p[0] = p[1]
            if len(p) == 4:
                #print(vars(p),p[0])
                if self.SymbolTable.isPresentIdent(p[0]):
                        tempVar = self.SymbolTable.getIdent(p[0]).Locate
                        p[0].Type=p[1].Type #########Implement Type Check
                else:
                        tempVar = self.SymbolTable.create_temp()
                        tempSymbol = Symbol()
                        tempSymbol.Type=p[1].Type #########Implement Type Check
                        p[0] = tempSymbol
                        p[0].Locate= tempVar
                #print([vars(self.SymbolTable.scope['Main'].Vars[x]) for x in self.SymbolTable.scope['Main'].Vars])
                self.TAC.inject(p[2],[tempVar,p[1].Locate,p[2],p[3].Locate])
                    

        def p_retexplist_exp(p):
            '''retexplist : retexplist COMMA retexp
            | retexp '''


        def p_retexp_oper(p):
            '''retexp :  nil 
            | false 
            | true 
            | Number 
            | STRING 
            | TRPLDOTS 
            | prefixexp 
            | exp PLUS exp
            | exp MINUS exp
            | exp TIMES exp
            | exp DIVIDE exp
            | exp POWER exp
            | exp LT exp
            | exp LE exp
            | exp GT exp
            | exp GE exp
            | exp NE exp
            | exp CHECKEQ exp
            | exp and exp
            | exp or exp
            | exp MODULO exp
            | exp DBLDOTS exp
            | tableconstructor
	    | unop exp  %prec unop'''
            
        def p_Number_ints(p):
            '''Number : INTEGER 
            | FLOAT 
            | HEX '''
            tempNum = Symbol()
            tempNum.Type = p.slice[1].type
            tempNum.Value=p[1]
            tempNum.Locate = p[1]
            p[0] = tempNum
            #print (vars(p[0]))

        def p_empty(p):
            'empty : '
            pass


        def p_prefixexp_exp(p):
            ''' prefixexp : var 
            |  LPAREN exp RPAREN 
            | functioncall'''
            p[0] = p[1]
            #print(vars(p[0]),vars(p),"pre")
        def p_unop_ops(p):
            '''unop : MINUS
            | not
            | HASH'''
            # Error rule for syntax errors

        def p_tableconstructor_fieldlist(p):
            '''tableconstructor : LCURLY fieldlist RCURLY 
            | LCURLY RCURLY'''

        def p_fieldlist_fieldseplist(p):
            '''fieldlist : field fieldseplist fieldsep
            | field fieldseplist'''
            
        def p_fieldseplist_field(p):
            ''' fieldseplist : fieldseplist fieldsep field 
            | empty'''

        def p_field_exp(p):
            '''field : LSQUARE exp RSQUARE EQUALS exp 
            | names EQUALS exp 
            | exp'''

        def p_fieldsep_seps(p):
          '''fieldsep : COMMA 
          | SEMI'''

        def p_error(p):
            print("Syntax error with token "+p.value)
            print ("\n")

        def p_names_id(p):
            '''names : ID
            | RESID'''
            p[0] = p[1]

        precedence = (
            ('nonassoc','comtrp'),
            ('left','LPAREN'),
            ('right','RPAREN'),
            ('right','COMMA'),
            ('left','LT','GT','LE','GE','NE','CHECKEQ','and','or'),
            ('right','DBLDOTS'),
            ('left', 'PLUS', 'MINUS'),
            ('left', 'TIMES', 'DIVIDE','MODULO'),
            ('right', 'unop'),  #uminus left to handle
            ('right', 'POWER')
        )

        #self.parser = yacc.yacc(debug=True,debuglog=log,start='sdash')
        self.parser = yacc.yacc(start='sdash')




# Set up a logging object

# parser.parse(input,debug=log)

# yacc.yacc(debug=True,debuglog=log)

if __name__ == '__main__':
        fname=sys.argv[1]
        f = open(fname,'r')
        data = f.read()
        f.close()
        #print("Hello")
        parserClass = LuaParser()
        parser = parserClass.parser      
        #    result = parser.parse(data,tracking=True)
        result = parser.parse(data)
        print(parserClass.TAC.print_OpCodes())
        print([vars(parserClass.SymbolTable.scope['Main'].Vars[x]) for x in parserClass.SymbolTable.scope['Main'].Vars])
        #print("Hello")
